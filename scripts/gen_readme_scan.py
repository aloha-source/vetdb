# scripts/gen_readme_scan.py
# 目的:
#  - cat結合用の "番号順 (install order)" を正として並べる
#  - 機能(サブディレクトリ)ごとにも、同じ番号順で束ねて見せる
#  - ルートは patches/ を前提（必要に応じて ROOTS を増やせる）

import re, pathlib, datetime
from collections import defaultdict

# スキャン対象（必要なら schema も追加可: [Path("patches"), Path("schema")]）
ROOTS = [pathlib.Path("patches")]
OUT = pathlib.Path("README.md")

# 先頭の番号を install order として抽出 (例: 010_xxx.sql -> 10)
ORDER_RE = re.compile(r"^(\d+)[-_].*\.sql$", re.IGNORECASE)

def extract_order(p: pathlib.Path) -> int:
    m = ORDER_RE.match(p.name)
    if m:
        try:
            return int(m.group(1))
        except ValueError:
            pass
    # 番号が無いファイルは末尾に寄せる
    return 10_000_000

def classify(p: pathlib.Path) -> str:
    n = p.name.lower()
    if n.startswith("fk_"):  return "FK"
    if n.startswith("tr_"):  return "Trigger"
    if n.startswith("idx_"): return "Index"
    return "Main"

# テーブル名キー (例: 041_visits.sql -> visits, users.sql -> users)
def table_key(p: pathlib.Path) -> str:
    base = p.stem
    parts = base.split("_", 1)
    return parts[1] if parts[0].isdigit() and len(parts) > 1 else base

# 機能名 = 直下サブディレクトリ (patches/<feature>/...)
# Lnn_xxx は xxx に正規化 (例: L04_domain -> domain)
def feature_name(root: pathlib.Path, p: pathlib.Path) -> str:
    try:
        rel = p.relative_to(root)
    except ValueError:
        return "_misc"
    first = rel.parts[0] if len(rel.parts) > 1 else "_misc"
    m = re.match(r"^L\d+_(.+)$", first)
    return m.group(1) if m else first

# 収集
files = []
for r in ROOTS:
    if r.exists():
        files += list(r.rglob("*.sql"))

# グローバル順 (番号昇順、名前は安定化用タイブレーク)
files_sorted = sorted(files, key=lambda p: (extract_order(p), p.as_posix().lower()))

# 機能 -> テーブル -> ファイル(番号順)
by_feature = defaultdict(lambda: defaultdict(list))
for p in files_sorted:
    root = next((r for r in ROOTS if p.as_posix().startswith(r.as_posix())), None)
    feat = feature_name(root, p) if root else "_misc"
    tbl  = table_key(p)
    by_feature[feat][tbl].append(p)

def md_link(p: pathlib.Path) -> str:
    rel = p.as_posix()
    return f"[{rel}]({rel})"

def fmt_order(p: pathlib.Path) -> str:
    o = extract_order(p)
    return f"{o:04d}" if o < 10_000_000 else "----"

now = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

lines = []
lines += [
    "# Schema Index",
    "",
    "_generated by scripts/gen_readme_scan.py_",
    "",
    f"_last update: {now} UTC_",
    "",
    "## 目次",
    "- [インストール順（番号順）](#インストール順番号順)",
    "- [機能別索引](#機能別索引)",
    "",
    "----",
    "",
    "## インストール順（番号順）",
    "",
    "| # | 種別 | パス |",
    "|---:|:---:|:---|",
]

# セクション1: 全ファイルをグローバル番号順に
for p in files_sorted:
    lines.append(f"| {fmt_order(p)} | {classify(p)} | {md_link(p)} |")

lines += ["", "----", "", "## 機能別索引", ""]

# セクション2: 機能別（中も番号順）
for feat in sorted(by_feature.keys()):
    lines.append(f"### {feat}")
    # テーブル見出しはテーブル名で、配下は番号順のまま一覧
    for tbl in sorted(by_feature[feat].keys()):
        lines.append(f"#### {tbl}")
        lines.append("| # | 種別 | パス |")
        lines.append("|---:|:---:|:---|")
        for p in by_feature[feat][tbl]:
            lines.append(f"| {fmt_order(p)} | {classify(p)} | {md_link(p)} |")
        lines.append("")  # blank
    lines.append("")      # blank between features

new = "\n".join(lines)
old = OUT.read_text(encoding="utf-8") if OUT.exists() else ""
if new != old:
    OUT.write_text(new, encoding="utf-8")
    print(f"[gen] updated {OUT} (files={len(files_sorted)})")
else:
    print(f"[gen] {OUT} up-to-date (files={len(files_sorted)})")
