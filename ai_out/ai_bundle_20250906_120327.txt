# AI_BUNDLE v1
# root=patches
<<<FILE patches/0000_function_create_uuid_functions.sql>>>
/* 000_checkup_create_uuid_functions.sql */
-- @phase: create
-- @provides: function:uuid_bin_to_hex, function:uuid_hex_to_bin, function:uuid_v7_str, function:uuid_v7_bin
-- @requires:

SET NAMES utf8mb4;

DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32) DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16) DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36) NOT DETERMINISTIC
BEGIN
  /* 擬似 UUIDv7: ミリ秒エポック + 乱数（検証用） */
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');
  SET r12 = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'), LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);
  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16) NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;
<<<END patches/0000_function_create_uuid_functions.sql>>>

<<<FILE patches/0001_init_setname.sql>>>
/* =========================================================
   0001_init_setname.sql
   ---------------------------------------------------------
   ■目的
     - クライアント/サーバ間の通信文字コードを utf8mb4 に統一。
     - DDL群を実行する前に必ず適用する。
     - 各テーブルには DEFAULT CHARSET=utf8mb4 を明示済みなので、
       本ファイルは通信経路の整合性を確保するための補助。

   ■効果
     - character_set_client      = utf8mb4
     - character_set_connection  = utf8mb4
     - character_set_results     = utf8mb4

   ■注意
     - 1セッションにつき1回で十分。
     - 各テーブルに繰り返し書く必要はない。
   ========================================================= */

SET NAMES utf8mb4;
<<<END patches/0001_init_setname.sql>>>

<<<FILE patches/archive/002_individuals_p014.sql>>>
/* ============================================================
   ユーティリティ関数群
   - UUIDバイナリ/文字列の相互変換
   - UUID v7（時系列ソート性あり）の生成
   - 見本: checkups_p012.2.sql 準拠
   ============================================================ */
DELIMITER $$

/* BIN(16) → HEX文字列32桁へ変換 */
DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32)
DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

/* UUID文字列（36桁/32桁/ダッシュ混在可）→ BIN(16) に変換 */
DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16)
DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

/* UUID v7 を文字列として生成（ソートフレンドリ、ランダムビット含む） */
DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED; DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED; DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4); DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8); DECLARE t_mid CHAR(4);

  -- 現在時刻をミリ秒単位に変換
  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  -- HEX化（12桁、先頭ゼロ埋め）
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  -- ランダムビット生成
  SET r12 = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));  -- UUIDバージョン=7
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  -- UUID各部位を組み立て
  SET t_hi = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

/* UUID v7 を BINARY(16) として生成 */
DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16)
NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

/* ============================================================
   再デプロイ安全化
   - テーブル/トリガ/ビューを事前DROP
   ============================================================ */
DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP VIEW IF EXISTS individuals_hex_v;
DROP TABLE IF EXISTS individuals;

/* ============================================================
   individuals テーブル
   目的:
   - 農場に属する個体（牛など）の基本情報を管理
   - uuid: BIN(16) をSoTキーとする（UUID v7）
   - 母子関係（遺伝母/哺育母）を分離管理
   - 父情報はメモのみ
   - ソフトデリート対応
   ============================================================ */
CREATE TABLE individuals (
  id                      INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, -- サロゲートPK（内部用）

  uuid                    BINARY(16)  NOT NULL UNIQUE,             -- グローバル一意ID（UUID v7, BIN16）
  farm_uuid               BINARY(16)  NOT NULL,                    -- 所属農場（farms.uuid, BIN16）
  user_uuid               BINARY(16)  NOT NULL,                    -- 登録/所有ユーザ（users.uuid, BIN16）

  name                    VARCHAR(100) NULL,                       -- 個体名（任意）
  ear_tag                 CHAR(10)     NULL,                       -- 耳標（全国一意10桁、未付与時NULL）
  status                  ENUM('active','sold','dead','culled')    -- 個体状態
                           NOT NULL DEFAULT 'active',              -- culled=廃用淘汰

  gender                  ENUM('female','male','cast','unknown')   -- 性別
                           NOT NULL DEFAULT 'unknown',             -- genders参照廃止→ENUM化

  birth_date              DATE         NULL,                       -- 生年月日
  death_date              DATE         NULL,                       -- 死亡日（任意記録）

  sire_name               VARCHAR(100) NULL,                       -- 父牛名（メモのみ、FKなし）

  genetic_dam_uuid        BINARY(16)   NULL,                       -- 遺伝母 UUID（自己参照FK）
  nursing_dam_uuid        BINARY(16)   NULL,                       -- 哺育母 UUID（自己参照FK）

  -- 母牛確定時のスナップ（帳票/検索用に保持）
  genetic_dam_ear_tag     CHAR(10)     NULL,
  genetic_dam_name        VARCHAR(100) NULL,
  nursing_dam_ear_tag     CHAR(10)     NULL,
  nursing_dam_name        VARCHAR(100) NULL,

  created_at              DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, 
  updated_at              DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at              DATETIME NULL,                           -- ソフトデリート（NULL=有効）

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),                      -- 耳標は全国一意、NULLは重複可

  -- インデックス設計（検索/一覧用）
  KEY idx_individuals_farm_name   (farm_uuid, name),
  KEY idx_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),

  -- 外部キー（farm/userは削除不可、参照整合性を保持）
  CONSTRAINT fk_individuals_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_individuals_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  -- 自己参照FK（母リンク）
  -- 母個体が削除された場合は子の dam_uuid を NULL化（当時の耳標/名前メモは保持）
  CONSTRAINT fk_individuals_genetic_dam
    FOREIGN KEY (genetic_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_individuals_nursing_dam
    FOREIGN KEY (nursing_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  -- 自傷防止（母=自分は禁止）
  CONSTRAINT chk_individuals_no_self_genetic
    CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing
    CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

/* ============================================================
   トリガ
   - INSERT時に uuid が NULL またはゼロUUIDなら
     uuid_v7_bin() を自動採番
   ============================================================ */
DELIMITER $$
CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

/* ============================================================
   HEX表現ビュー
   - UUID(BIN16)を文字列HEX化して確認・デバッグ用
   ============================================================ */
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)             AS uuid_hex,
  uuid_bin_to_hex(farm_uuid)        AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)        AS user_uuid_hex,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid) AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid) AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;
<<<END patches/archive/002_individuals_p014.sql>>>

<<<FILE patches/0100_checkup_create_individuals.sql>>>
/* 100_checkup_create_individuals.sql */
-- @phase: create
-- @provides: table:individuals
-- @requires: table:clinics, table:farms, table:users, function:uuid_v7_bin

DROP TABLE IF EXISTS individuals;

CREATE TABLE individuals (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,
  clinic_uuid           BINARY(16) NOT NULL,   -- ★ CSIFH: 所属院（履歴固定）
  farm_uuid             BINARY(16) NOT NULL,   -- ↔ farms.uuid
  user_uuid             BINARY(16) NULL,       -- ↔ users.uuid（担当メモ）
  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,         -- 全国一意10桁（NULL可）
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,
  sire_name             VARCHAR(100) NULL,     -- 父は名称メモのみ
  genetic_dam_uuid      BINARY(16) NULL,       -- 自己参照（遺伝母）
  nursing_dam_uuid      BINARY(16) NULL,       -- 自己参照（哺育母）
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,
  CONSTRAINT chk_individuals_no_self_genetic CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/0100_checkup_create_individuals.sql>>>

<<<FILE patches/0110_checkup_fk_individuals_clinic_uuid.sql>>>
/* 110_checkup_fk_individuals_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_individuals_clinic_uuid
-- @requires: table:individuals, table:clinics

ALTER TABLE individuals
  ADD CONSTRAINT fk_individuals_clinic_uuid FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/0110_checkup_fk_individuals_clinic_uuid.sql>>>

<<<FILE patches/0111_checkup_fk_individuals_farm_uuid.sql>>>
/* 111_checkup_fk_individuals_farm_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_individuals_farm_uuid
-- @requires: table:individuals, table:farms

ALTER TABLE individuals
  ADD CONSTRAINT fk_individuals_farm_uuid FOREIGN KEY (farm_uuid)    REFERENCES farms(uuid)      ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/0111_checkup_fk_individuals_farm_uuid.sql>>>

<<<FILE patches/112_checkup_fk_individuals_user_uuid.sql>>>
/* 112_checkup_fk_individuals_user_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_individuals_user_uuid
-- @requires: table:individuals, table:users

ALTER TABLE individuals
  ADD CONSTRAINT fk_individuals_user_uuid FOREIGN KEY (user_uuid)    REFERENCES users(uuid)      ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/112_checkup_fk_individuals_user_uuid.sql>>>

<<<FILE patches/113_checkup_fk_individuals_genetic_dam.sql>>>
/* 113_checkup_fk_individuals_genetic_dam.sql */
-- @phase: fk
-- @provides: fk:fk_individuals_genetic_dam
-- @requires: table:individuals

ALTER TABLE individuals
  ADD CONSTRAINT fk_individuals_genetic_dam FOREIGN KEY (genetic_dam_uuid)  REFERENCES individuals(uuid) ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/113_checkup_fk_individuals_genetic_dam.sql>>>

<<<FILE patches/114_checkup_fk_individuals_nursing_dam.sql>>>
/* 114_checkup_fk_individuals_nursing_dam.sql */
-- @phase: fk
-- @provides: fk:fk_individuals_nursing_dam
-- @requires: table:individuals

ALTER TABLE individuals
  ADD CONSTRAINT fk_individuals_nursing_dam FOREIGN KEY (nursing_dam_uuid)  REFERENCES individuals(uuid) ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/114_checkup_fk_individuals_nursing_dam.sql>>>

<<<FILE patches/120_checkup_idx_individuals.sql>>>
/* 120_checkup_idx_individuals.sql */
-- @phase: idx
-- @provides: index:uq_individuals_ear_tag, index:idx_individuals_farm_name, index:idx_individuals_farm_birth, index:idx_individuals_farm_status, index:idx_individuals_genetic_dam, index:idx_individuals_nursing_dam, index:idx_individuals_list, index:idx_individuals_clinic
-- @requires: table:individuals

CREATE UNIQUE INDEX uq_individuals_ear_tag ON individuals(ear_tag);
CREATE INDEX idx_individuals_farm_name   ON individuals(farm_uuid, name);
CREATE INDEX idx_individuals_farm_birth  ON individuals(farm_uuid, birth_date);
CREATE INDEX idx_individuals_farm_status ON individuals(farm_uuid, status);
CREATE INDEX idx_individuals_genetic_dam ON individuals(genetic_dam_uuid);
CREATE INDEX idx_individuals_nursing_dam ON individuals(nursing_dam_uuid);
CREATE INDEX idx_individuals_list        ON individuals(deleted_at, updated_at, id);
CREATE INDEX idx_individuals_clinic      ON individuals(clinic_uuid, id);
<<<END patches/120_checkup_idx_individuals.sql>>>

<<<FILE patches/130_checkup_tr_individuals.sql>>>
/* 130_checkup_tr_individuals_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_individuals_bi_uuid_v7
-- @requires: table:individuals, function:uuid_v7_bin, table:farms

DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bi_clinic;

DELIMITER $$

CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 親farmsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT f.clinic_uuid INTO @cu FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

DELIMITER ;
<<<END patches/130_checkup_tr_individuals.sql>>>

<<<FILE patches/131_checkup_tr_individuals_bu_rowver.sql>>>
/* 131_checkup_tr_individuals_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_individuals_bu_rowver
-- @requires: table:individuals

DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;

DELIMITER $$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  /* 履歴固定方針のため clinic_uuid は自動更新しない（必要時はアプリで明示更新） */
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;
<<<END patches/131_checkup_tr_individuals_bu_rowver.sql>>>

<<<FILE patches/140_checkup_create_view_individuals_hex_v.sql>>>
/* 140_checkup_create_view_individuals_hex_v.sql */
-- @phase: create
-- @provides: view:individuals_hex_v
-- @requires: function:uuid_bin_to_hex, table:individuals

DROP VIEW IF EXISTS individuals_hex_v;

CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)         AS uuid_hex,
  uuid_bin_to_hex(clinic_uuid)  AS clinic_uuid_hex,
  uuid_bin_to_hex(farm_uuid)    AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)    AS user_uuid_hex,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid)  AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid)  AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;
<<<END patches/140_checkup_create_view_individuals_hex_v.sql>>>

<<<FILE patches/200_checkup_create_visits.sql>>>
/* 200_checkup_create_visits.sql */
-- @phase: create
-- @provides: table:visits
-- @requires: table:clinics, table:farms, function:uuid_v7_bin

DROP TABLE IF EXISTS visits;

CREATE TABLE visits (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL,
  clinic_uuid      BINARY(16) NOT NULL,   -- ★ CSIFH
  farm_uuid        BINARY(16) NOT NULL,   -- ↔ farms.uuid
  visit_started_at DATETIME NOT NULL,
  visit_ended_at   DATETIME NULL,
  location_text    VARCHAR(180) NULL,
  note             VARCHAR(255) NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at       DATETIME NULL,
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/200_checkup_create_visits.sql>>>

<<<FILE patches/210_checkup_fk_visits_clinic_uuid.sql>>>
/* 210_checkup_fk_visits_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_visits_clinic_uuid
-- @requires: table:visits, table:clinics

ALTER TABLE visits
  ADD CONSTRAINT fk_visits_clinic_uuid FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid) ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/210_checkup_fk_visits_clinic_uuid.sql>>>

<<<FILE patches/211_checkup_fk_visits_farm_uuid.sql>>>
/* 211_checkup_fk_visits_farm_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_visits_farm_uuid
-- @requires: table:visits, table:farms

ALTER TABLE visits
  ADD CONSTRAINT fk_visits_farm_uuid   FOREIGN KEY (farm_uuid)   REFERENCES farms(uuid)   ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/211_checkup_fk_visits_farm_uuid.sql>>>

<<<FILE patches/220_checkup_idx_visits.sql>>>
/* 220_checkup_idx_visits.sql */
-- @phase: idx
-- @provides: index:idx_visits_farm, index:idx_visits_farm_started, index:idx_visits_started, index:idx_visits_list, index:idx_visits_clinic
-- @requires: table:visits

CREATE INDEX idx_visits_farm         ON visits(farm_uuid);
CREATE INDEX idx_visits_farm_started ON visits(farm_uuid, visit_started_at);
CREATE INDEX idx_visits_started      ON visits(visit_started_at);
CREATE INDEX idx_visits_list         ON visits(deleted_at, updated_at, id);
CREATE INDEX idx_visits_clinic       ON visits(clinic_uuid, visit_started_at);
<<<END patches/220_checkup_idx_visits.sql>>>

<<<FILE patches/230_checkup_tr_visits.sql>>>
/* 230_checkup_tr_visits_bi_uuid.sql */
-- @phase: trigger
-- @provides: trigger:bi_visits_uuid
-- @requires: table:visits, function:uuid_v7_bin, table:farms

DROP TRIGGER IF EXISTS bi_visits_uuid;
DROP TRIGGER IF EXISTS tr_visits_bi_clinic;

DELIMITER $$

CREATE TRIGGER bi_visits_uuid
BEFORE INSERT ON visits
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = 0x00000000000000000000000000000000 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
  IF NEW.visit_started_at IS NULL THEN
    SET NEW.visit_started_at = UTC_TIMESTAMP();
  END IF;

  /* CSIFH: 親farmsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT f.clinic_uuid INTO @cu FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

DELIMITER ;
<<<END patches/230_checkup_tr_visits.sql>>>

<<<FILE patches/231_checkup_tr_visits_bu_rowver.sql>>>
/* 231_checkup_tr_visits_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:bu_visits_rowver
-- @requires: table:visits

DROP TRIGGER IF EXISTS bu_visits_rowver;

DELIMITER $$

CREATE TRIGGER bu_visits_rowver
BEFORE UPDATE ON visits
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;
<<<END patches/231_checkup_tr_visits_bu_rowver.sql>>>

<<<FILE patches/300_checkup_create_checkups.sql>>>
/* 300_checkup_create_checkups.sql */
-- @phase: create
-- @provides: table:checkups
-- @requires: table:clinics, table:visits, table:individuals, table:receipt_header_drafts, function:uuid_v7_bin

DROP TABLE IF EXISTS checkups;

CREATE TABLE checkups (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,
  clinic_uuid  BINARY(16) NOT NULL,          -- ★ CSIFH
  visit_uuid   BINARY(16) NULL,              -- ↔ visits.uuid（SET NULL）
  individual_uuid BINARY(16) NOT NULL,       -- ↔ individuals.uuid（RESTRICT）

  /* p017: レシート草稿への直付け（草稿削除で自動デタッチ） */
  receipt_header_drafts_uuid BINARY(16) NULL, -- ↔ receipt_header_drafts.uuid

  /* 将来の確定カルテ弱リンク（FKなし） */
  chart_header_uuid BINARY(16) NULL,

  /* SOAP */
  s_subjective TEXT NULL,
  o_objective  TEXT NULL,
  a_assessment TEXT NULL,
  p_plan       TEXT NULL,

  /* TPR */
  temp_c     DECIMAL(4,1) NULL,
  pulse_bpm  SMALLINT UNSIGNED NULL,
  resp_bpm   SMALLINT UNSIGNED NULL,

  /* 現症・経過 */
  clinical_course TEXT NULL,

  /* 運用 */
  status      ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by  INT UNSIGNED NULL,
  row_version BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at  DATETIME NULL,
  created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;
<<<END patches/300_checkup_create_checkups.sql>>>

<<<FILE patches/310_checkup_fk_checkups_clinic_uuid.sql>>>
/* 310_checkup_fk_checkups_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_checkups_clinic_uuid
-- @requires: table:checkups, table:clinics

ALTER TABLE checkups
  ADD CONSTRAINT fk_checkups_clinic_uuid   FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)     ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/310_checkup_fk_checkups_clinic_uuid.sql>>>

<<<FILE patches/311_checkup_fk_checkups_visit_uuid.sql>>>
/* 311_checkup_fk_checkups_visit_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_checkups_visit_uuid
-- @requires: table:checkups, table:visits

ALTER TABLE checkups
  ADD CONSTRAINT fk_checkups_visit_uuid    FOREIGN KEY (visit_uuid)   REFERENCES visits(uuid)      ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/311_checkup_fk_checkups_visit_uuid.sql>>>

<<<FILE patches/312_checkup_fk_checkups_individual_uuid.sql>>>
/* 312_checkup_fk_checkups_individual_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_checkups_individual_uuid
-- @requires: table:checkups, table:individuals

ALTER TABLE checkups
  ADD CONSTRAINT fk_checkups_individual_uuid FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid) ON UPDATE RESTRICT ON DELETE RESTRICT;
<<<END patches/312_checkup_fk_checkups_individual_uuid.sql>>>

<<<FILE patches/313_checkup_fk_checkups_rhd.sql>>>
/* 313_checkup_fk_checkups_rhd.sql */
-- @phase: fk
-- @provides: fk:fk_checkups_rhd
-- @requires: table:checkups, table:receipt_header_drafts

ALTER TABLE checkups
  ADD CONSTRAINT fk_checkups_rhd           FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid) ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/313_checkup_fk_checkups_rhd.sql>>>

<<<FILE patches/320_checkup_idx_checkups.sql>>>
/* 320_checkup_idx_checkups.sql */
-- @phase: idx
-- @provides: index:idx_checkups_visit, index:idx_checkups_individual, index:idx_checkups_visit_ind_crt, index:idx_checkups_visit_ind_uuid, index:idx_checkups_chart_header, index:idx_checkups_list, index:idx_checkups_rhd, index:idx_checkups_clinic
-- @requires: table:checkups

CREATE INDEX idx_checkups_visit           ON checkups(visit_uuid);
CREATE INDEX idx_checkups_individual      ON checkups(individual_uuid);
CREATE INDEX idx_checkups_visit_ind_crt   ON checkups(visit_uuid, individual_uuid, created_at);
CREATE INDEX idx_checkups_visit_ind_uuid  ON checkups(visit_uuid, individual_uuid, uuid);
CREATE INDEX idx_checkups_chart_header    ON checkups(chart_header_uuid);
CREATE INDEX idx_checkups_list            ON checkups(deleted_at, updated_at, id);
CREATE INDEX idx_checkups_rhd             ON checkups(receipt_header_drafts_uuid, id);
CREATE INDEX idx_checkups_clinic          ON checkups(clinic_uuid, created_at);
<<<END patches/320_checkup_idx_checkups.sql>>>

<<<FILE patches/330_checkup_tr_checkups.sql>>>
/* 330_checkup_tr_checkups_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_checkups_bi_uuid_v7
-- @requires: table:checkups, function:uuid_v7_bin, table:visits, table:individuals

DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;

DELIMITER $$

CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 優先 visit.clinic_uuid → 無ければ individual.clinic_uuid を継承 */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    IF NEW.visit_uuid IS NOT NULL THEN
      SELECT v.clinic_uuid INTO @cu FROM visits v WHERE v.uuid = NEW.visit_uuid LIMIT 1;
    ELSE
      SELECT i.clinic_uuid INTO @cu FROM individuals i WHERE i.uuid = NEW.individual_uuid LIMIT 1;
    END IF;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

DELIMITER ;
<<<END patches/330_checkup_tr_checkups.sql>>>

<<<FILE patches/331_checkup_tr_checkups_bu_rowver.sql>>>
/* 331_checkup_tr_checkups_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_checkups_bu_rowver
-- @requires: table:checkups

DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;

DELIMITER $$

CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;
<<<END patches/331_checkup_tr_checkups_bu_rowver.sql>>>

<<<FILE patches/340_checkup_create_view_checkups_hex_v.sql>>>
/* 340_checkup_create_view_checkups_hex_v.sql */
-- @phase: create
-- @provides: view:checkups_hex_v
-- @requires: function:uuid_bin_to_hex, table:checkups

DROP VIEW IF EXISTS checkups_hex_v;

CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)         AS uuid_hex,
  uuid_bin_to_hex(clinic_uuid)  AS clinic_uuid_hex,
  uuid_bin_to_hex(visit_uuid)   AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid) AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm, clinical_course,
  status, created_by, deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/340_checkup_create_view_checkups_hex_v.sql>>>

<<<FILE patches/400_checkup_create_checkup_items.sql>>>
/* 400_checkup_create_checkup_items.sql */
-- @phase: create
-- @provides: table:checkup_items
-- @requires: table:clinics, table:checkups, function:uuid_v7_bin

DROP TABLE IF EXISTS checkup_items;

CREATE TABLE checkup_items (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,
  clinic_uuid         BINARY(16) NOT NULL,   -- ★ CSIFH
  checkup_uuid        BINARY(16) NOT NULL,   -- ↔ checkups.uuid
  treatment_uuid      BINARY(16) NULL,       -- 任意参照（マスタ未確定でも可）
  description         VARCHAR(255) NOT NULL,
  qty_unit            VARCHAR(32) NULL,
  quantity            DECIMAL(10,2) NOT NULL DEFAULT 1,
  pay_type            ENUM('insurance','private') NOT NULL DEFAULT 'private',

  /* 点数/価格の両立 */
  unit_b_points       INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points     INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point       DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  unit_price_yen      INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen  INT UNSIGNED NOT NULL DEFAULT 0,
  tax_rate            DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen        INT UNSIGNED NOT NULL DEFAULT 0,

  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;
<<<END patches/400_checkup_create_checkup_items.sql>>>

<<<FILE patches/410_checkup_fk_checkup_items_clinic.sql>>>
/* 410_checkup_fk_checkup_items_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_checkup_items_clinic
-- @requires: table:checkup_items, table:clinics

ALTER TABLE checkup_items
  ADD CONSTRAINT fk_checkup_items_clinic FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)  ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/410_checkup_fk_checkup_items_clinic.sql>>>

<<<FILE patches/411_checkup_fk_checkup_items_checkup.sql>>>
/* 411_checkup_fk_checkup_items_checkup.sql */
-- @phase: fk
-- @provides: fk:fk_checkup_items_checkup
-- @requires: table:checkup_items, table:checkups

ALTER TABLE checkup_items
  ADD CONSTRAINT fk_checkup_items_checkup FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid) ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/411_checkup_fk_checkup_items_checkup.sql>>>

<<<FILE patches/420_checkup_idx_checkup_items.sql>>>
/* 420_checkup_idx_checkup_items.sql */
-- @phase: idx
-- @provides: index:idx_checkup_items_parent, index:idx_checkup_items_list, index:idx_checkup_items_clinic
-- @requires: table:checkup_items

CREATE INDEX idx_checkup_items_parent ON checkup_items(checkup_uuid, pay_type);
CREATE INDEX idx_checkup_items_list   ON checkup_items(deleted_at, updated_at, id);
CREATE INDEX idx_checkup_items_clinic ON checkup_items(clinic_uuid, id);
<<<END patches/420_checkup_idx_checkup_items.sql>>>

<<<FILE patches/430_checkup_tr_checkup_items.sql>>>
/* 430_checkup_tr_checkup_items_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_checkup_items_bi_uuid_v7
-- @requires: table:checkup_items, function:uuid_v7_bin, table:checkups

DROP TRIGGER IF EXISTS tr_checkup_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkup_items_bi_clinic;

DELIMITER $$

CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 親checkupsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT c.clinic_uuid INTO @cu FROM checkups c WHERE c.uuid = NEW.checkup_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

DELIMITER ;
<<<END patches/430_checkup_tr_checkup_items.sql>>>

<<<FILE patches/431_checkup_tr_checkup_items_bu_rowver.sql>>>
/* 431_checkup_tr_checkup_items_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_checkup_items_bu_rowver
-- @requires: table:checkup_items

DROP TRIGGER IF EXISTS tr_checkup_items_bu_rowver;

DELIMITER $$

CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;
<<<END patches/431_checkup_tr_checkup_items_bu_rowver.sql>>>

<<<FILE patches/500_checkup_create_view_checkups_insurance_context_v.sql>>>
/* 500_checkup_create_view_checkups_insurance_context_v.sql */
-- @phase: create
-- @provides: view:checkups_insurance_context_v
-- @requires: table:checkups, table:individuals, table:farms

DROP VIEW IF EXISTS checkups_insurance_context_v;

CREATE OR REPLACE VIEW checkups_insurance_context_v AS
SELECT
  c.uuid AS checkup_uuid,
  f.non_insured AS farm_non_insured,
  CASE WHEN f.non_insured = 1 THEN 'private' ELSE 'insurance' END AS preferred_pay_type
FROM checkups c
JOIN individuals i ON i.uuid = c.individual_uuid
JOIN farms f       ON f.uuid = i.farm_uuid;
<<<END patches/500_checkup_create_view_checkups_insurance_context_v.sql>>>

<<<FILE patches/600_chart_create_disease_master.sql>>>
/* 600_chart_create_disease_master.sql */
-- @phase: create
-- @provides: table:disease_master
-- @requires: function:uuid_v7_bin

SET NAMES utf8mb4;

/* 再デプロイ安全化 */
DROP TRIGGER IF EXISTS tr_disease_master_bi_uuid_v7;
DROP TABLE IF EXISTS disease_master;

CREATE TABLE IF NOT EXISTS disease_master (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,            
  uuid              BINARY(16) NOT NULL UNIQUE,                         

  code6             CHAR(6) NOT NULL UNIQUE,                            
  major_name        VARCHAR(32) NOT NULL,                               
  middle_name       VARCHAR(32) NOT NULL,                               
  minor_name        VARCHAR(32) NOT NULL,                               

  major_code        CHAR(2) AS (SUBSTRING(code6, 1, 2)) VIRTUAL,        
  middle_code       CHAR(2) AS (SUBSTRING(code6, 3, 2)) VIRTUAL,        
  minor_code        CHAR(2) AS (SUBSTRING(code6, 5, 2)) VIRTUAL,        

  display_code      VARCHAR(8)
    AS (CONCAT_WS('-', major_code, middle_code, minor_code)) PERSISTENT,
  display_name      VARCHAR(255)
    AS (CONCAT_WS(' / ', major_name, middle_name, minor_name)) PERSISTENT,

  is_active         TINYINT(1) NOT NULL DEFAULT 1,                     
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,                
  deleted_at        DATETIME NULL,                                     
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  CHECK (code6 REGEXP '^[0-9]{6}$')
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/600_chart_create_disease_master.sql>>>

<<<FILE patches/610_chart_idx_disease_master.sql>>>
/* 610_chart_idx_disease_master.sql */
-- @phase: idx
-- @provides: index:idx_dm_name, index:idx_dm_list
-- @requires: table:disease_master

CREATE INDEX idx_dm_name ON disease_master(major_name, middle_name, minor_name);
CREATE INDEX idx_dm_list ON disease_master(deleted_at, updated_at, id);
<<<END patches/610_chart_idx_disease_master.sql>>>

<<<FILE patches/620_chart_tr_disease_master_bi_uuid_v7.sql>>>
/* 620_chart_tr_disease_master_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_disease_master_bi_uuid_v7
-- @requires: table:disease_master, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_disease_master_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_disease_master_bi_uuid_v7
BEFORE INSERT ON disease_master
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/620_chart_tr_disease_master_bi_uuid_v7.sql>>>

<<<FILE patches/630_chart_create_disease_chief_complaint_rules.sql>>>
/* 630_chart_create_disease_chief_complaint_rules.sql */
-- @phase: create
-- @provides: table:disease_chief_complaint_rules
-- @requires: table:disease_master

DROP TABLE IF EXISTS disease_chief_complaint_rules;

CREATE TABLE IF NOT EXISTS disease_chief_complaint_rules (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  disease_id             INT UNSIGNED NOT NULL,                   
  chief_complaint_text   VARCHAR(128) NOT NULL,                   
  display_order          SMALLINT UNSIGNED NOT NULL DEFAULT 0,    
  is_active              TINYINT(1) NOT NULL DEFAULT 1,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/630_chart_create_disease_chief_complaint_rules.sql>>>

<<<FILE patches/640_chart_fk_dccr_disease.sql>>>
/* 640_chart_fk_dccr_disease.sql */
-- @phase: fk
-- @provides: fk:fk_dccr_disease
-- @requires: table:disease_chief_complaint_rules, table:disease_master

ALTER TABLE disease_chief_complaint_rules
  ADD CONSTRAINT fk_dccr_disease
  FOREIGN KEY (disease_id) REFERENCES disease_master(id)
  ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/640_chart_fk_dccr_disease.sql>>>

<<<FILE patches/650_chart_idx_disease_chief_complaint_rules.sql>>>
/* 650_chart_idx_disease_chief_complaint_rules.sql */
-- @phase: idx
-- @provides: index:idx_dccr_fetch, index:idx_dccr_text
-- @requires: table:disease_chief_complaint_rules

CREATE INDEX idx_dccr_fetch ON disease_chief_complaint_rules(disease_id, is_active, display_order, id);
CREATE INDEX idx_dccr_text  ON disease_chief_complaint_rules(chief_complaint_text);
<<<END patches/650_chart_idx_disease_chief_complaint_rules.sql>>>

<<<FILE patches/660_chart_create_chart_header_drafts.sql>>>
/* 660_chart_create_chart_header_drafts.sql */
-- @phase: create
-- @provides: table:chart_header_drafts
-- @requires: table:individuals, table:farms, table:insurance_enrollments, table:disease_master

DROP TABLE IF EXISTS chart_header_drafts;

CREATE TABLE IF NOT EXISTS chart_header_drafts (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                 -- v7 UUID（TRIGGER付与）

  /* CSIFH: 当時の院（clinics.uuid）値を固定保持。clinics へのFKは付与しない */
  clinic_uuid               BINARY(16) NOT NULL,

  /* 強整合FK（削除はRESTRICT、保険は任意でSET NULL） */
  individual_uuid           BINARY(16) NOT NULL,                        -- ↔ individuals.uuid
  farm_uuid                 BINARY(16) NOT NULL,                        -- ↔ farms.uuid
  insurance_enrollment_id   INT UNSIGNED NULL,                          -- ↔ insurance_enrollments.id

  fiscal_year               YEAR NULL,                                  -- 編集中はNULL許容
  claim_month               TINYINT UNSIGNED NULL,                      -- 1..12
  CHECK (claim_month IS NULL OR claim_month BETWEEN 1 AND 12),

  outcome_code              TINYINT UNSIGNED NULL,                      -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  draft_status              ENUM('open','closed','issued') NOT NULL DEFAULT 'open',  -- open治療中/closed転帰済/issuedスナップ発行済
  status_note               VARCHAR(255) NULL,

  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  issued_at                 DATETIME NULL,

  /* 任意のスナップ（プレビュー用途） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  updated_by                INT UNSIGNED NULL,
  row_version               BIGINT UNSIGNED NOT NULL DEFAULT 1,          -- 楽観ロック
  deleted_at                DATETIME NULL,                                -- ソフトデリート
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/660_chart_create_chart_header_drafts.sql>>>

<<<FILE patches/670_chart_fk_chd_individual.sql>>>
/* 670_chart_fk_chd_individual.sql */
-- @phase: fk
-- @provides: fk:fk_chd_individual
-- @requires: table:chart_header_drafts, table:individuals

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_individual
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/670_chart_fk_chd_individual.sql>>>

<<<FILE patches/671_chart_fk_chd_farm.sql>>>
/* 671_chart_fk_chd_farm.sql */
-- @phase: fk
-- @provides: fk:fk_chd_farm
-- @requires: table:chart_header_drafts, table:farms

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/671_chart_fk_chd_farm.sql>>>

<<<FILE patches/672_chart_fk_chd_insenroll.sql>>>
/* 672_chart_fk_chd_insenroll.sql */
-- @phase: fk
-- @provides: fk:fk_chd_insenroll
-- @requires: table:chart_header_drafts, table:insurance_enrollments

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_insenroll
    FOREIGN KEY (insurance_enrollment_id) REFERENCES insurance_enrollments(id)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/672_chart_fk_chd_insenroll.sql>>>

<<<FILE patches/673_chart_fk_chd_disease1.sql>>>
/* 673_chart_fk_chd_disease1.sql */
-- @phase: fk
-- @provides: fk:fk_chd_dis1
-- @requires: table:chart_header_drafts, table:disease_master

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_dis1 FOREIGN KEY (disease1_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/673_chart_fk_chd_disease1.sql>>>

<<<FILE patches/674_chart_fk_chd_disease2.sql>>>
/* 674_chart_fk_chd_disease2.sql */
-- @phase: fk
-- @provides: fk:fk_chd_dis2
-- @requires: table:chart_header_drafts, table:disease_master

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_dis2 FOREIGN KEY (disease2_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/674_chart_fk_chd_disease2.sql>>>

<<<FILE patches/675_chart_fk_chd_disease3.sql>>>
/* 675_chart_fk_chd_disease3.sql */
-- @phase: fk
-- @provides: fk:fk_chd_dis3
-- @requires: table:chart_header_drafts, table:disease_master

ALTER TABLE chart_header_drafts
  ADD CONSTRAINT fk_chd_dis3 FOREIGN KEY (disease3_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/675_chart_fk_chd_disease3.sql>>>

<<<FILE patches/680_chart_idx_chart_header_drafts.sql>>>
/* 680_chart_idx_chart_header_drafts.sql */
-- @phase: idx
-- @provides: index:idx_chd_clinic_list, index:idx_hdr_drafts_open, index:idx_hdr_drafts_period, index:idx_hdr_drafts_dis1, index:idx_hdr_drafts_dis2, index:idx_hdr_drafts_dis3, index:idx_hdr_drafts_farm, index:idx_hdr_drafts_list
-- @requires: table:chart_header_drafts

CREATE INDEX idx_chd_clinic_list     ON chart_header_drafts(clinic_uuid, deleted_at, updated_at, id);
CREATE INDEX idx_hdr_drafts_open     ON chart_header_drafts(individual_uuid, draft_status, created_at);
CREATE INDEX idx_hdr_drafts_period   ON chart_header_drafts(fiscal_year, claim_month);
CREATE INDEX idx_hdr_drafts_dis1     ON chart_header_drafts(disease1_code);
CREATE INDEX idx_hdr_drafts_dis2     ON chart_header_drafts(disease2_code);
CREATE INDEX idx_hdr_drafts_dis3     ON chart_header_drafts(disease3_code);
CREATE INDEX idx_hdr_drafts_farm     ON chart_header_drafts(farm_uuid);
CREATE INDEX idx_hdr_drafts_list     ON chart_header_drafts(deleted_at, updated_at, id);
<<<END patches/680_chart_idx_chart_header_drafts.sql>>>

<<<FILE patches/690_chart_tr_chd_bi_uuid_v7.sql>>>
/* 690_chart_tr_chd_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_header_drafts_bi_uuid_v7
-- @requires: table:chart_header_drafts, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_chart_header_drafts_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bi_uuid_v7
BEFORE INSERT ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/690_chart_tr_chd_bi_uuid_v7.sql>>>

<<<FILE patches/691_chart_tr_chd_bi_clinic.sql>>>
/* 691_chart_tr_chd_bi_clinic.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_header_drafts_bi_clinic
-- @requires: table:chart_header_drafts, table:farms

DROP TRIGGER IF EXISTS tr_chart_header_drafts_bi_clinic;

DELIMITER $$
/* CSIFH: INSERT時に farms.clinic_uuid を継承（アプリから clinic_uuid を渡す必要なし） */
CREATE TRIGGER tr_chart_header_drafts_bi_clinic
BEFORE INSERT ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/691_chart_tr_chd_bi_clinic.sql>>>

<<<FILE patches/692_chart_tr_chd_bu_clinic_sync.sql>>>
/* 692_chart_tr_chd_bu_clinic_sync.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_header_drafts_bu_clinic_sync
-- @requires: table:chart_header_drafts, table:farms

DROP TRIGGER IF EXISTS tr_chart_header_drafts_bu_clinic_sync;

DELIMITER $$
/* 任意：draft 内で farm_uuid を変更した場合に clinic_uuid も再継承して整合させる */
CREATE TRIGGER tr_chart_header_drafts_bu_clinic_sync
BEFORE UPDATE ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.farm_uuid <> OLD.farm_uuid THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
  /* row_version の更新は既存トリガで実施 */
END $$
DELIMITER ;
<<<END patches/692_chart_tr_chd_bu_clinic_sync.sql>>>

<<<FILE patches/693_chart_tr_chd_bu_rowver.sql>>>
/* 693_chart_tr_chd_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_header_drafts_bu_rowver
-- @requires: table:chart_header_drafts

DROP TRIGGER IF EXISTS tr_chart_header_drafts_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bu_rowver
BEFORE UPDATE ON chart_header_drafts
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/693_chart_tr_chd_bu_rowver.sql>>>

<<<FILE patches/700_chart_create_chart_headers.sql>>>
/* 700_chart_create_chart_headers.sql */
-- @phase: create
-- @provides: table:chart_headers
-- @requires: function:uuid_v7_bin

DROP TABLE IF EXISTS chart_headers;

CREATE TABLE IF NOT EXISTS chart_headers (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                -- v7 UUID

  clinic_uuid               BINARY(16) NOT NULL,                        -- 当時の院（clinics.uuid）値

  /* 追跡弱リンク（確定後は変更しないためFKなしでも可） */
  individual_uuid           BINARY(16) NOT NULL,
  farm_uuid                 BINARY(16) NOT NULL,
  insurance_enrollment_id   INT UNSIGNED NULL,

  /* 保険期間識別 */
  fiscal_year               YEAR NOT NULL,
  claim_month               TINYINT UNSIGNED NOT NULL,                 -- 1..12
  CHECK (claim_month BETWEEN 1 AND 12),

  /* 転帰・期間（確定値） */
  outcome_code              TINYINT UNSIGNED NOT NULL,                 -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  /* 主訴・診断（スナップ） */
  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  /* 疾病スナップ（6桁コード＋表示名） */
  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  /* 金額・点数合計（スナップ） */
  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  /* ステータス：printed / voided（未印刷はNULL） */
  status                    ENUM('printed','voided') NULL DEFAULT NULL,
  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at                 DATETIME NULL,
  void_reason               VARCHAR(255) NULL,

  /* スナップ時の表示/保険情報（任意） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/700_chart_create_chart_headers.sql>>>

<<<FILE patches/710_chart_idx_chart_headers.sql>>>
/* 710_chart_idx_chart_headers.sql */
-- @phase: idx
-- @provides: index:idx_ch_clinic_list, index:idx_chart_headers_period, index:idx_chart_headers_status, index:idx_chart_headers_individual, index:idx_chart_headers_farm, index:idx_chart_headers_outcome, index:idx_chart_headers_dis1, index:idx_chart_headers_dis2, index:idx_chart_headers_dis3, index:idx_ch_list
-- @requires: table:chart_headers

CREATE INDEX idx_ch_clinic_list            ON chart_headers(clinic_uuid, updated_at, id);
CREATE INDEX idx_chart_headers_period      ON chart_headers(fiscal_year, claim_month);
CREATE INDEX idx_chart_headers_status      ON chart_headers(status);
CREATE INDEX idx_chart_headers_individual  ON chart_headers(individual_uuid);
CREATE INDEX idx_chart_headers_farm        ON chart_headers(farm_uuid);
CREATE INDEX idx_chart_headers_outcome     ON chart_headers(outcome_code);
CREATE INDEX idx_chart_headers_dis1        ON chart_headers(disease1_code);
CREATE INDEX idx_chart_headers_dis2        ON chart_headers(disease2_code);
CREATE INDEX idx_chart_headers_dis3        ON chart_headers(disease3_code);
CREATE INDEX idx_ch_list                   ON chart_headers(updated_at, id);
<<<END patches/710_chart_idx_chart_headers.sql>>>

<<<FILE patches/720_chart_tr_chart_headers_bi_uuid_v7.sql>>>
/* 720_chart_tr_chart_headers_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_headers_bi_uuid_v7
-- @requires: table:chart_headers, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_chart_headers_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_chart_headers_bi_uuid_v7
BEFORE INSERT ON chart_headers
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/720_chart_tr_chart_headers_bi_uuid_v7.sql>>>

<<<FILE patches/721_chart_tr_chart_headers_bi_clinic.sql>>>
/* 721_chart_tr_chart_headers_bi_clinic.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_headers_bi_clinic
-- @requires: table:chart_headers, table:farms

DROP TRIGGER IF EXISTS tr_chart_headers_bi_clinic;

DELIMITER $$
/* CSIFH: INSERT時に farms.clinic_uuid を継承して固定（確定スナップの当時値） */
CREATE TRIGGER tr_chart_headers_bi_clinic
BEFORE INSERT ON chart_headers
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/721_chart_tr_chart_headers_bi_clinic.sql>>>

<<<FILE patches/730_chart_create_chart_checkups.sql>>>
/* 730_chart_create_chart_checkups.sql */
-- @phase: create
-- @provides: table:chart_checkups
-- @requires: table:chart_headers, function:uuid_v7_bin

DROP TABLE IF EXISTS chart_checkups;

CREATE TABLE IF NOT EXISTS chart_checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   BINARY(16) NOT NULL UNIQUE,             -- 行UUID
  chart_uuid             BINARY(16) NOT NULL,                    -- ↔ chart_headers.uuid
  clinic_uuid            BINARY(16) NOT NULL,                    -- 当時の院（clinics.uuid）値
  seq_no                 INT UNSIGNED NOT NULL,                  -- ヘッダ内の並び

  source_checkup_uuid    BINARY(16) NOT NULL,                    -- 由来 checkups.uuid（監査）
  source_visit_uuid      BINARY(16) NULL,                        -- 由来 visits.uuid（任意）

  checkup_at             DATETIME NULL,                          -- 受診日時

  subjective_text        TEXT NULL,
  objective_text         TEXT NULL,
  assessment_text        TEXT NULL,
  plan_text              TEXT NULL,
  clinical_course_text   TEXT NULL,

  tpr_temp_c             DECIMAL(4,1) NULL,
  tpr_pulse_bpm          SMALLINT UNSIGNED NULL,
  tpr_resp_bpm           SMALLINT UNSIGNED NULL,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/730_chart_create_chart_checkups.sql>>>

<<<FILE patches/740_chart_fk_chart_checkups_header.sql>>>
/* 740_chart_fk_chart_checkups_header.sql */
-- @phase: fk
-- @provides: fk:fk_chart_checkups_header
-- @requires: table:chart_checkups, table:chart_headers

ALTER TABLE chart_checkups
  ADD CONSTRAINT fk_chart_checkups_header
    FOREIGN KEY (chart_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/740_chart_fk_chart_checkups_header.sql>>>

<<<FILE patches/745_chart_idx_chart_checkups.sql>>>
/* 745_chart_idx_chart_checkups.sql */
-- @phase: idx
-- @provides: index:uq_chart_checkups_hdr_seq, index:idx_chart_checkups_hdr, index:idx_cc_clinic
-- @requires: table:chart_checkups

CREATE UNIQUE INDEX uq_chart_checkups_hdr_seq ON chart_checkups(chart_uuid, seq_no);
CREATE INDEX idx_chart_checkups_hdr          ON chart_checkups(chart_uuid);
CREATE INDEX idx_cc_clinic                   ON chart_checkups(clinic_uuid, chart_uuid);
<<<END patches/745_chart_idx_chart_checkups.sql>>>

<<<FILE patches/750_chart_tr_chart_checkups_bi_uuid_v7.sql>>>
/* 750_chart_tr_chart_checkups_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_checkups_bi_uuid_v7
-- @requires: table:chart_checkups, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_chart_checkups_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_chart_checkups_bi_uuid_v7
BEFORE INSERT ON chart_checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/750_chart_tr_chart_checkups_bi_uuid_v7.sql>>>

<<<FILE patches/751_chart_tr_chart_checkups_bi_clinic.sql>>>
/* 751_chart_tr_chart_checkups_bi_clinic.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_checkups_bi_clinic
-- @requires: table:chart_checkups, table:chart_headers

DROP TRIGGER IF EXISTS tr_chart_checkups_bi_clinic;

DELIMITER $$
/* CSIFH: INSERT時に親 chart_headers の clinic_uuid を継承して固定 */
CREATE TRIGGER tr_chart_checkups_bi_clinic
BEFORE INSERT ON chart_checkups
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT ch.clinic_uuid INTO NEW.clinic_uuid
      FROM chart_headers ch
     WHERE ch.uuid = NEW.chart_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/751_chart_tr_chart_checkups_bi_clinic.sql>>>

<<<FILE patches/760_chart_create_chart_items.sql>>>
/* 760_chart_create_chart_items.sql */
-- @phase: create
-- @provides: table:chart_items
-- @requires: table:chart_checkups, function:uuid_v7_bin

DROP TABLE IF EXISTS chart_items;

CREATE TABLE IF NOT EXISTS chart_items (
  id                       INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                     BINARY(16) NOT NULL UNIQUE,           -- 明細UUID
  chart_checkup_uuid       BINARY(16) NOT NULL,                  -- ↔ chart_checkups.uuid
  clinic_uuid              BINARY(16) NOT NULL,                  -- 当時の院（clinics.uuid）値
  within_checkup_line_no   INT UNSIGNED NOT NULL,                -- 受診回内の行順

  source_checkup_uuid      BINARY(16) NOT NULL,                  -- 由来 checkups.uuid（監査）
  treatment_uuid           BINARY(16) NULL,                      -- 由来 treatment_master.uuid 等（任意）

  description              VARCHAR(255) NOT NULL,
  qty_unit                 VARCHAR(32) NULL,
  quantity                 DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type                 ENUM('insurance','private') NOT NULL,
  unit_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points          INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point            DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate                 DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen             INT UNSIGNED NOT NULL DEFAULT 0,

  created_at               DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
<<<END patches/760_chart_create_chart_items.sql>>>

<<<FILE patches/770_chart_fk_chart_items_cc.sql>>>
/* 770_chart_fk_chart_items_cc.sql */
-- @phase: fk
-- @provides: fk:fk_chart_items_cc
-- @requires: table:chart_items, table:chart_checkups

ALTER TABLE chart_items
  ADD CONSTRAINT fk_chart_items_cc
    FOREIGN KEY (chart_checkup_uuid) REFERENCES chart_checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/770_chart_fk_chart_items_cc.sql>>>

<<<FILE patches/775_chart_idx_chart_items.sql>>>
/* 775_chart_idx_chart_items.sql */
-- @phase: idx
-- @provides: index:idx_chart_items_parent, index:idx_ci_clinic
-- @requires: table:chart_items

CREATE INDEX idx_chart_items_parent ON chart_items(chart_checkup_uuid, within_checkup_line_no);
CREATE INDEX idx_ci_clinic         ON chart_items(clinic_uuid, chart_checkup_uuid);
<<<END patches/775_chart_idx_chart_items.sql>>>

<<<FILE patches/780_chart_tr_chart_items_bi_uuid_v7.sql>>>
/* 780_chart_tr_chart_items_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_items_bi_uuid_v7
-- @requires: table:chart_items, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_chart_items_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_chart_items_bi_uuid_v7
BEFORE INSERT ON chart_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/780_chart_tr_chart_items_bi_uuid_v7.sql>>>

<<<FILE patches/781_chart_tr_chart_items_bi_clinic.sql>>>
/* 781_chart_tr_chart_items_bi_clinic.sql */
-- @phase: trigger
-- @provides: trigger:tr_chart_items_bi_clinic
-- @requires: table:chart_items, table:chart_checkups

DROP TRIGGER IF EXISTS tr_chart_items_bi_clinic;

DELIMITER $$
/* CSIFH: INSERT時に親 chart_checkups の clinic_uuid を継承して固定 */
CREATE TRIGGER tr_chart_items_bi_clinic
BEFORE INSERT ON chart_items
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT cc.clinic_uuid INTO NEW.clinic_uuid
      FROM chart_checkups cc
     WHERE cc.uuid = NEW.chart_checkup_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/781_chart_tr_chart_items_bi_clinic.sql>>>

<<<FILE patches/1000_treatment_create_treatment_master.sql>>>
/* 1000_treatment_create_treatment_master.sql */
-- @phase: create
-- @provides: table:treatment_master
-- @requires: table:clinics, function:uuid_v7_bin
-- 方針: 原文のCREATEから索引(FK/KEY)を分離。列定義は原文のまま。

SET NAMES utf8mb4;

DROP TABLE IF EXISTS treatment_master;

CREATE TABLE IF NOT EXISTS treatment_master (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,                   -- UUIDv7(bin16)
  clinic_uuid          BINARY(16) NOT NULL,                          -- ↔ clinics.uuid（当時値・不変）
  code                 VARCHAR(50)  NOT NULL,                        -- 院内/製剤コード
  name                 VARCHAR(255) NOT NULL,                        -- 表示名
  type                 ENUM('procedure','medication') NOT NULL,      -- 区分
  qty_unit             VARCHAR(32)  NOT NULL,                        -- 単位
  default_pay_type     ENUM('insurance','private') NOT NULL DEFAULT 'insurance',

  /* 点数/価格（整数運用） */
  current_b_points     INT UNSIGNED NULL,
  current_a_points     INT UNSIGNED NULL,
  current_price_yen    INT UNSIGNED NULL,

  /* 税率（例 0.10） */
  tax_rate             DECIMAL(4,2) NOT NULL,

  /* 任意メタ（一本化: 全体向け注意・用法等） */
  dosage_per_kg        DECIMAL(10,4) NULL,                           -- 体重1kgあたり
  usage_text           TEXT NULL,

  /* 運用 */
  is_active            TINYINT(1) NOT NULL DEFAULT 1,
  created_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME  NULL,                                -- SoftDelete
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1             -- 楽観ロック
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1000_treatment_create_treatment_master.sql>>>

<<<FILE patches/1010_treatment_idx_treatment_master.sql>>>
/* 1010_treatment_idx_treatment_master.sql */
-- @phase: idx
-- @provides: index:uq_ttm_clinic_code, index:idx_ttm_active, index:idx_quality, index:idx_clinic_list
-- @requires: table:treatment_master
-- 原文のUNIQUE/KEYをCREATE INDEXへ移設（名称・列順は原文どおり）

CREATE UNIQUE INDEX uq_ttm_clinic_code ON treatment_master (clinic_uuid, code);         -- ★院別一意
CREATE INDEX idx_ttm_active   ON treatment_master (is_active, name);
CREATE INDEX idx_quality      ON treatment_master (deleted_at, updated_at, id);
CREATE INDEX idx_clinic_list  ON treatment_master (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1010_treatment_idx_treatment_master.sql>>>

<<<FILE patches/1020_treatment_fk_treatment_master_clinic_uuid.sql>>>
/* 1020_treatment_fk_treatment_master_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_ttm_clinic_uuid
-- @requires: table:treatment_master, table:clinics
-- 原文: treatment_master のみ clinics にFKを付与

ALTER TABLE treatment_master
  ADD CONSTRAINT fk_ttm_clinic_uuid
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1020_treatment_fk_treatment_master_clinic_uuid.sql>>>

<<<FILE patches/1030_treatment_tr_treatment_master_bi_uuid.sql>>>
/* 1030_treatment_tr_treatment_master_bi_uuid.sql */
-- @phase: trigger
-- @provides: trigger:bi_treatment_master_uuid
-- @requires: table:treatment_master, function:uuid_v7_bin
-- 役割: UUID自動採番（NULL時）。原文どおり。

DROP TRIGGER IF EXISTS bi_treatment_master_uuid;

DELIMITER $$
CREATE TRIGGER bi_treatment_master_uuid
BEFORE INSERT ON treatment_master
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$
DELIMITER ;
<<<END patches/1030_treatment_tr_treatment_master_bi_uuid.sql>>>

<<<FILE patches/1031_treatment_tr_treatment_master_bu_rowver.sql>>>
/* 1031_treatment_tr_treatment_master_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:bu_treatment_master_rowver
-- @requires: table:treatment_master
-- 役割: clinic_uuid の不変ガード＋row_version自動更新。原文どおり。

DROP TRIGGER IF EXISTS bu_treatment_master_rowver;

DELIMITER $$
CREATE TRIGGER bu_treatment_master_rowver
BEFORE UPDATE ON treatment_master
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_master';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1031_treatment_tr_treatment_master_bu_rowver.sql>>>

<<<FILE patches/1100_treatment_create_treatment_disease_rules.sql>>>
/* 1100_treatment_create_treatment_disease_rules.sql */
-- @phase: create
-- @provides: table:treatment_disease_rules
-- @requires: table:treatment_master, table:disease_master, function:uuid_v7_bin
-- 方針: 索引とFKは別ファイル。列定義は原文のまま。

DROP TABLE IF EXISTS treatment_disease_rules;

CREATE TABLE IF NOT EXISTS treatment_disease_rules (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,           -- UUIDv7(bin16)
  clinic_uuid      BINARY(16) NOT NULL,                  -- 当時値（FKなし）
  treatment_uuid   BINARY(16) NOT NULL,                  -- ↔ treatment_master.uuid
  disease_uuid     BINARY(16) NOT NULL,                  -- ↔ disease_master.uuid
  disease_specific TEXT NULL,                            -- on-label時の任意表示文（病名特異）
  is_active        TINYINT(1) NOT NULL DEFAULT 1,
  created_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME  NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1100_treatment_create_treatment_disease_rules.sql>>>

<<<FILE patches/1110_treatment_fk_treatment_disease_rules_treatment_uuid.sql>>>
/* 1110_treatment_fk_treatment_disease_rules_treatment_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_tdr_treatment_uuid
-- @requires: table:treatment_disease_rules, table:treatment_master

ALTER TABLE treatment_disease_rules
  ADD CONSTRAINT fk_tdr_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1110_treatment_fk_treatment_disease_rules_treatment_uuid.sql>>>

<<<FILE patches/1111_treatment_fk_treatment_disease_rules_disease_uuid.sql>>>
/* 1111_treatment_fk_treatment_disease_rules_disease_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_tdr_disease_uuid
-- @requires: table:treatment_disease_rules, table:disease_master

ALTER TABLE treatment_disease_rules
  ADD CONSTRAINT fk_tdr_disease_uuid
    FOREIGN KEY (disease_uuid)   REFERENCES disease_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1111_treatment_fk_treatment_disease_rules_disease_uuid.sql>>>

<<<FILE patches/1120_treatment_idx_treatment_disease_rules.sql>>>
/* 1120_treatment_idx_treatment_disease_rules.sql */
-- @phase: idx
-- @provides: index:uq_tdr_pair, index:idx_tdr_treat, index:idx_tdr_dis, index:idx_quality, index:idx_clinic_list
-- @requires: table:treatment_disease_rules

CREATE UNIQUE INDEX uq_tdr_pair    ON treatment_disease_rules (treatment_uuid, disease_uuid);
CREATE INDEX idx_tdr_treat         ON treatment_disease_rules (treatment_uuid);
CREATE INDEX idx_tdr_dis           ON treatment_disease_rules (disease_uuid);
CREATE INDEX idx_quality           ON treatment_disease_rules (deleted_at, updated_at, id);
CREATE INDEX idx_clinic_list       ON treatment_disease_rules (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1120_treatment_idx_treatment_disease_rules.sql>>>

<<<FILE patches/1130_treatment_tr_treatment_disease_rules_bi_uuid.sql>>>
/* 1130_treatment_tr_treatment_disease_rules_bi_uuid.sql */
-- @phase: trigger
-- @provides: trigger:bi_treatment_disease_rules_uuid
-- @requires: table:treatment_disease_rules, function:uuid_v7_bin, table:treatment_master
-- 役割: UUID自動採番＋clinic_uuidの親継承（NULL時のみ）。原文どおり。

DROP TRIGGER IF EXISTS bi_treatment_disease_rules_uuid;

DELIMITER $$
CREATE TRIGGER bi_treatment_disease_rules_uuid
BEFORE INSERT ON treatment_disease_rules
FOR EACH ROW
BEGIN
  DECLARE v_parent_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_master）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT tm.clinic_uuid INTO v_parent_clinic
      FROM treatment_master tm
     WHERE tm.uuid = NEW.treatment_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_parent_clinic;
  END IF;
END$$
DELIMITER ;
<<<END patches/1130_treatment_tr_treatment_disease_rules_bi_uuid.sql>>>

<<<FILE patches/1131_treatment_tr_treatment_disease_rules_bu_rowver.sql>>>
/* 1131_treatment_tr_treatment_disease_rules_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:bu_treatment_disease_rules_rowver
-- @requires: table:treatment_disease_rules
-- 役割: clinic_uuid の不変ガード＋row_version自動更新。原文どおり。

DROP TRIGGER IF EXISTS bu_treatment_disease_rules_rowver;

DELIMITER $$
CREATE TRIGGER bu_treatment_disease_rules_rowver
BEFORE UPDATE ON treatment_disease_rules
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_disease_rules';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1131_treatment_tr_treatment_disease_rules_bu_rowver.sql>>>

<<<FILE patches/1200_treatment_create_treatment_sets.sql>>>
/* 1200_treatment_create_treatment_sets.sql */
-- @phase: create
-- @provides: table:treatment_sets
-- @requires: table:users, function:uuid_v7_bin

DROP TABLE IF EXISTS treatment_sets;

CREATE TABLE IF NOT EXISTS treatment_sets (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,               -- UUIDv7(bin16)
  clinic_uuid  BINARY(16) NOT NULL,                      -- 当時値（FKなし）
  user_uuid    BINARY(16) NOT NULL,                      -- ↔ users.uuid
  name         VARCHAR(100) NOT NULL,
  note         VARCHAR(255) NULL,
  sequence_no  INT UNSIGNED NOT NULL DEFAULT 1,
  visibility   ENUM('private','shared') NOT NULL DEFAULT 'shared',
  is_active    TINYINT(1) NOT NULL DEFAULT 1,

  created_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME  NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1200_treatment_create_treatment_sets.sql>>>

<<<FILE patches/1210_treatment_fk_treatment_sets_user_uuid.sql>>>
/* 1210_treatment_fk_treatment_sets_user_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_treatment_sets_user_uuid
-- @requires: table:treatment_sets, table:users

ALTER TABLE treatment_sets
  ADD CONSTRAINT fk_treatment_sets_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1210_treatment_fk_treatment_sets_user_uuid.sql>>>

<<<FILE patches/1220_treatment_idx_treatment_sets.sql>>>
/* 1220_treatment_idx_treatment_sets.sql */
-- @phase: idx
-- @provides: index:idx_ts_owner, index:idx_visibility, index:idx_quality, index:idx_clinic_list
-- @requires: table:treatment_sets

CREATE INDEX idx_ts_owner     ON treatment_sets (user_uuid, is_active, sequence_no);
CREATE INDEX idx_visibility   ON treatment_sets (visibility);
CREATE INDEX idx_quality      ON treatment_sets (deleted_at, updated_at, id);
CREATE INDEX idx_clinic_list  ON treatment_sets (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1220_treatment_idx_treatment_sets.sql>>>

<<<FILE patches/1230_treatment_tr_treatment_sets_bi_uuid.sql>>>
/* 1230_treatment_tr_treatment_sets_bi_uuid.sql */
-- @phase: trigger
-- @provides: trigger:bi_treatment_sets_uuid
-- @requires: table:treatment_sets, function:uuid_v7_bin, table:users
-- 役割: UUID自動採番＋usersからclinic_uuid継承（NULL時のみ）。原文どおり。

DROP TRIGGER IF EXISTS bi_treatment_sets_uuid;

DELIMITER $$
CREATE TRIGGER bi_treatment_sets_uuid
BEFORE INSERT ON treatment_sets
FOR EACH ROW
BEGIN
  DECLARE v_user_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（users）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT u.clinic_uuid INTO v_user_clinic
      FROM users u
     WHERE u.uuid = NEW.user_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_user_clinic;
  END IF;
END$$
DELIMITER ;
<<<END patches/1230_treatment_tr_treatment_sets_bi_uuid.sql>>>

<<<FILE patches/1231_treatment_tr_treatment_sets_bu_rowver.sql>>>
/* 1231_treatment_tr_treatment_sets_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:bu_treatment_sets_rowver
-- @requires: table:treatment_sets
-- 役割: clinic_uuid の不変ガード＋row_version自動更新。原文どおり。

DROP TRIGGER IF EXISTS bu_treatment_sets_rowver;

DELIMITER $$
CREATE TRIGGER bu_treatment_sets_rowver
BEFORE UPDATE ON treatment_sets
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_sets';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1231_treatment_tr_treatment_sets_bu_rowver.sql>>>

<<<FILE patches/1300_treatment_create_treatment_set_items.sql>>>
/* 1300_treatment_create_treatment_set_items.sql */
-- @phase: create
-- @provides: table:treatment_set_items
-- @requires: table:treatment_sets, table:treatment_master, function:uuid_v7_bin

DROP TABLE IF EXISTS treatment_set_items;

CREATE TABLE IF NOT EXISTS treatment_set_items (
  id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid            BINARY(16) NOT NULL UNIQUE,            -- UUIDv7(bin16)
  clinic_uuid     BINARY(16) NOT NULL,                   -- 当時値（FKなし）
  set_uuid        BINARY(16) NOT NULL,                   -- ↔ treatment_sets.uuid
  treatment_uuid  BINARY(16) NOT NULL,                   -- ↔ treatment_master.uuid
  sequence_no     INT UNSIGNED NOT NULL DEFAULT 1,
  preset_quantity DECIMAL(10,2) NULL,                    -- p016.2方針（10,2）

  created_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at      DATETIME  NULL,
  row_version     BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1300_treatment_create_treatment_set_items.sql>>>

<<<FILE patches/1310_treatment_fk_treatment_set_items_set_uuid.sql>>>
/* 1310_treatment_fk_treatment_set_items_set_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_tsi_set_uuid
-- @requires: table:treatment_set_items, table:treatment_sets

ALTER TABLE treatment_set_items
  ADD CONSTRAINT fk_tsi_set_uuid
    FOREIGN KEY (set_uuid)       REFERENCES treatment_sets(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1310_treatment_fk_treatment_set_items_set_uuid.sql>>>

<<<FILE patches/1311_treatment_fk_treatment_set_items_treatment_uuid.sql>>>
/* 1311_treatment_fk_treatment_set_items_treatment_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_tsi_treatment_uuid
-- @requires: table:treatment_set_items, table:treatment_master

ALTER TABLE treatment_set_items
  ADD CONSTRAINT fk_tsi_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1311_treatment_fk_treatment_set_items_treatment_uuid.sql>>>

<<<FILE patches/1320_treatment_idx_treatment_set_items.sql>>>
/* 1320_treatment_idx_treatment_set_items.sql */
-- @phase: idx
-- @provides: index:uq_tsi_item, index:idx_tsi_set_seq, index:idx_treatment, index:idx_quality, index:idx_clinic_list
-- @requires: table:treatment_set_items

CREATE UNIQUE INDEX uq_tsi_item     ON treatment_set_items (set_uuid, treatment_uuid);
CREATE INDEX idx_tsi_set_seq        ON treatment_set_items (set_uuid, sequence_no);
CREATE INDEX idx_treatment          ON treatment_set_items (treatment_uuid);
CREATE INDEX idx_quality            ON treatment_set_items (deleted_at, updated_at, id);
CREATE INDEX idx_clinic_list        ON treatment_set_items (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1320_treatment_idx_treatment_set_items.sql>>>

<<<FILE patches/1330_treatment_tr_treatment_set_items_bi_uuid.sql>>>
/* 1330_treatment_tr_treatment_set_items_bi_uuid.sql */
-- @phase: trigger
-- @provides: trigger:bi_treatment_set_items_uuid
-- @requires: table:treatment_set_items, function:uuid_v7_bin, table:treatment_sets
-- 役割: UUID自動採番＋treatment_setsからclinic_uuid継承（NULL時のみ）。原文どおり。

DROP TRIGGER IF EXISTS bi_treatment_set_items_uuid;

DELIMITER $$
CREATE TRIGGER bi_treatment_set_items_uuid
BEFORE INSERT ON treatment_set_items
FOR EACH ROW
BEGIN
  DECLARE v_set_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_sets）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT ts.clinic_uuid INTO v_set_clinic
      FROM treatment_sets ts
     WHERE ts.uuid = NEW.set_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_set_clinic;
  END IF;
END$$
DELIMITER ;
<<<END patches/1330_treatment_tr_treatment_set_items_bi_uuid.sql>>>

<<<FILE patches/1331_treatment_tr_treatment_set_items_bu_rowver.sql>>>
/* 1331_treatment_tr_treatment_set_items_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:bu_treatment_set_items_rowver
-- @requires: table:treatment_set_items
-- 役割: clinic_uuid の不変ガード＋row_version自動更新。原文どおり。

DROP TRIGGER IF EXISTS bu_treatment_set_items_rowver;

DELIMITER $$
CREATE TRIGGER bu_treatment_set_items_rowver
BEFORE UPDATE ON treatment_set_items
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_set_items';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1331_treatment_tr_treatment_set_items_bu_rowver.sql>>>

<<<FILE patches/1400_clinic_create_clinics.sql>>>
/* 1400_clinic_create_clinics.sql */
-- @phase: create
-- @provides: table:clinics
-- @requires: function:uuid_v7_bin
-- 方針: 原文のCREATE本体のみ。索引(UNIQUE/KEY)とトリガは別ファイル。

SET NAMES utf8mb4;

/* 再デプロイ安全化（テーブル本体） */
DROP TABLE IF EXISTS clinics;

CREATE TABLE clinics (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL,                 -- ★不変／更新不可（トリガで固定）
  name              VARCHAR(120) NOT NULL,               -- 例: 〇〇動物病院
  phone             VARCHAR(50)  NULL,
  email             VARCHAR(255) NULL,

  /* サブドメイン/独自ドメイン（どちらも任意／NULL重複OK、値が入れば一意） */
  subdomain         VARCHAR(63)  NULL,
  custom_domain     VARCHAR(255) NULL,

  postal_code       VARCHAR(16)  NULL,
  address_line1     VARCHAR(255) NULL,
  address_line2     VARCHAR(255) NULL,

  notes             TEXT NULL,                           -- 院内メモ（公開しない想定）

  /* 監査・運用列 */
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at        DATETIME NULL,
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1400_clinic_create_clinics.sql>>>

<<<FILE patches/1410_clinic_idx_clinics.sql>>>
/* 1410_clinic_idx_clinics.sql */
-- @phase: idx
-- @provides: index:uq_clinics_uuid, index:uq_clinics_subdomain, index:uq_clinics_custom_domain, index:idx_clinics_list
-- @requires: table:clinics
-- 原文の UNIQUE/KEY をそのまま移設（名称・列順を維持）

CREATE UNIQUE INDEX uq_clinics_uuid          ON clinics(uuid);
CREATE UNIQUE INDEX uq_clinics_subdomain     ON clinics(subdomain);
CREATE UNIQUE INDEX uq_clinics_custom_domain ON clinics(custom_domain);
CREATE INDEX        idx_clinics_list         ON clinics(deleted_at, updated_at, id);
<<<END patches/1410_clinic_idx_clinics.sql>>>

<<<FILE patches/1420_clinic_tr_clinics_bi_uuid_v7.sql>>>
/* 1420_clinic_tr_clinics_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_clinics_bi_uuid_v7
-- @requires: table:clinics, function:uuid_v7_bin
-- 役割: UUID自動採番（未指定時のみ）。原文どおり。

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS tr_clinics_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_clinics_bi_uuid_v7
BEFORE INSERT ON clinics
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;
<<<END patches/1420_clinic_tr_clinics_bi_uuid_v7.sql>>>

<<<FILE patches/1421_clinic_tr_clinics_bu_rowver.sql>>>
/* 1421_clinic_tr_clinics_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_clinics_bu_rowver
-- @requires: table:clinics
-- 役割: UUID不変＋row_versionインクリメント。原文どおり。

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS tr_clinics_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_clinics_bu_rowver
BEFORE UPDATE ON clinics
FOR EACH ROW
BEGIN
  /* UUIDは不変：誤更新による連鎖CASCADE事故を防止 */
  SET NEW.uuid = OLD.uuid;
  /* 楽観ロック／差分検知 */
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1421_clinic_tr_clinics_bu_rowver.sql>>>

<<<FILE patches/1430_clinic_create_clinic_settings.sql>>>
/* 1430_clinic_create_clinic_settings.sql */
-- @phase: create
-- @provides: table:clinic_settings
-- @requires: table:clinics
-- 方針: 原文のCREATE本体＋CHECK制約を保持。索引/一意/FKは別ファイル。

/* 再デプロイ安全化（テーブル本体） */
DROP TABLE IF EXISTS clinic_settings;

CREATE TABLE clinic_settings (
  id                           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                  BINARY(16) NOT NULL,     -- ↔ clinics.uuid（1院1行）
  /* 会計系既定値 */
  yen_per_point                DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  copay_rate                   DECIMAL(5,2) NOT NULL DEFAULT 0.00,   -- 例: 30.00 (=30%)
  default_tax_rate             DECIMAL(4,2) NOT NULL DEFAULT 0.00,   -- 例: 10.00 (=10%)
  price_rounding               ENUM('none','round','ceil','floor') NOT NULL DEFAULT 'round',
  price_rounding_unit          INT UNSIGNED NOT NULL DEFAULT 1,      -- 1/10/100 など

  /* 帳票/表示 */
  billing_contact_name         VARCHAR(128) NULL,       -- 請求窓口担当者名（運用表示）
  invoice_logo_path            VARCHAR(255) NULL,       -- 帳票ロゴ（S3等のパス）
  receipt_footer_text          VARCHAR(255) NULL,       -- レシート定型フッター
  invoice_registration_number  VARCHAR(14)  NULL,       -- 例: 'T' + 13桁

  /* 監査・運用列 */
  created_at                   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at                   DATETIME NULL,
  row_version                  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  /* 任意: インボイス登録番号の形式検証（対応エンジンのみ有効） */
  CONSTRAINT chk_clinic_settings_invoice_reg
    CHECK (invoice_registration_number IS NULL
           OR invoice_registration_number REGEXP '^T[0-9]{13}$')
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1430_clinic_create_clinic_settings.sql>>>

<<<FILE patches/1440_clinic_fk_clinic_settings_clinic_uuid.sql>>>
/* 1440_clinic_fk_clinic_settings_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_clinic_settings_clinic
-- @requires: table:clinic_settings, table:clinics
-- 役割: clinics(uuid) への強整合。原文どおり（ON UPDATE CASCADE / ON DELETE RESTRICT）。

ALTER TABLE clinic_settings
  ADD CONSTRAINT fk_clinic_settings_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1440_clinic_fk_clinic_settings_clinic_uuid.sql>>>

<<<FILE patches/1450_clinic_idx_clinic_settings.sql>>>
/* 1450_clinic_idx_clinic_settings.sql */
-- @phase: idx
-- @provides: index:uq_clinic_settings_clinic, index:idx_clinic_settings_list
-- @requires: table:clinic_settings
-- 原文の UNIQUE/KEY を移設（名称・列順を維持）

CREATE UNIQUE INDEX uq_clinic_settings_clinic ON clinic_settings(clinic_uuid);
CREATE INDEX        idx_clinic_settings_list  ON clinic_settings(deleted_at, updated_at, id);
<<<END patches/1450_clinic_idx_clinic_settings.sql>>>

<<<FILE patches/1460_clinic_tr_clinic_settings_bu_rowver.sql>>>
/* 1460_clinic_tr_clinic_settings_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_clinic_settings_bu_rowver
-- @requires: table:clinic_settings
-- 役割: row_version の自動インクリメント。原文どおり。

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS tr_clinic_settings_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_clinic_settings_bu_rowver
BEFORE UPDATE ON clinic_settings
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1460_clinic_tr_clinic_settings_bu_rowver.sql>>>

<<<FILE patches/1500_insurance_create_insurance_enrollments.sql>>>
/* 1500_insurance_create_insurance_enrollments.sql */
-- @phase: create
-- @provides: table:insurance_enrollments
-- @requires: table:farms
-- 方針: 原文どおりの列定義とCHECK。索引とFKは別ファイルへ移設。
-- 備考: MySQL 8.0+（ウィンドウ関数はビュー側で使用）

SET NAMES utf8mb4;

/* 再デプロイ安全化（本体テーブル） */
DROP TABLE IF EXISTS `insurance_enrollments`;

CREATE TABLE IF NOT EXISTS `insurance_enrollments` (
  /* 識別子（AUTO_INCREMENT 主キー） */
  `id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* テナント（FARM単位, BINARY(16) UUIDv7想定） */
  `farm_uuid` BINARY(16) NOT NULL,

  /* 加入者コード（共済番号など8桁を想定） */
  `subscriber_code` CHAR(8) NOT NULL,

  /* 入力ステータス（英語ENUM：入力値の状態） */
  `status` ENUM('insured','non_insured','unknown') NOT NULL DEFAULT 'unknown',

  /* 期間（端NULL許容）— 両端NULLは today-valid とみなす */
  `start_date` DATE NULL,
  `end_date`   DATE NULL,

  /* 任意付帯 */
  `fiscal_year` YEAR NULL,
  `source_note` VARCHAR(255) NULL,

  /* 無効化(取消)と理由 — voided 行は代表選定から除外 */
  `voided_at`   DATETIME NULL,
  `void_reason` VARCHAR(255) NULL,

  /* v1p9: 楽観ロック & 論理削除 & 監査 */
  `row_version` BIGINT UNSIGNED NOT NULL DEFAULT 1,
  `deleted_at`  DATETIME NULL,
  `created_by`  INT UNSIGNED NULL,
  `created_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 期間整合性（NULLはスルー） */
  CHECK ( `start_date` IS NULL OR `end_date` IS NULL OR `start_date` <= `end_date` )
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;
<<<END patches/1500_insurance_create_insurance_enrollments.sql>>>

<<<FILE patches/1510_insurance_fk_insurance_enrollments_farm_uuid.sql>>>
/* 1510_insurance_fk_insurance_enrollments_farm_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_ins_enro_farm
-- @requires: table:insurance_enrollments, table:farms
-- 役割: farm_uuid → farms.uuid（ON UPDATE CASCADE / ON DELETE RESTRICT）

ALTER TABLE `insurance_enrollments`
  ADD CONSTRAINT `fk_ins_enro_farm`
    FOREIGN KEY (`farm_uuid`) REFERENCES `farms`(`uuid`)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1510_insurance_fk_insurance_enrollments_farm_uuid.sql>>>

<<<FILE patches/1520_insurance_idx_insurance_enrollments.sql>>>
/* 1520_insurance_idx_insurance_enrollments.sql */
-- @phase: idx
-- @provides: index:idx_farm_dates, index:idx_code, index:idx_enroll_list
-- @requires: table:insurance_enrollments
-- 役割: 原文の INDEX/KEY を分離（名称・列順そのまま）

CREATE INDEX `idx_farm_dates` ON `insurance_enrollments` (`farm_uuid`, `start_date`, `end_date`);
CREATE INDEX `idx_code`       ON `insurance_enrollments` (`subscriber_code`);
CREATE INDEX `idx_enroll_list` ON `insurance_enrollments` (`deleted_at`, `updated_at`, `id`);
<<<END patches/1520_insurance_idx_insurance_enrollments.sql>>>

<<<FILE patches/1530_insurance_tr_insurance_enrollments_bu_rowver.sql>>>
/* 1530_insurance_tr_insurance_enrollments_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_insurance_enrollments_rowver_bu
-- @requires: table:insurance_enrollments
-- 役割: row_version の自動インクリメント。原文どおり。

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS `tr_insurance_enrollments_rowver_bu`;

DELIMITER $$
CREATE TRIGGER `tr_insurance_enrollments_rowver_bu`
BEFORE UPDATE ON `insurance_enrollments`
FOR EACH ROW
BEGIN
  SET NEW.`row_version` = OLD.`row_version` + 1;
END$$
DELIMITER ;
<<<END patches/1530_insurance_tr_insurance_enrollments_bu_rowver.sql>>>

<<<FILE patches/1540_insurance_create_view_insurance_current.sql>>>
/* 1540_insurance_create_view_insurance_current.sql */
-- @phase: view
-- @provides: view:insurance_current
-- @requires: table:insurance_enrollments
-- 役割: FARM単位の代表1行ビュー（today-valid 優先 → end DESC → start DESC → id DESC）

/* 再デプロイ安全化（依存ビューの再定義に備える） */
DROP VIEW IF EXISTS `insurance_current`;

CREATE VIEW `insurance_current` AS
WITH ranked AS (
  SELECT
    e.*,
    /* 今日有効？（端NULL許容） */
    CASE
      WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
       AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
      THEN 1 ELSE 0
    END AS is_today_valid,
    /* 代表順位: today-valid → end DESC → start DESC → id DESC */
    ROW_NUMBER() OVER (
      PARTITION BY e.farm_uuid
      ORDER BY
        CASE
          WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
           AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
          THEN 0 ELSE 1
        END,
        COALESCE(e.end_date,  '9999-12-31') DESC,
        COALESCE(e.start_date,'9999-12-31') DESC,
        e.id DESC
    ) AS rn
  FROM `insurance_enrollments` e
  WHERE e.voided_at IS NULL AND e.deleted_at IS NULL
)
SELECT
  r.id,
  r.farm_uuid,
  r.subscriber_code,
  r.status,
  r.start_date,
  r.end_date,
  r.fiscal_year,
  r.source_note,
  r.voided_at,
  r.void_reason,
  r.row_version,
  r.deleted_at,
  r.created_by,
  r.created_at,
  r.updated_at,
  r.is_today_valid,
  CASE WHEN r.end_date IS NULL THEN NULL
       ELSE DATEDIFF(r.end_date, CURDATE())
  END AS days_to_end
FROM ranked r
WHERE r.rn = 1;
<<<END patches/1540_insurance_create_view_insurance_current.sql>>>

<<<FILE patches/1550_insurance_create_view_insurance_current_status.sql>>>
/* 1550_insurance_create_view_insurance_current_status.sql */
-- @phase: view
-- @provides: view:insurance_current_status
-- @requires: view:insurance_current
-- 役割: ラベル化ビュー（active / renewal_due_soon など）。clinic列は持たない。

/* 再デプロイ安全化（このビュー自身の再定義） */
DROP VIEW IF EXISTS `insurance_current_status`;

CREATE VIEW `insurance_current_status` AS
SELECT
  c.farm_uuid,
  c.subscriber_code,
  c.start_date,
  c.end_date,
  c.days_to_end,
  CASE
    WHEN c.is_today_valid = 1 THEN 'active'
    WHEN c.end_date IS NOT NULL AND c.end_date < CURDATE() THEN 'renewal_overdue'
    WHEN c.end_date IS NOT NULL
         AND c.end_date >= CURDATE()
         AND c.end_date <= (CURDATE() + INTERVAL 30 DAY)
      THEN 'renewal_due_soon'
    WHEN c.status = 'non_insured' THEN 'non_insured'
    WHEN c.status = 'insured'     THEN 'insured'
    ELSE 'unknown'
  END AS current_status
FROM `insurance_current` c;
<<<END patches/1550_insurance_create_view_insurance_current_status.sql>>>

<<<FILE patches/1600_appointment_create_appointments.sql>>>
/* 1600_appointment_create_appointments.sql */
-- @phase: create
-- @provides: table:appointments
-- @requires: table:clinics, table:farms, table:individuals, table:vet_users, function:uuid_v7_bin
-- 備考: 索引/外部キー/トリガは分離。本文は原文と同一機能。

SET NAMES utf8mb4;

/* 再デプロイ安全化（本体テーブル） */
DROP TABLE IF EXISTS appointments;

CREATE TABLE appointments (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                 BINARY(16) NULL,               -- ↔ clinics.uuid（SET NULL方針）
  uuid                        BINARY(16) NOT NULL UNIQUE,    -- 予定の一意ID（v7推奨）
  farm_uuid                   BINARY(16) NULL,               -- ↔ farms.uuid（SET NULL）
  individual_uuid             BINARY(16) NULL,               -- ↔ individuals.uuid（SET NULL）
  organizer_vet_user_uuid     BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）
  created_by_vet_uuid         BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）
  updated_by_vet_user_uuid    BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）

  title                       VARCHAR(255) NOT NULL,
  note                        TEXT NULL,
  location_text               VARCHAR(255) NULL,
  start_at                    DATETIME NOT NULL,             -- UTC
  end_at                      DATETIME NOT NULL,             -- UTC
  time_zone                   VARCHAR(64) NULL,              -- 例: 'Asia/Tokyo'
  status                      ENUM('draft','scheduled','cancelled','archived')
                                NOT NULL DEFAULT 'scheduled',

  row_version                 BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at                  DATETIME NULL,
  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1600_appointment_create_appointments.sql>>>

<<<FILE patches/1610_appointment_idx_appointments.sql>>>
/* 1610_appointment_idx_appointments.sql */
-- @phase: idx
-- @provides: index:idx_appt_list, index:idx_appt_tenant_time, index:idx_appt_farm_time, index:idx_appt_individual, index:idx_appt_org
-- @requires: table:appointments

CREATE INDEX idx_appt_list        ON appointments (deleted_at, updated_at, id);
CREATE INDEX idx_appt_tenant_time ON appointments (clinic_uuid, start_at, end_at);
CREATE INDEX idx_appt_farm_time   ON appointments (farm_uuid, start_at, end_at);
CREATE INDEX idx_appt_individual  ON appointments (individual_uuid);
CREATE INDEX idx_appt_org         ON appointments (organizer_vet_user_uuid);
<<<END patches/1610_appointment_idx_appointments.sql>>>

<<<FILE patches/1611_appointment_fk_appointments_clinic_uuid.sql>>>
/* 1611_appointment_fk_appointments_clinic_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_appt_clinic_uuid
-- @requires: table:appointments, table:clinics

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_clinic_uuid
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1611_appointment_fk_appointments_clinic_uuid.sql>>>

<<<FILE patches/1612_appointment_fk_appointments_farm_uuid.sql>>>
/* 1612_appointment_fk_appointments_farm_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_appt_farm_uuid
-- @requires: table:appointments, table:farms

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1612_appointment_fk_appointments_farm_uuid.sql>>>

<<<FILE patches/1613_appointment_fk_appointments_individual_uuid.sql>>>
/* 1613_appointment_fk_appointments_individual_uuid.sql */
-- @phase: fk
-- @provides: fk:fk_appt_individual_uuid
-- @requires: table:appointments, table:individuals

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1613_appointment_fk_appointments_individual_uuid.sql>>>

<<<FILE patches/1614_appointment_fk_appointments_organizer_vet.sql>>>
/* 1614_appointment_fk_appointments_organizer_vet.sql */
-- @phase: fk
-- @provides: fk:fk_appt_organizer_vet
-- @requires: table:appointments, table:vet_users

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_organizer_vet
    FOREIGN KEY (organizer_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1614_appointment_fk_appointments_organizer_vet.sql>>>

<<<FILE patches/1615_appointment_fk_appointments_created_by_vet.sql>>>
/* 1615_appointment_fk_appointments_created_by_vet.sql */
-- @phase: fk
-- @provides: fk:fk_appt_created_by_vet
-- @requires: table:appointments, table:vet_users

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_created_by_vet
    FOREIGN KEY (created_by_vet_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1615_appointment_fk_appointments_created_by_vet.sql>>>

<<<FILE patches/1616_appointment_fk_appointments_updated_by_vet.sql>>>
/* 1616_appointment_fk_appointments_updated_by_vet.sql */
-- @phase: fk
-- @provides: fk:fk_appt_updated_by_vet
-- @requires: table:appointments, table:vet_users

ALTER TABLE appointments
  ADD CONSTRAINT fk_appt_updated_by_vet
    FOREIGN KEY (updated_by_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1616_appointment_fk_appointments_updated_by_vet.sql>>>

<<<FILE patches/1620_appointment_tr_appointments_bi_uuid_v7.sql>>>
/* 1620_appointment_tr_appointments_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_appointments_bi_uuid_v7
-- @requires: table:appointments, function:uuid_v7_bin

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS tr_appointments_bi_uuid_v7;

DELIMITER $$
CREATE TRIGGER tr_appointments_bi_uuid_v7
BEFORE INSERT ON appointments
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/1620_appointment_tr_appointments_bi_uuid_v7.sql>>>

<<<FILE patches/1621_appointment_tr_appointments_bu_rowver.sql>>>
/* 1621_appointment_tr_appointments_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_appointments_bu_rowver
-- @requires: table:appointments

/* 再デプロイ安全化（トリガ個別） */
DROP TRIGGER IF EXISTS tr_appointments_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_appointments_bu_rowver
BEFORE UPDATE ON appointments
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1621_appointment_tr_appointments_bu_rowver.sql>>>

<<<FILE patches/1630_appointment_create_clinic_google_tokens.sql>>>
/* 1630_appointment_create_clinic_google_tokens.sql */
-- @phase: create
-- @provides: table:clinic_google_tokens
-- @requires: table:clinics

DROP TABLE IF EXISTS clinic_google_tokens;

CREATE TABLE clinic_google_tokens (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid          BINARY(16) NOT NULL,                 -- ↔ clinics.uuid
  google_email         VARCHAR(255) NOT NULL,
  access_token_enc     TEXT NOT NULL,                       -- 暗号化済み
  refresh_token_enc    TEXT NOT NULL,                       -- 暗号化済み
  token_type           VARCHAR(32) NULL,
  scopes               TEXT NULL,
  expires_at           DATETIME NULL,
  revoked_at           DATETIME NULL,

  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1630_appointment_create_clinic_google_tokens.sql>>>

<<<FILE patches/1640_appointment_idx_clinic_google_tokens.sql>>>
/* 1640_appointment_idx_clinic_google_tokens.sql */
-- @phase: idx
-- @provides: index:uq_clinic_token, index:idx_tokens_list, index:idx_google_email
-- @requires: table:clinic_google_tokens

CREATE UNIQUE INDEX uq_clinic_token ON clinic_google_tokens (clinic_uuid);
CREATE INDEX idx_tokens_list       ON clinic_google_tokens (updated_at, id);
CREATE INDEX idx_google_email      ON clinic_google_tokens (google_email);
<<<END patches/1640_appointment_idx_clinic_google_tokens.sql>>>

<<<FILE patches/1650_appointment_fk_clinic_google_tokens_clinic.sql>>>
/* 1650_appointment_fk_clinic_google_tokens_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_clinic_token_clinic
-- @requires: table:clinic_google_tokens, table:clinics

ALTER TABLE clinic_google_tokens
  ADD CONSTRAINT fk_clinic_token_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1650_appointment_fk_clinic_google_tokens_clinic.sql>>>

<<<FILE patches/1660_appointment_tr_clinic_google_tokens_bu_rowver.sql>>>
/* 1660_appointment_tr_clinic_google_tokens_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_clinic_google_tokens_bu_rowver
-- @requires: table:clinic_google_tokens

DROP TRIGGER IF EXISTS tr_clinic_google_tokens_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_clinic_google_tokens_bu_rowver
BEFORE UPDATE ON clinic_google_tokens
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1660_appointment_tr_clinic_google_tokens_bu_rowver.sql>>>

<<<FILE patches/1670_appointment_create_clinic_calendar_settings.sql>>>
/* 1670_appointment_create_clinic_calendar_settings.sql */
-- @phase: create
-- @provides: table:clinic_calendar_settings
-- @requires: table:clinics, table:vet_users

DROP TABLE IF EXISTS clinic_calendar_settings;

CREATE TABLE clinic_calendar_settings (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                 BINARY(16) NOT NULL,           -- ↔ clinics.uuid
  calendar_id                 VARCHAR(255) NOT NULL,         -- '...@group.calendar.google.com'
  calendar_summary            VARCHAR(255) NULL,
  sync_owner_vet_user_uuid    BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）

  row_version                 BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1670_appointment_create_clinic_calendar_settings.sql>>>

<<<FILE patches/1680_appointment_idx_clinic_calendar_settings.sql>>>
/* 1680_appointment_idx_clinic_calendar_settings.sql */
-- @phase: idx
-- @provides: index:uq_clinic_calendar, index:idx_calendar_id, index:idx_clinic_calendar_list
-- @requires: table:clinic_calendar_settings

CREATE UNIQUE INDEX uq_clinic_calendar    ON clinic_calendar_settings (clinic_uuid);
CREATE INDEX        idx_calendar_id       ON clinic_calendar_settings (calendar_id);
CREATE INDEX        idx_clinic_calendar_list ON clinic_calendar_settings (updated_at, id);
<<<END patches/1680_appointment_idx_clinic_calendar_settings.sql>>>

<<<FILE patches/1690_appointment_fk_clinic_calendar_settings_clinic.sql>>>
/* 1690_appointment_fk_clinic_calendar_settings_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_clinic_calendar_clinic
-- @requires: table:clinic_calendar_settings, table:clinics

ALTER TABLE clinic_calendar_settings
  ADD CONSTRAINT fk_clinic_calendar_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1690_appointment_fk_clinic_calendar_settings_clinic.sql>>>

<<<FILE patches/1700_appointment_fk_clinic_calendar_settings_sync_owner.sql>>>
/* 1700_appointment_fk_clinic_calendar_settings_sync_owner.sql */
-- @phase: fk
-- @provides: fk:fk_clinic_calendar_sync_owner
-- @requires: table:clinic_calendar_settings, table:vet_users

ALTER TABLE clinic_calendar_settings
  ADD CONSTRAINT fk_clinic_calendar_sync_owner
    FOREIGN KEY (sync_owner_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1700_appointment_fk_clinic_calendar_settings_sync_owner.sql>>>

<<<FILE patches/1710_appointment_tr_clinic_calendar_settings_bu_rowver.sql>>>
/* 1710_appointment_tr_clinic_calendar_settings_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_clinic_calendar_settings_bu_rowver
-- @requires: table:clinic_calendar_settings

DROP TRIGGER IF EXISTS tr_clinic_calendar_settings_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_clinic_calendar_settings_bu_rowver
BEFORE UPDATE ON clinic_calendar_settings
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1710_appointment_tr_clinic_calendar_settings_bu_rowver.sql>>>

<<<FILE patches/1720_appointment_create_appointment_event_links.sql>>>
/* 1720_appointment_create_appointment_event_links.sql */
-- @phase: create
-- @provides: table:appointment_event_links
-- @requires: table:clinics, table:appointments, table:vet_users

DROP TABLE IF EXISTS appointment_event_links;

CREATE TABLE appointment_event_links (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid            BINARY(16) NOT NULL,           -- ↔ clinics.uuid（CASCADE）
  appointment_uuid       BINARY(16) NOT NULL,           -- ↔ appointments.uuid（CASCADE）
  google_calendar_id     VARCHAR(255) NOT NULL,
  google_event_id        VARCHAR(255) NOT NULL,
  ical_uid               VARCHAR(255) NULL,
  etag                   VARCHAR(255) NULL,
  writer_vet_user_uuid   BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL, 監査用）
  status                 ENUM('pending','synced','failed','deleted','skipped')
                           NOT NULL DEFAULT 'pending',
  synced_at              DATETIME NULL,

  row_version            BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1720_appointment_create_appointment_event_links.sql>>>

<<<FILE patches/1730_appointment_idx_appointment_event_links.sql>>>
/* 1730_appointment_idx_appointment_event_links.sql */
-- @phase: idx
-- @provides: index:uq_link_per_calendar, index:idx_link_gcal, index:idx_link_writer, index:idx_ael_list
-- @requires: table:appointment_event_links

CREATE UNIQUE INDEX uq_link_per_calendar ON appointment_event_links (clinic_uuid, appointment_uuid, google_calendar_id);
CREATE INDEX idx_link_gcal   ON appointment_event_links (google_calendar_id, google_event_id);
CREATE INDEX idx_link_writer ON appointment_event_links (writer_vet_user_uuid);
CREATE INDEX idx_ael_list    ON appointment_event_links (updated_at, id);
<<<END patches/1730_appointment_idx_appointment_event_links.sql>>>

<<<FILE patches/1740_appointment_fk_ael_clinic.sql>>>
/* 1740_appointment_fk_ael_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_ael_clinic
-- @requires: table:appointment_event_links, table:clinics

ALTER TABLE appointment_event_links
  ADD CONSTRAINT fk_ael_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1740_appointment_fk_ael_clinic.sql>>>

<<<FILE patches/1741_appointment_fk_ael_appt.sql>>>
/* 1741_appointment_fk_ael_appt.sql */
-- @phase: fk
-- @provides: fk:fk_ael_appt
-- @requires: table:appointment_event_links, table:appointments

ALTER TABLE appointment_event_links
  ADD CONSTRAINT fk_ael_appt
    FOREIGN KEY (appointment_uuid) REFERENCES appointments(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1741_appointment_fk_ael_appt.sql>>>

<<<FILE patches/1742_appointment_fk_ael_writer_vet.sql>>>
/* 1742_appointment_fk_ael_writer_vet.sql */
-- @phase: fk
-- @provides: fk:fk_ael_writer_vet
-- @requires: table:appointment_event_links, table:vet_users

ALTER TABLE appointment_event_links
  ADD CONSTRAINT fk_ael_writer_vet
    FOREIGN KEY (writer_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;
<<<END patches/1742_appointment_fk_ael_writer_vet.sql>>>

<<<FILE patches/1750_appointment_tr_appointment_event_links_bu_rowver.sql>>>
/* 1750_appointment_tr_appointment_event_links_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_appointment_event_links_bu_rowver
-- @requires: table:appointment_event_links

DROP TRIGGER IF EXISTS tr_appointment_event_links_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_appointment_event_links_bu_rowver
BEFORE UPDATE ON appointment_event_links
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1750_appointment_tr_appointment_event_links_bu_rowver.sql>>>

<<<FILE patches/1760_appointment_create_calendar_sync_state.sql>>>
/* 1760_appointment_create_calendar_sync_state.sql */
-- @phase: create
-- @provides: table:calendar_sync_state
-- @requires: table:clinics

DROP TABLE IF EXISTS calendar_sync_state;

CREATE TABLE calendar_sync_state (
  id            INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid   BINARY(16) NOT NULL,                -- ↔ clinics.uuid（CASCADE）
  calendar_id   VARCHAR(255) NOT NULL,
  sync_token    TEXT NOT NULL,

  row_version   BIGINT UNSIGNED NOT NULL DEFAULT 1,
  updated_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1760_appointment_create_calendar_sync_state.sql>>>

<<<FILE patches/1770_appointment_idx_calendar_sync_state.sql>>>
/* 1770_appointment_idx_calendar_sync_state.sql */
-- @phase: idx
-- @provides: index:uq_calendar_sync, index:idx_calendar, index:idx_css_list
-- @requires: table:calendar_sync_state

CREATE UNIQUE INDEX uq_calendar_sync ON calendar_sync_state (clinic_uuid, calendar_id);
CREATE INDEX idx_calendar           ON calendar_sync_state (calendar_id);
CREATE INDEX idx_css_list           ON calendar_sync_state (updated_at, id);
<<<END patches/1770_appointment_idx_calendar_sync_state.sql>>>

<<<FILE patches/1780_appointment_fk_calendar_sync_state_clinic.sql>>>
/* 1780_appointment_fk_calendar_sync_state_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_sync_clinic
-- @requires: table:calendar_sync_state, table:clinics

ALTER TABLE calendar_sync_state
  ADD CONSTRAINT fk_sync_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1780_appointment_fk_calendar_sync_state_clinic.sql>>>

<<<FILE patches/1790_appointment_tr_calendar_sync_state_bu_rowver.sql>>>
/* 1790_appointment_tr_calendar_sync_state_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_calendar_sync_state_bu_rowver
-- @requires: table:calendar_sync_state

DROP TRIGGER IF EXISTS tr_calendar_sync_state_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_calendar_sync_state_bu_rowver
BEFORE UPDATE ON calendar_sync_state
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1790_appointment_tr_calendar_sync_state_bu_rowver.sql>>>

<<<FILE patches/1800_appointment_create_appointment_fulfillments.sql>>>
/* 1800_appointment_create_appointment_fulfillments.sql */
-- @phase: create
-- @provides: table:appointment_fulfillments
-- @requires: table:clinics, table:appointments, table:visits

DROP TABLE IF EXISTS appointment_fulfillments;

CREATE TABLE appointment_fulfillments (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid        BINARY(16) NOT NULL,           -- ↔ clinics.uuid（CASCADE）
  appointment_uuid   BINARY(16) NOT NULL,           -- ↔ appointments.uuid（CASCADE）
  visit_uuid         BINARY(16) NOT NULL,           -- ↔ visits.uuid（CASCADE）
  fulfilled_at       DATETIME NOT NULL,
  note               VARCHAR(255) NULL,

  row_version        BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1800_appointment_create_appointment_fulfillments.sql>>>

<<<FILE patches/1810_appointment_idx_appointment_fulfillments.sql>>>
/* 1810_appointment_idx_appointment_fulfillments.sql */
-- @phase: idx
-- @provides: index:uq_appt_visit, index:idx_visit, index:idx_fulfill_list
-- @requires: table:appointment_fulfillments

CREATE UNIQUE INDEX uq_appt_visit  ON appointment_fulfillments (appointment_uuid, visit_uuid);
CREATE INDEX idx_visit             ON appointment_fulfillments (visit_uuid);
CREATE INDEX idx_fulfill_list      ON appointment_fulfillments (created_at, id);
<<<END patches/1810_appointment_idx_appointment_fulfillments.sql>>>

<<<FILE patches/1820_appointment_fk_appointment_fulfillments_clinic.sql>>>
/* 1820_appointment_fk_appointment_fulfillments_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_fulfill_clinic
-- @requires: table:appointment_fulfillments, table:clinics

ALTER TABLE appointment_fulfillments
  ADD CONSTRAINT fk_fulfill_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1820_appointment_fk_appointment_fulfillments_clinic.sql>>>

<<<FILE patches/1821_appointment_fk_appointment_fulfillments_appt.sql>>>
/* 1821_appointment_fk_appointment_fulfillments_appt.sql */
-- @phase: fk
-- @provides: fk:fk_fulfill_appt
-- @requires: table:appointment_fulfillments, table:appointments

ALTER TABLE appointment_fulfillments
  ADD CONSTRAINT fk_fulfill_appt
    FOREIGN KEY (appointment_uuid) REFERENCES appointments(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1821_appointment_fk_appointment_fulfillments_appt.sql>>>

<<<FILE patches/1822_appointment_fk_appointment_fulfillments_visit.sql>>>
/* 1822_appointment_fk_appointment_fulfillments_visit.sql */
-- @phase: fk
-- @provides: fk:fk_fulfill_visit
-- @requires: table:appointment_fulfillments, table:visits

ALTER TABLE appointment_fulfillments
  ADD CONSTRAINT fk_fulfill_visit
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE;
<<<END patches/1822_appointment_fk_appointment_fulfillments_visit.sql>>>

<<<FILE patches/1830_appointment_tr_appointment_fulfillments_bu_rowver.sql>>>
/* 1830_appointment_tr_appointment_fulfillments_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_appointment_fulfillments_bu_rowver
-- @requires: table:appointment_fulfillments

DROP TRIGGER IF EXISTS tr_appointment_fulfillments_bu_rowver;

DELIMITER $$
CREATE TRIGGER tr_appointment_fulfillments_bu_rowver
BEFORE UPDATE ON appointment_fulfillments
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;
<<<END patches/1830_appointment_tr_appointment_fulfillments_bu_rowver.sql>>>

<<<FILE patches/1900_farmmirror_create_farms.sql>>>
/* 1900_farmmirror_create_farms.sql */
-- @phase: create
-- @provides: table:farms
-- @requires: table:clinics, function:uuid_v7_bin
-- 備考: 索引/UNIQUE/FK/トリガは別ファイルへ分離（本文は原文の列定義を維持）

--SET NAMES utf8mb4;はinitに分離

DROP TABLE IF EXISTS farms;
CREATE TABLE farms (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL,
  clinic_uuid      BINARY(16) NOT NULL,              -- ↔ clinics.uuid（院所属・厳格）
  name             VARCHAR(120) NOT NULL,
  billing_name     VARCHAR(120) NULL,
  billing_address  VARCHAR(255) NULL,

  row_hash         CHAR(64) NULL,                    -- 任意：差分検出や外部同期の補助
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME NULL,                    -- ソフトデリート（論理削除）
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1 -- 楽観ロック/差分検知
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1900_farmmirror_create_farms.sql>>>

<<<FILE patches/1910_farmmirror_idx_farms.sql>>>
/* 1910_farmmirror_idx_farms.sql */
-- @phase: idx
-- @provides: index:uq_farms_uuid, index:uq_farms_uuid_clinic, index:idx_farms_name, index:idx_farms_list, index:idx_farms_clinic_list
-- @requires: table:farms

CREATE UNIQUE INDEX uq_farms_uuid         ON farms (uuid);
CREATE UNIQUE INDEX uq_farms_uuid_clinic  ON farms (uuid, clinic_uuid); -- 合成FK参照先
CREATE INDEX        idx_farms_name        ON farms (name);
CREATE INDEX        idx_farms_list        ON farms (deleted_at, updated_at, id);
CREATE INDEX        idx_farms_clinic_list ON farms (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1910_farmmirror_idx_farms.sql>>>

<<<FILE patches/1911_farmmirror_fk_farms_clinic.sql>>>
/* 1911_farmmirror_fk_farms_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_farms_clinic
-- @requires: table:farms, table:clinics

ALTER TABLE farms
  ADD CONSTRAINT fk_farms_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1911_farmmirror_fk_farms_clinic.sql>>>

<<<FILE patches/1920_farmmirror_tr_farms_bi_uuid_v7.sql>>>
/* 1920_farmmirror_tr_farms_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_farms_bi_uuid_v7
-- @requires: table:farms, function:uuid_v7_bin
-- 役割: UUID未指定時の自動採番（原文どおり）

DROP TRIGGER IF EXISTS tr_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farms_bi_uuid_v7
BEFORE INSERT ON farms
FOR EACH ROW
BEGIN
  /* UUIDはBINARY(16)/v7想定。未指定時のみ自動採番。 */
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;
<<<END patches/1920_farmmirror_tr_farms_bi_uuid_v7.sql>>>

<<<FILE patches/1921_farmmirror_tr_farms_bu_rowver_lockuuid.sql>>>
/* 1921_farmmirror_tr_farms_bu_rowver_lockuuid.sql */
-- @phase: trigger
-- @provides: trigger:tr_farms_bu_rowver_lockuuid
-- @requires: table:farms
-- 役割: UUID固定＋row_versionインクリメント（原文どおり）

DROP TRIGGER IF EXISTS tr_farms_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farms_bu_rowver_lockuuid
BEFORE UPDATE ON farms
FOR EACH ROW
BEGIN
  /* UUIDは不変・row_versionは+1。clinic_uuidの付け替えはFKが整合性を担保。 */
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1921_farmmirror_tr_farms_bu_rowver_lockuuid.sql>>>

<<<FILE patches/1930_farmmirror_create_vet_users.sql>>>
/* 1930_farmmirror_create_vet_users.sql */
-- @phase: create
-- @provides: table:vet_users
-- @requires: table:clinics, function:uuid_v7_bin

DROP TABLE IF EXISTS vet_users;
CREATE TABLE vet_users (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid               BINARY(16) NOT NULL,
  clinic_uuid        BINARY(16) NOT NULL,            -- ↔ clinics.uuid
  display_name       VARCHAR(100) NOT NULL,
  email              VARCHAR(255) NULL,
  phone              VARCHAR(50) NULL,
  role_label         VARCHAR(100) NULL,              -- 例: 院長/獣医師/スタッフ
  clinic_branch_name VARCHAR(120) NULL,              -- 分院メモ（UI補助）

  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at         DATETIME NULL,
  row_version        BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1930_farmmirror_create_vet_users.sql>>>

<<<FILE patches/1940_farmmirror_idx_vet_users.sql>>>
/* 1940_farmmirror_idx_vet_users.sql */
-- @phase: idx
-- @provides: index:uq_vet_users_uuid, index:idx_vet_users_name, index:idx_vet_users_email, index:idx_vet_users_list, index:idx_vet_users_clinic_list
-- @requires: table:vet_users

CREATE UNIQUE INDEX uq_vet_users_uuid        ON vet_users (uuid);
CREATE INDEX        idx_vet_users_name       ON vet_users (display_name);
CREATE INDEX        idx_vet_users_email      ON vet_users (email);
CREATE INDEX        idx_vet_users_list       ON vet_users (deleted_at, updated_at, id);
CREATE INDEX        idx_vet_users_clinic_list ON vet_users (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1940_farmmirror_idx_vet_users.sql>>>

<<<FILE patches/1941_farmmirror_fk_vet_users_clinic.sql>>>
/* 1941_farmmirror_fk_vet_users_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_vet_users_clinic
-- @requires: table:vet_users, table:clinics

ALTER TABLE vet_users
  ADD CONSTRAINT fk_vet_users_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/1941_farmmirror_fk_vet_users_clinic.sql>>>

<<<FILE patches/1950_farmmirror_tr_vet_users_bi_uuid_v7.sql>>>
/* 1950_farmmirror_tr_vet_users_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_vet_users_bi_uuid_v7
-- @requires: table:vet_users, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_vet_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bi_uuid_v7
BEFORE INSERT ON vet_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;
<<<END patches/1950_farmmirror_tr_vet_users_bi_uuid_v7.sql>>>

<<<FILE patches/1951_farmmirror_tr_vet_users_bu_rowver_lockuuid.sql>>>
/* 1951_farmmirror_tr_vet_users_bu_rowver_lockuuid.sql */
-- @phase: trigger
-- @provides: trigger:tr_vet_users_bu_rowver_lockuuid
-- @requires: table:vet_users

DROP TRIGGER IF EXISTS tr_vet_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bu_rowver_lockuuid
BEFORE UPDATE ON vet_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/1951_farmmirror_tr_vet_users_bu_rowver_lockuuid.sql>>>

<<<FILE patches/1960_farmmirror_create_farm_users.sql>>>
/* 1960_farmmirror_create_farm_users.sql */
-- @phase: create
-- @provides: table:farm_users
-- @requires: table:farms, function:uuid_v7_bin

DROP TABLE IF EXISTS farm_users;
CREATE TABLE farm_users (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL,

  farm_uuid    BINARY(16) NOT NULL,                 -- ↔ farms.uuid
  clinic_uuid  BINARY(16) NOT NULL,                 -- 院スコープ検索用に保持（親から継承）

  display_name VARCHAR(100) NOT NULL,
  email        VARCHAR(255) NULL,
  phone        VARCHAR(50) NULL,
  role_label   VARCHAR(100) NULL,                   -- 例: 場長/経理/担当

  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1960_farmmirror_create_farm_users.sql>>>

<<<FILE patches/1970_farmmirror_idx_farm_users.sql>>>
/* 1970_farmmirror_idx_farm_users.sql */
-- @phase: idx
-- @provides: index:uq_farm_users_uuid, index:idx_farm_users_farm, index:idx_farm_users_email, index:idx_farm_users_list, index:idx_farm_users_clinic_list
-- @requires: table:farm_users

CREATE UNIQUE INDEX uq_farm_users_uuid        ON farm_users (uuid);
CREATE INDEX        idx_farm_users_farm       ON farm_users (farm_uuid, display_name);
CREATE INDEX        idx_farm_users_email      ON farm_users (email);
CREATE INDEX        idx_farm_users_list       ON farm_users (deleted_at, updated_at, id);
CREATE INDEX        idx_farm_users_clinic_list ON farm_users (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/1970_farmmirror_idx_farm_users.sql>>>

<<<FILE patches/1971_farmmirror_fk_farm_users_farm_clinic.sql>>>
/* 1971_farmmirror_fk_farm_users_farm_clinic.sql */
-- @phase: fk
-- @provides: fk:fk_fu_farm_clinic
-- @requires: table:farm_users, table:farms (unique: uq_farms_uuid_clinic)

ALTER TABLE farm_users
  ADD CONSTRAINT fk_fu_farm_clinic
    FOREIGN KEY (farm_uuid, clinic_uuid)
    REFERENCES farms (uuid, clinic_uuid)
    ON UPDATE CASCADE
    ON DELETE RESTRICT;
<<<END patches/1971_farmmirror_fk_farm_users_farm_clinic.sql>>>

<<<FILE patches/1980_farmmirror_tr_farm_users_bi_uuid_v7.sql>>>
/* 1980_farmmirror_tr_farm_users_bi_uuid_v7.sql */
-- @phase: trigger
-- @provides: trigger:tr_farm_users_bi_uuid_v7
-- @requires: table:farm_users, table:farms, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bi_uuid_v7
BEFORE INSERT ON farm_users
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 親farmから clinic_uuid を継承（手入力・取り違えの防止） */
  SELECT f.clinic_uuid INTO v_clinic
    FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  SET NEW.clinic_uuid = v_clinic;
END$$
DELIMITER ;
<<<END patches/1980_farmmirror_tr_farm_users_bi_uuid_v7.sql>>>

<<<FILE patches/1981_farmmirror_tr_farm_users_bu_rowver_lockuuid.sql>>>
/* 1981_farmmirror_tr_farm_users_bu_rowver_lockuuid.sql */
-- @phase: trigger
-- @provides: trigger:tr_farm_users_bu_rowver_lockuuid
-- @requires: table:farm_users, table:farms

DROP TRIGGER IF EXISTS tr_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farm_users
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  SET NEW.uuid = OLD.uuid;                    -- UUIDは不変
  SET NEW.row_version = OLD.row_version + 1;  -- 楽観ロック

  /* 親farmの変更や親側clinic付け替えに追随（再継承） */
  SELECT f.clinic_uuid INTO v_clinic
    FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  SET NEW.clinic_uuid = v_clinic;
END$$
DELIMITER ;
<<<END patches/1981_farmmirror_tr_farm_users_bu_rowver_lockuuid.sql>>>

<<<FILE patches/1990_farmmirror_create_farmdb_farms_mirror.sql>>>
/* 1990_farmmirror_create_farmdb_farms_mirror.sql */
-- @phase: create
-- @provides: table:farmdb_farms_mirror

DROP TABLE IF EXISTS farmdb_farms_mirror;
CREATE TABLE farmdb_farms_mirror (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL UNIQUE,     -- farmDB側 farm.uuid
  clinic_uuid       BINARY(16) NULL,                -- farmDBの値そのまま（NULL可）
  name              VARCHAR(120) NOT NULL,
  billing_name      VARCHAR(120) NULL,
  billing_address   VARCHAR(255) NULL,
  deleted_at        DATETIME NULL,                  -- 外部削除の鏡像（tombstone）
  updated_at_source DATETIME NULL,                  -- farmDB側の更新時刻（差分カーソル用）

  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1990_farmmirror_create_farmdb_farms_mirror.sql>>>

<<<FILE patches/1991_farmmirror_idx_farmdb_farms_mirror.sql>>>
/* 1991_farmmirror_idx_farmdb_farms_mirror.sql */
-- @phase: idx
-- @provides: index:idx_fdb_farms_clinic_list, index:idx_fdb_farms_updated, index:idx_fdb_farms_name
-- @requires: table:farmdb_farms_mirror

CREATE INDEX idx_fdb_farms_clinic_list ON farmdb_farms_mirror (clinic_uuid, deleted_at, updated_at, id);
CREATE INDEX idx_fdb_farms_updated     ON farmdb_farms_mirror (updated_at_source);
CREATE INDEX idx_fdb_farms_name        ON farmdb_farms_mirror (name);
<<<END patches/1991_farmmirror_idx_farmdb_farms_mirror.sql>>>

<<<FILE patches/1992_farmmirror_create_farmdb_individuals_mirror.sql>>>
/* 1992_farmmirror_create_farmdb_individuals_mirror.sql */
-- @phase: create
-- @provides: table:farmdb_individuals_mirror

DROP TABLE IF EXISTS farmdb_individuals_mirror;
CREATE TABLE farmdb_individuals_mirror (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,
  clinic_uuid          BINARY(16) NULL,             -- farmDB由来（NULL可）
  farm_uuid            BINARY(16) NOT NULL,         -- 参照先もfarmDBのUUID（FKなし）
  user_uuid            BINARY(16) NULL,

  name                 VARCHAR(100) NULL,
  ear_tag              CHAR(10) NULL,
  status               ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender               ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date           DATE NULL,
  death_date           DATE NULL,
  sire_name            VARCHAR(100) NULL,

  genetic_dam_uuid     BINARY(16) NULL,
  nursing_dam_uuid     BINARY(16) NULL,
  genetic_dam_ear_tag  CHAR(10) NULL,
  genetic_dam_name     VARCHAR(100) NULL,
  nursing_dam_ear_tag  CHAR(10) NULL,
  nursing_dam_name     VARCHAR(100) NULL,

  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME NULL,
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1992_farmmirror_create_farmdb_individuals_mirror.sql>>>

<<<FILE patches/1994_farmmirror_create_farmdb_farm_users_mirror.sql>>>
/* 1994_farmmirror_create_farmdb_farm_users_mirror.sql */
-- @phase: create
-- @provides: table:farmdb_farm_users_mirror

DROP TABLE IF EXISTS farmdb_farm_users_mirror;
CREATE TABLE farmdb_farm_users_mirror (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,
  clinic_uuid  BINARY(16) NULL,            -- farmDB由来（NULL可）
  farm_uuid    BINARY(16) NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  email        VARCHAR(255) NULL,
  phone        VARCHAR(50) NULL,
  role_label   VARCHAR(100) NULL,

  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1994_farmmirror_create_farmdb_farm_users_mirror.sql>>>

<<<FILE patches/1995_farmmirror_idx_farmdb_farm_users_mirror.sql>>>
/* 1995_farmmirror_idx_farmdb_farm_users_mirror.sql */
-- @phase: idx
-- @provides: index:idx_fdb_farm_users_clinic_list, index:idx_fdb_farm_users_farm, index:idx_fdb_farm_users_email
-- @requires: table:farmdb_farm_users_mirror

CREATE INDEX idx_fdb_farm_users_clinic_list ON farmdb_farm_users_mirror (clinic_uuid, deleted_at, updated_at, id);
CREATE INDEX idx_fdb_farm_users_farm        ON farmdb_farm_users_mirror (farm_uuid, display_name);
CREATE INDEX idx_fdb_farm_users_email       ON farmdb_farm_users_mirror (email);
<<<END patches/1995_farmmirror_idx_farmdb_farm_users_mirror.sql>>>

<<<FILE patches/1996_farmmirror_create_entity_links.sql>>>
/* 1996_farmmirror_create_entity_links.sql */
-- @phase: create
-- @provides: table:entity_links
-- @requires: table:farms, table:farm_users, table:farmdb_*_mirror, table:individuals (individual分岐を使う場合)

DROP TABLE IF EXISTS entity_links;
CREATE TABLE entity_links (
  id            BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  clinic_uuid   BINARY(16) NOT NULL,                  -- ← local 由来（トリガで確定）
  entity_type   ENUM('farm','individual','farm_user') NOT NULL,
  source_system ENUM('farmdb') NOT NULL DEFAULT 'farmdb',

  local_uuid    BINARY(16) NOT NULL,                  -- VetDB SoT 側 UUID
  remote_uuid   BINARY(16) NOT NULL,                  -- farmDB mirror 側 UUID

  is_primary    TINYINT(1) NOT NULL DEFAULT 1,        -- 将来: 多対1許容時の“主”印
  note          VARCHAR(255) NULL,

  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/1996_farmmirror_create_entity_links.sql>>>

<<<FILE patches/1997_farmmirror_idx_entity_links.sql>>>
/* 1997_farmmirror_idx_entity_links.sql */
-- @phase: idx
-- @provides: index:uq_entity_links_remote, index:idx_entity_links_local, index:idx_entity_links_clinic
-- @requires: table:entity_links

CREATE UNIQUE INDEX uq_entity_links_remote ON entity_links (entity_type, source_system, remote_uuid);
CREATE INDEX        idx_entity_links_local  ON entity_links (entity_type, local_uuid);
CREATE INDEX        idx_entity_links_clinic ON entity_links (clinic_uuid, entity_type, updated_at, id);
<<<END patches/1997_farmmirror_idx_entity_links.sql>>>

<<<FILE patches/1998_farmmirror_tr_entity_links_bi_scope.sql>>>
/* 1998_farmmirror_tr_entity_links_bi_scope.sql */
-- @phase: trigger
-- @provides: trigger:tr_entity_links_bi_scope
-- @requires: table:entity_links, table:farms, table:farm_users, table:farmdb_*_mirror, table:individuals(任意)
-- 役割: local由来clinicの強制確定＋remote clinicとの越境拒否（原文どおり）

DROP TRIGGER IF EXISTS tr_entity_links_bi_scope;
DELIMITER $$
CREATE TRIGGER tr_entity_links_bi_scope
BEFORE INSERT ON entity_links
FOR EACH ROW
BEGIN
  DECLARE v_local_clinic  BINARY(16);
  DECLARE v_remote_clinic BINARY(16);

  /* 1) local 側 clinic を確定（entity_typeに応じて参照先が異なる） */
  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farms WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      /* farm_users は合成FKにより (farm_uuid, clinic_uuid) が親と常に一致 */
      SELECT clinic_uuid INTO v_local_clinic
        FROM farm_users WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'individual' THEN
      /* 注意: individuals（SoT）が必要。未導入ならこの分岐は利用しないこと。 */
      SELECT f.clinic_uuid INTO v_local_clinic
        FROM individuals i
        JOIN farms f ON f.uuid = i.farm_uuid
       WHERE i.uuid = NEW.local_uuid
       LIMIT 1;
  END CASE;
  SET NEW.clinic_uuid = v_local_clinic;

  /* 2) remote 側 clinic を取得して院越境を拒否（NULLは許容＝未所属→収容） */
  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farms_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farm_users_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_individuals_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;
  END CASE;

  IF v_remote_clinic IS NOT NULL AND v_remote_clinic <> v_local_clinic THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Cross-clinic link is not allowed';
  END IF;
END$$
DELIMITER ;
<<<END patches/1998_farmmirror_tr_entity_links_bi_scope.sql>>>

<<<FILE patches/1999_farmmirror_tr_entity_links_bu_scope.sql>>>
/* 1999_farmmirror_tr_entity_links_bu_scope.sql */
-- @phase: trigger
-- @provides: trigger:tr_entity_links_bu_scope
-- @requires: table:entity_links, table:farms, table:farm_users, table:farmdb_*_mirror, table:individuals(任意)

DROP TRIGGER IF EXISTS tr_entity_links_bu_scope;
DELIMITER $$
CREATE TRIGGER tr_entity_links_bu_scope
BEFORE UPDATE ON entity_links
FOR EACH ROW
BEGIN
  DECLARE v_local_clinic  BINARY(16);
  DECLARE v_remote_clinic BINARY(16);

  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farms WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farm_users WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT f.clinic_uuid INTO v_local_clinic
        FROM individuals i
        JOIN farms f ON f.uuid = i.farm_uuid
       WHERE i.uuid = NEW.local_uuid
       LIMIT 1;
  END CASE;
  SET NEW.clinic_uuid = v_local_clinic;

  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farms_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farm_users_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_individuals_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;
  END CASE;

  IF v_remote_clinic IS NOT NULL AND v_remote_clinic <> v_local_clinic THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Cross-clinic link is not allowed';
  END IF;
END$$
DELIMITER ;
<<<END patches/1999_farmmirror_tr_entity_links_bu_scope.sql>>>

<<<FILE patches/2000_receipt_create_receipt_header_drafts.sql>>>
/* 2000_receipt_create_receipt_header_drafts.sql */
-- @phase: create
-- @feature: receipt
-- @provides: table:receipt_header_drafts
-- @requires: function:uuid_v7_bin, table:farms
-- 備考: インデックス/一意/外部キー/トリガは別ファイルで付与（原文列定義は維持）

SET NAMES utf8mb4;

DROP TABLE IF EXISTS receipt_header_drafts;
CREATE TABLE IF NOT EXISTS receipt_header_drafts (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（下書きの識別）

  /* 任意のスコープ（印字や絞り込み用） */
  farm_uuid             BINARY(16) NULL,
  clinic_uuid           BINARY(16) NULL,                             -- 当時の所属院（可変：farm変更時に再継承）
  title                 VARCHAR(120) NULL,
  note                  VARCHAR(255) NULL,

  /* 状態遷移（発行で issued に） */
  status                ENUM('open','closed','issued') NOT NULL DEFAULT 'open',
  issued_at             DATETIME NULL,                               -- issued 遷移時刻
  issued_by_user_id     INT UNSIGNED NULL,
  issued_receipt_uuid   BINARY(16) NULL,                             -- 対応する receipt_headers.uuid（作成後にセット）

  /* クリニック設定スナップ（draft時点の値） */
  yen_per_point         DECIMAL(8,2) NOT NULL DEFAULT 10.00,         -- 例: 1点=10円
  copay_rate            DECIMAL(5,4) NOT NULL DEFAULT 0.1000,        -- 例: 10% は 0.1000
  tax_rounding          ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',

  /* 集計（税抜→税→税込） */
  total_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 自由価格（税抜）
  subtotal_yen          INT UNSIGNED NOT NULL DEFAULT 0,             -- 点換算円 + 自由価格（税抜）
  tax_yen               INT UNSIGNED NOT NULL DEFAULT 0,
  total_insurance_yen   INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（保険）
  total_private_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（自由）
  patient_copay_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 患者負担
  insurer_pay_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 保険者負担

  /* 監査（可変テーブルなので row_version / deleted_at を保持） */
  created_by            INT UNSIGNED NULL,
  updated_by            INT UNSIGNED NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at            DATETIME NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/2000_receipt_create_receipt_header_drafts.sql>>>

<<<FILE patches/2005_receipt_idx_receipt_header_drafts.sql>>>
/* 2005_receipt_idx_receipt_header_drafts.sql */
-- @phase: idx
-- @feature: receipt
-- @provides: index:idx_receipt_drafts_list, index:idx_receipt_drafts_farm, index:idx_receipt_drafts_clinic
-- @requires: table:receipt_header_drafts

CREATE INDEX idx_receipt_drafts_list   ON receipt_header_drafts (deleted_at, updated_at, id);
CREATE INDEX idx_receipt_drafts_farm   ON receipt_header_drafts (farm_uuid,   deleted_at, updated_at, id);
CREATE INDEX idx_receipt_drafts_clinic ON receipt_header_drafts (clinic_uuid, deleted_at, updated_at, id);
<<<END patches/2005_receipt_idx_receipt_header_drafts.sql>>>

<<<FILE patches/2006_receipt_fk_receipt_header_drafts_farm_uuid.sql>>>
/* 2006_receipt_fk_receipt_header_drafts_farm_uuid.sql */
-- @phase: fk
-- @feature: receipt
-- @provides: fk:fk_rcpt_drafts_farm
-- @requires: table:receipt_header_drafts, table:farms

ALTER TABLE receipt_header_drafts
  ADD CONSTRAINT fk_rcpt_drafts_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT;
<<<END patches/2006_receipt_fk_receipt_header_drafts_farm_uuid.sql>>>

<<<FILE patches/2007_receipt_tr_receipt_header_drafts_bi_uuid_v7.sql>>>
/* 2007_receipt_tr_receipt_header_drafts_bi_uuid_v7.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_header_drafts_bi_uuid_v7
-- @requires: table:receipt_header_drafts, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bi_uuid_v7
BEFORE INSERT ON receipt_header_drafts
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 挿入時に farm → clinic を継承（弱参照 / FKはfarmにのみ） */
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO v_clinic
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_clinic;
  END IF;
END $$
DELIMITER ;
<<<END patches/2007_receipt_tr_receipt_header_drafts_bi_uuid_v7.sql>>>

<<<FILE patches/2008_receipt_tr_receipt_header_drafts_bu_rowver.sql>>>
/* 2008_receipt_tr_receipt_header_drafts_bu_rowver.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_header_drafts_bu_rowver
-- @requires: table:receipt_header_drafts

DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bu_rowver;
DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bu_rowver
BEFORE UPDATE ON receipt_header_drafts
FOR EACH ROW
BEGIN
  DECLARE v_clinic2 BINARY(16);

  /* 楽観ロック：row_version 自動インクリメント */
  SET NEW.row_version = OLD.row_version + 1;

  /* farm_uuid 変更時は clinic_uuid を再継承 */
  IF (NEW.farm_uuid <> OLD.farm_uuid) OR (NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL) THEN
    SELECT f.clinic_uuid INTO v_clinic2
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_clinic2;
  END IF;
END $$
DELIMITER ;
<<<END patches/2008_receipt_tr_receipt_header_drafts_bu_rowver.sql>>>

<<<FILE patches/2009_receipt_tr_receipt_header_drafts_bi_clinic_inherit.sql>>>
/* 2009_receipt_tr_receipt_header_drafts_bi_clinic_inherit.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_header_drafts_bi_clinic_inherit
-- @requires: table:receipt_header_drafts, table:farms
-- 備考: 原文の命名・ロジックをそのまま分離（BIで farm→clinic 継承）

DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_clinic_inherit;
DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bi_clinic_inherit
BEFORE INSERT ON receipt_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/2009_receipt_tr_receipt_header_drafts_bi_clinic_inherit.sql>>>

<<<FILE patches/2010_receipt_create_receipt_headers.sql>>>
/* 2010_receipt_create_receipt_headers.sql */
-- @phase: create
-- @feature: receipt
-- @provides: table:receipt_headers
-- @requires: function:uuid_v7_bin, table:farms

DROP TABLE IF EXISTS receipt_headers;
CREATE TABLE IF NOT EXISTS receipt_headers (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                        BINARY(16) NOT NULL UNIQUE,            -- v7 UUID（スナップの識別）
  receipt_header_drafts_uuid  BINARY(16) NULL,                       -- 参照元ドラフト（弱リンク）
  farm_uuid                   BINARY(16) NULL,                       -- 弱リンク（将来の参照用）
  clinic_uuid                 BINARY(16) NULL,                       -- 当時の所属院（不変）
  receipt_no                  VARCHAR(40) NULL,                      -- 任意の対外発番（UI採番）
  title                       VARCHAR(120) NULL,
  note                        VARCHAR(255) NULL,

  issued_at                   DATETIME NOT NULL,                     -- 発行日時（スナップ時刻）
  issued_by_user_id           INT UNSIGNED NULL,

  status                      ENUM('printed','voided') NULL DEFAULT NULL,  -- 未印刷(NULL)/印刷済/取消
  printed_at                  DATETIME NULL,
  printed_count               INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at                   DATETIME NULL,
  void_reason                 VARCHAR(255) NULL,
  voided_by_user_id           INT UNSIGNED NULL,

  /* クリニック設定スナップ（固定） */
  yen_per_point               DECIMAL(8,2) NOT NULL,
  copay_rate                  DECIMAL(5,4) NOT NULL,
  tax_rounding                ENUM('floor','round','ceil') NOT NULL,

  /* 集計スナップ（固定） */
  total_b_points              INT UNSIGNED NOT NULL,
  total_a_points              INT UNSIGNED NOT NULL,
  total_price_yen             INT UNSIGNED NOT NULL,
  subtotal_yen                INT UNSIGNED NOT NULL,
  tax_yen                     INT UNSIGNED NOT NULL,
  total_insurance_yen         INT UNSIGNED NOT NULL,
  total_private_yen           INT UNSIGNED NOT NULL,
  patient_copay_yen           INT UNSIGNED NOT NULL,
  insurer_pay_yen             INT UNSIGNED NOT NULL,

  /* 任意：印字/レイアウト用のクリニック情報 */
  clinic_snapshot_json        JSON NULL,

  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/2010_receipt_create_receipt_headers.sql>>>

<<<FILE patches/2015_receipt_idx_receipt_headers.sql>>>
/* 2015_receipt_idx_receipt_headers.sql */
-- @phase: idx
-- @feature: receipt
-- @provides: index:uq_receipt_headers_no, index:idx_rcpt_hdr_draft, index:idx_rcpt_hdr_issued, index:idx_rcpt_hdr_status, index:idx_rcpt_hdr_farm, index:idx_rcpt_hdr_clinic
-- @requires: table:receipt_headers

CREATE UNIQUE INDEX uq_receipt_headers_no ON receipt_headers (receipt_no);
CREATE INDEX idx_rcpt_hdr_draft  ON receipt_headers (receipt_header_drafts_uuid, issued_at);
CREATE INDEX idx_rcpt_hdr_issued ON receipt_headers (issued_at, id);
CREATE INDEX idx_rcpt_hdr_status ON receipt_headers (status, issued_at, id);
CREATE INDEX idx_rcpt_hdr_farm   ON receipt_headers (farm_uuid, issued_at, id);
CREATE INDEX idx_rcpt_hdr_clinic ON receipt_headers (clinic_uuid, issued_at, id);
<<<END patches/2015_receipt_idx_receipt_headers.sql>>>

<<<FILE patches/2016_receipt_tr_receipt_headers_bi_uuid_v7.sql>>>
/* 2016_receipt_tr_receipt_headers_bi_uuid_v7.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_headers_bi_uuid_v7
-- @requires: table:receipt_headers, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_receipt_headers_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_receipt_headers_bi_uuid_v7
BEFORE INSERT ON receipt_headers
FOR EACH ROW
BEGIN
  DECLARE v_hdr_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 発行時に farm → clinic を固定継承（アプリが直接セットしても可） */
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO v_hdr_clinic
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_hdr_clinic;
  END IF;
END $$
DELIMITER ;
<<<END patches/2016_receipt_tr_receipt_headers_bi_uuid_v7.sql>>>

<<<FILE patches/2017_receipt_tr_receipt_headers_bi_clinic_inherit.sql>>>
/* 2017_receipt_tr_receipt_headers_bi_clinic_inherit.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_headers_bi_clinic_inherit
-- @requires: table:receipt_headers, table:farms
-- 備考: 原文「tr_receipt_headers_bi_clinic_inherit」をそのまま分離

DROP TRIGGER IF EXISTS tr_receipt_headers_bi_clinic_inherit;
DELIMITER $$
CREATE TRIGGER tr_receipt_headers_bi_clinic_inherit
BEFORE INSERT ON receipt_headers
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/2017_receipt_tr_receipt_headers_bi_clinic_inherit.sql>>>

<<<FILE patches/2020_receipt_create_receipt_checkups.sql>>>
/* 2020_receipt_create_receipt_checkups.sql */
-- @phase: create
-- @feature: receipt
-- @provides: table:receipt_checkups
-- @requires: function:uuid_v7_bin, table:receipt_headers

DROP TABLE IF EXISTS receipt_checkups;
CREATE TABLE IF NOT EXISTS receipt_checkups (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7（items から参照）
  receipt_header_uuid BINARY(16) NOT NULL,                         -- ↔ receipt_headers.uuid（弱リンク）
  clinic_uuid         BINARY(16) NULL,                             -- 親ヘッダから固定継承
  source_checkup_uuid BINARY(16) NOT NULL,                         -- 由来：checkups.uuid
  checkup_at          DATETIME NULL,                               -- 任意：診療日時など
  individual_uuid     BINARY(16) NULL,                             -- 任意：印字補助
  individual_label    VARCHAR(120) NULL,                           -- 任意：個体表示名 等
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/2020_receipt_create_receipt_checkups.sql>>>

<<<FILE patches/2025_receipt_idx_receipt_checkups.sql>>>
/* 2025_receipt_idx_receipt_checkups.sql */
-- @phase: idx
-- @feature: receipt
-- @provides: index:uq_rcpt_hdr_src, index:idx_rcpt_ckp_hdr, index:idx_rcpt_ckp_src, index:idx_rcpt_ckp_clinic
-- @requires: table:receipt_checkups

CREATE UNIQUE INDEX uq_rcpt_hdr_src   ON receipt_checkups (receipt_header_uuid, source_checkup_uuid);
CREATE INDEX        idx_rcpt_ckp_hdr  ON receipt_checkups (receipt_header_uuid, id);
CREATE INDEX        idx_rcpt_ckp_src  ON receipt_checkups (source_checkup_uuid);
CREATE INDEX        idx_rcpt_ckp_clinic ON receipt_checkups (clinic_uuid, receipt_header_uuid, id);
<<<END patches/2025_receipt_idx_receipt_checkups.sql>>>

<<<FILE patches/2026_receipt_tr_receipt_checkups_bi_uuid_v7.sql>>>
/* 2026_receipt_tr_receipt_checkups_bi_uuid_v7.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_checkups_bi_uuid_v7
-- @requires: table:receipt_checkups, function:uuid_v7_bin

DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_receipt_checkups_bi_uuid_v7
BEFORE INSERT ON receipt_checkups
FOR EACH ROW
BEGIN
  DECLARE v_ckp_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番（items が参照するため必須） */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* ヘッダから clinic_uuid を固定継承 */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT h.clinic_uuid INTO v_ckp_clinic
      FROM receipt_headers h WHERE h.uuid = NEW.receipt_header_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_ckp_clinic;
  END IF;
END $$
DELIMITER ;
<<<END patches/2026_receipt_tr_receipt_checkups_bi_uuid_v7.sql>>>

<<<FILE patches/2027_receipt_tr_receipt_checkups_bi_clinic_inherit.sql>>>
/* 2027_receipt_tr_receipt_checkups_bi_clinic_inherit.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_checkups_bi_clinic_inherit
-- @requires: table:receipt_checkups, table:receipt_headers

DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_clinic_inherit;
DELIMITER $$
CREATE TRIGGER tr_receipt_checkups_bi_clinic_inherit
BEFORE INSERT ON receipt_checkups
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL THEN
    SELECT h.clinic_uuid INTO NEW.clinic_uuid
      FROM receipt_headers h WHERE h.uuid = NEW.receipt_header_uuid LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/2027_receipt_tr_receipt_checkups_bi_clinic_inherit.sql>>>

<<<FILE patches/2030_receipt_create_receipt_items.sql>>>
/* 2030_receipt_create_receipt_items.sql */
-- @phase: create
-- @feature: receipt
-- @provides: table:receipt_items
-- @requires: table:receipt_checkups

DROP TABLE IF EXISTS receipt_items;
CREATE TABLE IF NOT EXISTS receipt_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  receipt_checkup_uuid   BINARY(16) NOT NULL,                       -- ↔ receipt_checkups.uuid（弱リンク）
  clinic_uuid            BINARY(16) NULL,                           -- 親CKPから固定継承
  source_checkup_item_id INT UNSIGNED NOT NULL,                     -- 由来：checkup_items.id

  /* マスタ/入力の当時値スナップ（印字・再現に必要な範囲を保持） */
  description            VARCHAR(255) NOT NULL,                     -- 例: 処置/薬品名
  qty_unit               VARCHAR(32)  NULL,                         -- 例: mL, 回, 錠...
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  /* 点数/自由価格の両立 */
  pay_type               ENUM('insurance','private') NOT NULL DEFAULT 'insurance',
  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  /* 税と金額（行で算出→ヘッダで合算） */
  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,           -- 税抜
  tax_yen                INT UNSIGNED NOT NULL DEFAULT 0,
  total_yen              INT UNSIGNED NOT NULL DEFAULT 0,           -- 税込

  note                   VARCHAR(255) NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/2030_receipt_create_receipt_items.sql>>>

<<<FILE patches/2035_receipt_idx_receipt_items.sql>>>
/* 2035_receipt_idx_receipt_items.sql */
-- @phase: idx
-- @feature: receipt
-- @provides: index:uq_rcptitem_ckp_src, index:idx_rcpt_items_ckpuuid, index:idx_rcpt_items_source, index:idx_rcpt_items_clinic
-- @requires: table:receipt_items

CREATE UNIQUE INDEX uq_rcptitem_ckp_src   ON receipt_items (receipt_checkup_uuid, source_checkup_item_id);
CREATE INDEX        idx_rcpt_items_ckpuuid ON receipt_items (receipt_checkup_uuid, id);
CREATE INDEX        idx_rcpt_items_source  ON receipt_items (source_checkup_item_id);
CREATE INDEX        idx_rcpt_items_clinic  ON receipt_items (clinic_uuid, receipt_checkup_uuid, id);
<<<END patches/2035_receipt_idx_receipt_items.sql>>>

<<<FILE patches/2036_receipt_tr_receipt_items_bi_clinic_inherit.sql>>>
/* 2036_receipt_tr_receipt_items_bi_clinic_inherit.sql */
-- @phase: trigger
-- @feature: receipt
-- @provides: trigger:tr_receipt_items_bi_clinic_inherit
-- @requires: table:receipt_items, table:receipt_checkups

DROP TRIGGER IF EXISTS tr_receipt_items_bi_clinic_inherit;
DELIMITER $$
CREATE TRIGGER tr_receipt_items_bi_clinic_inherit
BEFORE INSERT ON receipt_items
FOR EACH ROW
BEGIN
  DECLARE v_item_clinic BINARY(16);

  /* 親CKPから clinic_uuid を固定継承 */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT c.clinic_uuid INTO v_item_clinic
      FROM receipt_checkups c WHERE c.uuid = NEW.receipt_checkup_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_item_clinic;
  END IF;
END $$
DELIMITER ;
<<<END patches/2036_receipt_tr_receipt_items_bi_clinic_inherit.sql>>>

<<<FILE patches/archive/002.indi_to_ckpit_p014.2.sql>>>
/* ===================================================================
   vetDB schema install (based on p014.1 / visits.draft / checkups_p012.2)
   [p014.2:2025-08-29] 反映した変更（要約）
     - individuals.user_uuid を「担当者記録」用途に降格（NULL可, ON DELETE SET NULL）
       + 担当者名テキスト responsible_user_name を追加
     - visits.farm_uuid → farms.uuid に FK を新設（ON UPDATE CASCADE / ON DELETE RESTRICT）
     - checkups.visit_uuid → visits.uuid を ON DELETE SET NULL（NULL許容）へ変更
     - individuals.farm_uuid → farms.uuid は CASCADE/RESTRICT のまま（維持）
     - checkups.individual_uuid → individuals.uuid は RESTRICT のまま（維持）
     - バリデーションはアプリ側アンカーロックで実施（DBトリガは追加しない）
     - 推奨インデックスの追加/明示（visit_uuid / individual_uuid / farm_uuid / list index）
   =================================================================== */

SET NAMES utf8mb4;

-- ================================================================
-- UUIDユーティリティ関数（p012系そのまま）
--   ※既存環境にある場合は DROP IF EXISTS で安全に再作成
-- ================================================================
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16))
RETURNS CHAR(32) DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36))
RETURNS BINARY(16) DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str()
RETURNS CHAR(36) NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  SET r12    = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail   = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);
  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin()
RETURNS BINARY(16) NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$
DELIMITER ;

-- ================================================================
-- 再デプロイ安全化（既存オブジェクトDROP）
--   ※「既存のものは変更せず含める」方針に沿い、各テーブル定義内の
--     トリガは元DDLの内容を踏襲して再定義します。
-- ================================================================
DROP VIEW  IF EXISTS checkups_hex_v;
DROP VIEW  IF EXISTS individuals_hex_v;

DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;
DROP TRIGGER IF EXISTS bi_visits_uuid;
DROP TRIGGER IF EXISTS bu_visits_rowver;
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;
DROP TRIGGER IF EXISTS tr_checkup_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkup_items_bu_rowver;

DROP TABLE IF EXISTS checkup_items;
DROP TABLE IF EXISTS checkups;
DROP TABLE IF EXISTS visits;
DROP TABLE IF EXISTS individuals;

-- ================================================================
-- individuals（p014.1 をベースに変更適用）
--   - user_uuid: 担当者記録用に降格（NULL可, ON DELETE SET NULL）
--   - responsible_user_name: 担当者名をテキスト保持（UI表示/監査用）
--   - 既存のUUID自動採番/row_versionトリガは「変更せず」含める
--   - FK: farm_uuid → farms.uuid は CASCADE/RESTRICT のまま
-- ================================================================
CREATE TABLE individuals (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,         -- サロゲートPK
  uuid                  BINARY(16) NOT NULL UNIQUE,                      -- UUIDv7(bin16)（アプリ/既存TRGで採番）
  farm_uuid             BINARY(16) NOT NULL,                             -- ↔ farms.uuid
  user_uuid             BINARY(16) NULL,                                 -- [p014.2][降格] 担当者UUID（NULL可）
  responsible_user_name VARCHAR(100) NULL,                               -- [p014.2][new] 担当者名（自由記述）

  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,                                   -- 全国一意10桁（NULL可）
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,

  sire_name             VARCHAR(100) NULL,                               -- 父はメモのみ（FKなし）

  genetic_dam_uuid      BINARY(16) NULL,                                 -- 自己参照（遺伝母）
  nursing_dam_uuid      BINARY(16) NULL,                                 -- 自己参照（哺育母）

  -- 母確定時スナップ（帳票/検索）
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,

  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,                                   -- ソフトデリート
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,              -- 楽観ロック（既存TRGで+1）

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),

  -- 推奨インデックス
  KEY idx_individuals_farm_name   (farm_uuid, name),
  KEY idx_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_individuals_list        (deleted_at, updated_at, id),

  -- 外部キー
  CONSTRAINT fk_individuals_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,                    -- （維持）

  CONSTRAINT fk_individuals_user_uuid                        -- [p014.2] 降格（null可/削除時null）
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  -- 自己参照FK（母リンク）
  CONSTRAINT fk_individuals_genetic_dam
    FOREIGN KEY (genetic_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_individuals_nursing_dam
    FOREIGN KEY (nursing_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  -- 自傷防止（母=自分は禁止）
  CONSTRAINT chk_individuals_no_self_genetic
    CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing
    CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- 既存の individuals トリガ（p014.1のまま）――変更せず再定義
DELIMITER $$
CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  -- uuid 未指定/全ゼロなら UUIDv7(bin16) を自動採番
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  -- row_version を自動加算（アプリの楽観ロックと整合）
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

-- 可読ビュー（HEX表示）
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)        AS uuid_hex,
  uuid_bin_to_hex(farm_uuid)   AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)   AS user_uuid_hex,
  responsible_user_name,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid)  AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid)  AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;

-- ================================================================
-- visits（visits.draft をベースに FKを追加）
--   - farm_uuid → farms.uuid に FK 新設（CASCADE/RESTRICT）
--   - 既存のUUID自動採番/row_versionトリガは「変更せず」含める
-- ================================================================
CREATE TABLE visits (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,          -- UUIDv7(bin16)
  farm_uuid        BINARY(16) NOT NULL,                 -- ↔ farms.uuid（本版でFK化）
  visit_started_at DATETIME NOT NULL,                   -- UTC保存（表示はアプリTZ）
  visit_ended_at   DATETIME NULL,
  location_text    VARCHAR(180) NULL,
  note             VARCHAR(255) NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at       DATETIME NULL,
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 推奨インデックス
  KEY idx_visits_farm             (farm_uuid),                   -- [p014.2][add] farm絞り
  KEY idx_visits_farm_started     (farm_uuid, visit_started_at),
  KEY idx_visits_started          (visit_started_at),
  KEY idx_visits_list             (deleted_at, updated_at, id),

  -- 新設FK：未登録farmへのvisitを物理的に防止
  CONSTRAINT fk_visits_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- 既存の visits トリガ（visits.draftのまま）――変更せず再定義
DELIMITER $$
CREATE TRIGGER bi_visits_uuid
BEFORE INSERT ON visits
FOR EACH ROW
BEGIN
  -- uuid 未指定/全ゼロは自動採番、開始時刻未指定はUTC現在
  IF NEW.uuid IS NULL OR NEW.uuid = 0x00000000000000000000000000000000 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
  IF NEW.visit_started_at IS NULL THEN
    SET NEW.visit_started_at = UTC_TIMESTAMP();
  END IF;
END$$

CREATE TRIGGER bu_visits_rowver
BEFORE UPDATE ON visits
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

-- ================================================================
-- checkups / checkup_items（checkups_p012.2 をベースに変更適用）
--   - checkups.visit_uuid: NULL許容 + ON DELETE SET NULL（visit削除で接続解除）
--   - checkups.individual_uuid: RESTRICT のまま
--   - 既存のUUID自動採番/row_versionトリガは「変更せず」含める
--   - chart_header_uuid は弱リンク（FKなし、索引のみ）＊元ポリシー踏襲
-- ================================================================
CREATE TABLE checkups (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL UNIQUE,        -- UUIDv7(bin16)

  visit_uuid        BINARY(16) NULL,                   -- [p014.2] NULL許容へ変更
  individual_uuid   BINARY(16) NOT NULL,               -- ↔ individuals.uuid (RESTRICT)
  chart_header_uuid BINARY(16) NULL,                   -- 弱リンク（FKなし）

  -- SOAP
  s_subjective      TEXT NULL,
  o_objective       TEXT NULL,
  a_assessment      TEXT NULL,
  p_plan            TEXT NULL,

  -- TPR
  temp_c            DECIMAL(4,1) NULL,
  pulse_bpm         SMALLINT UNSIGNED NULL,
  resp_bpm          SMALLINT UNSIGNED NULL,

  -- 現症・経過
  clinical_course   TEXT NULL,

  -- 請求/運用
  claim_exclusion       ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached  TINYINT(1) NOT NULL DEFAULT 0,
  status                ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by            INT UNSIGNED NULL,

  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at        DATETIME NULL,
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 推奨インデックス
  INDEX idx_checkups_visit           (visit_uuid),                      -- 割当/未割当の切替
  INDEX idx_checkups_individual      (individual_uuid),                 -- JOIN用
  INDEX idx_checkups_visit_ind_crt   (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_ind_uuid  (visit_uuid, individual_uuid, uuid),
  INDEX idx_checkups_chart_header    (chart_header_uuid),               -- 弱リンク用
  KEY   idx_checkups_list            (deleted_at, updated_at, id),      -- 安定一覧・差分

  -- 外部キー
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,  -- [p014.2] visit削除で接続解除
  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE RESTRICT ON DELETE RESTRICT
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE       = utf8mb4_unicode_ci
  ROW_FORMAT    = DYNAMIC;

CREATE TABLE checkup_items (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,     -- UUIDv7(bin16)
  checkup_uuid         BINARY(16) NOT NULL,            -- ↔ checkups.uuid
  treatment_uuid       BINARY(16) NULL,                -- 任意参照
  description          VARCHAR(255) NOT NULL,
  qty_unit             VARCHAR(32) NULL,
  quantity             DECIMAL(10,2) NOT NULL DEFAULT 1,
  pay_type             ENUM('insurance','private') NOT NULL,
  unit_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points      INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point        DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  unit_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen   INT UNSIGNED NOT NULL DEFAULT 0,
  tax_rate             DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen         INT UNSIGNED NOT NULL DEFAULT 0,

  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at           DATETIME NULL,
  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 推奨インデックス
  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),
  KEY   idx_checkup_items_list   (deleted_at, updated_at, id),

  CONSTRAINT fk_checkup_items_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE       = utf8mb4_unicode_ci
  ROW_FORMAT    = DYNAMIC;

-- 既存の checkups / checkup_items トリガ（p012.2のまま）――変更せず再定義
DELIMITER $$
CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

-- 可読ビュー（HEX表示）
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)            AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)      AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid) AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm,
  clinical_course,
  claim_exclusion, has_insurance_cached, status, created_by,
  deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/archive/002.indi_to_ckpit_p014.2.sql>>>

<<<FILE patches/archive/002.indi_to_ckpit_p014.3.sql>>>
/* ===================================================================
   vetDB schema install (based on p014.1 / visits.draft / checkups_p012.2)
   [p014.2:2025-08-29] + [p017: checkups に receipt_header_drafts_uuid 直付け統合]
   =================================================================== */

SET NAMES utf8mb4;

-- ================================================================
-- UUIDユーティリティ関数（p012系そのまま）
-- ※既存環境にある場合は DROP IF EXISTS で安全に再作成
-- ================================================================
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32)
DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16)
DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');
  SET r12 = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');
  SET t_hi = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16)
NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

-- ================================================================
-- 再デプロイ安全化（既存オブジェクトDROP）
-- ================================================================
DROP VIEW IF EXISTS checkups_hex_v;
DROP VIEW IF EXISTS individuals_hex_v;

DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;
DROP TRIGGER IF EXISTS bi_visits_uuid;
DROP TRIGGER IF EXISTS bu_visits_rowver;
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;
DROP TRIGGER IF EXISTS tr_checkup_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkup_items_bu_rowver;

DROP TABLE IF EXISTS checkup_items;
DROP TABLE IF EXISTS checkups;
DROP TABLE IF EXISTS visits;
DROP TABLE IF EXISTS individuals;

-- ================================================================
-- individuals（p014.2）
-- ================================================================
CREATE TABLE individuals (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, -- サロゲートPK
  uuid                  BINARY(16) NOT NULL UNIQUE,              -- UUIDv7(bin16)
  farm_uuid             BINARY(16) NOT NULL,                     -- ↔ farms.uuid
  user_uuid             BINARY(16) NULL,                         -- 担当者UUID（降格; NULL可）
  responsible_user_name VARCHAR(100) NULL,                       -- 担当者名（自由記述）

  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,                           -- 全国一意10桁（NULL可）
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,

  sire_name             VARCHAR(100) NULL,                       -- 父はメモのみ（FKなし）
  genetic_dam_uuid      BINARY(16) NULL,                         -- 自己参照（遺伝母）
  nursing_dam_uuid      BINARY(16) NULL,                         -- 自己参照（哺育母）

  -- 母確定時スナップ（帳票/検索）
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,

  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,                           -- ソフトデリート
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,      -- 楽観ロック

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),

  KEY idx_individuals_farm_name   (farm_uuid, name),
  KEY idx_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_individuals_list        (deleted_at, updated_at, id),

  CONSTRAINT fk_individuals_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_individuals_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_individuals_genetic_dam
    FOREIGN KEY (genetic_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_individuals_nursing_dam
    FOREIGN KEY (nursing_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT chk_individuals_no_self_genetic CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- individuals トリガ
DELIMITER $$
CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

-- 可読ビュー（HEX表示）
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)        AS uuid_hex,
  uuid_bin_to_hex(farm_uuid)   AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)   AS user_uuid_hex,
  responsible_user_name,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid) AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid) AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;

-- ================================================================
-- visits（p014.2）
-- ================================================================
CREATE TABLE visits (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,         -- UUIDv7(bin16)
  farm_uuid        BINARY(16) NOT NULL,                -- ↔ farms.uuid（本版でFK化）
  visit_started_at DATETIME NOT NULL,                  -- UTC保存（表示はアプリTZ）
  visit_ended_at   DATETIME NULL,
  location_text    VARCHAR(180) NULL,
  note             VARCHAR(255) NULL,

  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at       DATETIME NULL,
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_visits_farm         (farm_uuid),
  KEY idx_visits_farm_started (farm_uuid, visit_started_at),
  KEY idx_visits_started      (visit_started_at),
  KEY idx_visits_list         (deleted_at, updated_at, id),

  CONSTRAINT fk_visits_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- visits トリガ
DELIMITER $$
CREATE TRIGGER bi_visits_uuid
BEFORE INSERT ON visits
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = 0x00000000000000000000000000000000 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
  IF NEW.visit_started_at IS NULL THEN
    SET NEW.visit_started_at = UTC_TIMESTAMP();
  END IF;
END$$

CREATE TRIGGER bu_visits_rowver
BEFORE UPDATE ON visits
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

-- ================================================================
-- checkups / checkup_items（p014.2）＋［p017差分のみ反映：checkups に draft 直付け］
-- ================================================================
CREATE TABLE checkups (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL UNIQUE,        -- UUIDv7(bin16)

  visit_uuid        BINARY(16) NULL,                   -- NULL許容（visit削除でSET NULL）
  individual_uuid   BINARY(16) NOT NULL,               -- ↔ individuals.uuid (RESTRICT)

  -- [p017] 発行対象集合の起点となる draft 直付け
  receipt_header_drafts_uuid BINARY(16) NULL,          -- ↔ receipt_header_drafts.uuid

  chart_header_uuid BINARY(16) NULL,                   -- 弱リンク（FKなし）

  -- SOAP
  s_subjective      TEXT NULL,
  o_objective       TEXT NULL,
  a_assessment      TEXT NULL,
  p_plan            TEXT NULL,

  -- TPR
  temp_c            DECIMAL(4,1) NULL,
  pulse_bpm         SMALLINT UNSIGNED NULL,
  resp_bpm          SMALLINT UNSIGNED NULL,

  -- 現症・経過
  clinical_course   TEXT NULL,

  -- 請求/運用
  claim_exclusion      ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached TINYINT(1) NOT NULL DEFAULT 0,

  status            ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by        INT UNSIGNED NULL,

  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at        DATETIME NULL,
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 索引
  INDEX idx_checkups_visit          (visit_uuid),
  INDEX idx_checkups_individual     (individual_uuid),
  INDEX idx_checkups_visit_ind_crt  (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_ind_uuid (visit_uuid, individual_uuid, uuid),
  INDEX idx_checkups_chart_header   (chart_header_uuid),
  KEY   idx_checkups_list           (deleted_at, updated_at, id),

  -- [p017] draft直付け用索引
  KEY   idx_checkups_rhd            (receipt_header_drafts_uuid, id),

  -- 外部キー
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE RESTRICT ON DELETE RESTRICT,

  -- [p017] receipt draft 接続FK（draft削除で自動デタッチ）
  CONSTRAINT fk_checkups_rhd
    FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci
  ROW_FORMAT = DYNAMIC;

CREATE TABLE checkup_items (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,      -- UUIDv7(bin16)
  checkup_uuid        BINARY(16) NOT NULL,             -- ↔ checkups.uuid

  treatment_uuid      BINARY(16) NULL,                 -- 任意参照（マスタ未確定でも可）
  description         VARCHAR(255) NOT NULL,
  qty_unit            VARCHAR(32) NULL,
  quantity            DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type            ENUM('insurance','private') NOT NULL,

  -- 点数/価格の両立
  unit_b_points       INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points     INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point       DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  unit_price_yen      INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen  INT UNSIGNED NOT NULL DEFAULT 0,
  tax_rate            DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen        INT UNSIGNED NOT NULL DEFAULT 0,

  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 索引
  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),
  KEY   idx_checkup_items_list   (deleted_at, updated_at, id),

  CONSTRAINT fk_checkup_items_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci
  ROW_FORMAT = DYNAMIC;

-- checkups / checkup_items トリガ（p014.2のまま）
DELIMITER $$

CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;

-- 可読ビュー（HEX表示）※ビューは p014.2 のまま（rhd列は出力しません）
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)            AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)      AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid) AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm,
  clinical_course,
  claim_exclusion, has_insurance_cached,
  status, created_by,
  deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/archive/002.indi_to_ckpit_p014.3.sql>>>

<<<FILE patches/archive/002.indi_to_ckpit_p014.4.sql>>>
/* ===================================================================
   vetDB — p014.3 改版（非加入＝常に自費／UI優先・DB最小）
   -------------------------------------------------------------------
   目的:
     - 非加入牧場では checkup_items.pay_type を private 固定（UI）。
     - 加入牧場では insurance を優先表示（UI）。
     - DB は最小構成：UUID/row_version のみトリガ、保険ガードは行わない。
     - アプリ層（API）で insurance 選択時のみ非加入を1回JOIN検証。

   主な変更:
     - farms に non_insured を追加（牧場単位の既定ポリシー）。
     - checkups から claim_exclusion / has_insurance_cached を削除（廃止）。
     - checkup_items.pay_type は ENUM('insurance','private') のまま、DEFAULT 'private' を推奨。
     - ビュー checkups_insurance_context_v を新設（UIの初期値/制御用）。
     - p017 の receipt_header_drafts_uuid は維持（FKあり）。本DDLでは最小スタブを併設。

   ノート:
     - 文字コード/照合順序/ROW_FORMAT は p012+ 系の既定を踏襲。
     - UTC 保存・表示はアプリ側でタイムゾーン変換。
   =================================================================== */

SET NAMES utf8mb4;

/* ================================================================
   再デプロイ安全化（存在すれば削除）
   - farms/users は既存運用前提のため DROP しない
   ================================================================ */
DROP VIEW    IF EXISTS checkups_insurance_context_v;
DROP VIEW    IF EXISTS checkups_hex_v;
DROP VIEW    IF EXISTS individuals_hex_v;

DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;
DROP TRIGGER IF EXISTS bi_visits_uuid;
DROP TRIGGER IF EXISTS bu_visits_rowver;
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;
DROP TRIGGER IF EXISTS tr_checkup_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkup_items_bu_rowver;

DROP TABLE IF EXISTS checkup_items;
DROP TABLE IF EXISTS checkups;
DROP TABLE IF EXISTS visits;
DROP TABLE IF EXISTS individuals;

/* receipt_header_drafts は FK整合のためスタブ同梱（本番は p017 正式DDLに置換） */
DROP TABLE IF EXISTS receipt_header_drafts;

/* ================================================================
   UUIDユーティリティ関数（p012系）
   - BINARY(16) を基本とし、HEX表示/変換/UUIDv7生成を提供
   ================================================================ */
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32)
DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16)
DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
  /* 擬似 UUIDv7: ミリ秒エポック + 乱数（検証用）。
     実運用はDB/アプリ側で正式実装に置換可。 */
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms  = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  SET r12    = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail   = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16)
NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

/* ================================================================
   individuals（p014.3 構成踏襲）
   ------------------------------------------------
   - UUID: BINARY(16) / v7想定（自動採番トリガ）
   - farm_uuid: farms.uuid（ON UPDATE CASCADE / ON DELETE RESTRICT）
   - user_uuid: 担当者メモ用途（NULL許容/ON DELETE SET NULL）
   - 母参照: genetic/nursing を分離、自己参照禁止 CHECK
   - row_version: 楽観ロック（更新ごとに +1）
   - 一覧最適化索引: (deleted_at, updated_at, id)
   ================================================================ */
CREATE TABLE individuals (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,
  farm_uuid             BINARY(16) NOT NULL,      -- ↔ farms.uuid
  user_uuid             BINARY(16) NULL,          -- ↔ users.uuid（任意・担当メモ）

  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,            -- 全国一意10桁（NULL可）
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,

  sire_name             VARCHAR(100) NULL,        -- 父は名称メモのみ（FKなし）

  genetic_dam_uuid      BINARY(16) NULL,          -- 自己参照（遺伝母）
  nursing_dam_uuid      BINARY(16) NULL,          -- 自己参照（哺育母）
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,

  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),
  KEY idx_individuals_farm_name   (farm_uuid, name),
  KEY idx_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_individuals_list        (deleted_at, updated_at, id),

  CONSTRAINT fk_individuals_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_individuals_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_individuals_genetic_dam
    FOREIGN KEY (genetic_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_individuals_nursing_dam
    FOREIGN KEY (nursing_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT chk_individuals_no_self_genetic CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* 読みやすいHEXビュー（API/デバッグ用） */
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(farm_uuid)         AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)         AS user_uuid_hex,
  name, ear_tag, status, gender,
  birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid)  AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid)  AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;

/* ================================================================
   visits（p014.3 構成踏襲）
   ------------------------------------------------
   - farm_uuid: 訪問先（FK）。個体farmと一致チェックはアプリ層で実施。
   - visit_started_at: 未指定時は UTC 現在時刻（BIトリガ）。
   - row_version: 楽観ロック。
   ================================================================ */
CREATE TABLE visits (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,
  farm_uuid        BINARY(16) NOT NULL,               -- ↔ farms.uuid
  visit_started_at DATETIME NOT NULL,
  visit_ended_at   DATETIME NULL,
  location_text    VARCHAR(180) NULL,
  note             VARCHAR(255) NULL,

  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at       DATETIME NULL,
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_visits_farm         (farm_uuid),
  KEY idx_visits_farm_started (farm_uuid, visit_started_at),
  KEY idx_visits_started      (visit_started_at),
  KEY idx_visits_list         (deleted_at, updated_at, id),

  CONSTRAINT fk_visits_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_visits_uuid
BEFORE INSERT ON visits
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = 0x00000000000000000000000000000000 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
  IF NEW.visit_started_at IS NULL THEN
    SET NEW.visit_started_at = UTC_TIMESTAMP();
  END IF;
END$$

CREATE TRIGGER bu_visits_rowver
BEFORE UPDATE ON visits
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ================================================================
   checkups（p014.3 改版：2列廃止／rhdは維持）
   ------------------------------------------------
   - 廃止: claim_exclusion / has_insurance_cached（UI/APIで不要化）。
   - 維持: receipt_header_drafts_uuid（p017 直付け）。
   - visit_uuid: NULL許容（訪問削除時は SET NULL）。
   - individual_uuid: 必須（個体基準）。
   - chart_header_uuid: 将来のスナップ弱リンク（FKなし）。
   - SOAP/TPR/経過: 記録用。
   ================================================================ */
CREATE TABLE checkups (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid               BINARY(16) NOT NULL UNIQUE,
  visit_uuid         BINARY(16) NULL,                 -- ↔ visits.uuid（SET NULL）
  individual_uuid    BINARY(16) NOT NULL,             -- ↔ individuals.uuid（RESTRICT）

  /* p017: レシート草稿への直付け（草稿削除で自動デタッチ） */
  receipt_header_drafts_uuid BINARY(16) NULL,         -- ↔ receipt_header_drafts.uuid

  /* 将来の確定カルテ弱リンク（FKなし） */
  chart_header_uuid  BINARY(16) NULL,

  /* SOAP */
  s_subjective       TEXT NULL,
  o_objective        TEXT NULL,
  a_assessment       TEXT NULL,
  p_plan             TEXT NULL,

  /* TPR */
  temp_c             DECIMAL(4,1) NULL,
  pulse_bpm          SMALLINT UNSIGNED NULL,
  resp_bpm           SMALLINT UNSIGNED NULL,

  /* 現症・経過 */
  clinical_course    TEXT NULL,

  /* 運用 */
  status             ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by         INT UNSIGNED NULL,

  row_version        BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at         DATETIME NULL,
  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 索引 */
  INDEX idx_checkups_visit              (visit_uuid),
  INDEX idx_checkups_individual         (individual_uuid),
  INDEX idx_checkups_visit_ind_crt      (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_ind_uuid     (visit_uuid, individual_uuid, uuid),
  INDEX idx_checkups_chart_header       (chart_header_uuid),
  KEY   idx_checkups_list               (deleted_at, updated_at, id),
  KEY   idx_checkups_rhd                (receipt_header_drafts_uuid, id),

  /* 外部キー */
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE RESTRICT ON DELETE RESTRICT,

  CONSTRAINT fk_checkups_rhd
    FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ================================================================
   checkup_items（p014.3 構成踏襲 / DEFAULT 'private' 推奨）
   ------------------------------------------------
   - pay_type: 'insurance' / 'private'（加入→混合可、非加入→UI固定で private）
   - 非加入ガードはトリガ不採用（アプリ層で insurance 選択時のみ検証）。
   - 点数/価格の両立。row_version による楽観ロック。
   ================================================================ */
CREATE TABLE checkup_items (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,
  checkup_uuid        BINARY(16) NOT NULL,             -- ↔ checkups.uuid
  treatment_uuid      BINARY(16) NULL,                 -- 任意参照（マスタ未確定でも可）

  description         VARCHAR(255) NOT NULL,
  qty_unit            VARCHAR(32) NULL,
  quantity            DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type            ENUM('insurance','private') NOT NULL DEFAULT 'private',

  /* 点数/価格の両立 */
  unit_b_points       INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points     INT UNSIGNED NOT NULL DEFAULT 0,

  yen_per_point       DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  unit_price_yen      INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen  INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate            DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen        INT UNSIGNED NOT NULL DEFAULT 0,

  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),
  KEY   idx_checkup_items_list   (deleted_at, updated_at, id),

  CONSTRAINT fk_checkup_items_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ================================================================
   ビュー: UI/API 補助
   ------------------------------------------------
   1) checkups_hex_v:
      - BINARY(16) を HEX で可読化。
      - 廃止列（claim_exclusion / has_insurance_cached）は出力しない。
      - receipt_header_drafts_uuid は方針どおり非出力（内部用途）。

   2) checkups_insurance_context_v:
      - checkup → individual → farm をJOINし、牧場の加入/非加入を返す。
      - UIの既定値に使う preferred_pay_type を同時に返す。
        * 非加入  : 'private'
        * 加入    : 'insurance'
      - API では “insurance が選択された時だけ” これを参照して検証する。
   ================================================================ */
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)        AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid)   AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm,
  clinical_course,
  status, created_by,
  deleted_at, created_at, updated_at
FROM checkups;

CREATE OR REPLACE VIEW checkups_insurance_context_v AS
SELECT
  c.uuid AS checkup_uuid,
  f.non_insured AS farm_non_insured,
  CASE WHEN f.non_insured = 1 THEN 'private' ELSE 'insurance' END AS preferred_pay_type
FROM checkups c
JOIN individuals i ON i.uuid = c.individual_uuid
JOIN farms f       ON f.uuid = i.farm_uuid;
<<<END patches/archive/002.indi_to_ckpit_p014.4.sql>>>

<<<FILE patches/archive/002.individuals_p014.1.sql>>>
/* ============================================================
  ユーティリティ関数群
  - UUIDバイナリ/文字列の相互変換
  - UUID v7（時系列ソート性あり）の生成
  - 見本: checkups_p012.2.sql 準拠
  [p014r2:2025-08-28] 原文維持（整合のみ）。参照: checkups_p012.2.sql
============================================================ */
DELIMITER $$

/* BIN(16) → HEX文字列32桁へ変換 */
DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16))
RETURNS CHAR(32) DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

/* UUID文字列（36桁/32桁/ダッシュ混在可）→ BIN(16) に変換 */
DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36))
RETURNS BINARY(16) DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

/* UUID v7 を文字列として生成（ソートフレンドリ、ランダムビット含む） */
DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str()
RETURNS CHAR(36) NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  -- 現在時刻をミリ秒単位に変換
  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  -- HEX化（12桁、先頭ゼロ埋め）
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  -- ランダムビット生成
  SET r12    = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0')); -- UUIDバージョン=7
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail   = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  -- UUID各部位を組み立て
  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);
  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

/* UUID v7 を BINARY(16) として生成 */
DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin()
RETURNS BINARY(16) NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$
DELIMITER ;

/* ============================================================
  再デプロイ安全化 - テーブル/トリガ/ビューを事前DROP
  [p014r2] 原文維持
============================================================ */
DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;        -- [p014r2][new] row_version用（後述）
DROP VIEW    IF EXISTS individuals_hex_v;
DROP TABLE   IF EXISTS individuals;

/* ============================================================
  individuals テーブル
  目的:
  - 農場に属する個体（牛など）の基本情報を管理
  - uuid: BIN(16) をSoTキーとする（UUID v7）
  - 母子関係（遺伝母/哺育母）を分離管理
  - 父情報はメモのみ
  - ソフトデリート対応
  [p014r2:2025-08-28] 変更概要:
    1) row_version 追加（visits.draft / checkups_p012.2 に整合）
    2) list用複合索引 (deleted_at, updated_at, id) 追加（v1p9方針に整合）
    3) BEFORE UPDATE で row_version を自動+1（運用統一）
    4) 既存仕様（BIN16, ENUM gender, 耳標Unique, 自己参照CHECK 等）は維持
============================================================ */
CREATE TABLE individuals (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,        -- サロゲートPK（内部用）

  uuid                BINARY(16) NOT NULL UNIQUE,                     -- グローバル一意ID（UUID v7, BIN16）
  farm_uuid           BINARY(16) NOT NULL,                            -- 所属農場（farms.uuid, BIN16）
  user_uuid           BINARY(16) NOT NULL,                            -- 登録/所有ユーザ（users.uuid, BIN16）

  name                VARCHAR(100) NULL,                              -- 個体名（任意）
  ear_tag             CHAR(10) NULL,                                  -- 耳標（全国一意10桁、未付与時NULL）
  status              ENUM('active','sold','dead','culled')           -- 個体状態
                        NOT NULL DEFAULT 'active',                     -- culled=廃用淘汰
  gender              ENUM('female','male','cast','unknown')          -- 性別
                        NOT NULL DEFAULT 'unknown',                    -- genders参照廃止→ENUM化
  birth_date          DATE NULL,                                       -- 生年月日
  death_date          DATE NULL,                                       -- 死亡日（任意記録）

  sire_name           VARCHAR(100) NULL,                              -- 父牛名（メモのみ、FKなし）

  genetic_dam_uuid    BINARY(16) NULL,                                -- 遺伝母 UUID（自己参照FK）
  nursing_dam_uuid    BINARY(16) NULL,                                -- 哺育母 UUID（自己参照FK）

  -- 母牛確定時のスナップ（帳票/検索用に保持）
  genetic_dam_ear_tag CHAR(10) NULL,
  genetic_dam_name    VARCHAR(100) NULL,
  nursing_dam_ear_tag CHAR(10) NULL,
  nursing_dam_name    VARCHAR(100) NULL,

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at          DATETIME NULL,                                   -- ソフトデリート（NULL=有効）

  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,              -- [p014r2][new] 楽観ロック（visits/checkupsに整合）

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),                         -- 耳標は全国一意、NULLは重複可

  -- インデックス設計（検索/一覧用）
  KEY idx_individuals_farm_name   (farm_uuid, name),
  KEY idx_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),

  KEY idx_individuals_list (deleted_at, updated_at, id),               -- [p014r2][new] 一覧安定・差分同期（v1p9整合）

  -- 外部キー（farm/userは削除不可、参照整合性を保持）
  CONSTRAINT fk_individuals_farm_uuid
    FOREIGN KEY (farm_uuid)   REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_individuals_user_uuid
    FOREIGN KEY (user_uuid)   REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  -- 自己参照FK（母リンク）
  -- 母個体が削除された場合は子の dam_uuid を NULL化（当時の耳標/名前メモは保持）
  CONSTRAINT fk_individuals_genetic_dam
    FOREIGN KEY (genetic_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_individuals_nursing_dam
    FOREIGN KEY (nursing_dam_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,

  -- 自傷防止（母=自分は禁止）
  CONSTRAINT chk_individuals_no_self_genetic
    CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing
    CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
)
ENGINE=InnoDB
DEFAULT CHARSET = utf8mb4
COLLATE       = utf8mb4_unicode_ci
ROW_FORMAT    = DYNAMIC;

/* ============================================================
  トリガ
  - INSERT時に uuid が NULL またはゼロUUIDなら uuid_v7_bin() を自動採番
  - [p014r2][new] UPDATE時に row_version を +1（visits/checkups と運用統一）
============================================================ */
DELIMITER $$

CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

CREATE TRIGGER tr_individuals_bu_rowver     -- [p014r2][new]
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ============================================================
  HEX表現ビュー
  - UUID(BIN16)を文字列HEX化して確認・デバッグ用
  [p014r2] 原文維持（列構成は従前のまま）
============================================================ */
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(farm_uuid)         AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)         AS user_uuid_hex,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid)  AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid)  AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;
<<<END patches/archive/002.individuals_p014.1.sql>>>

<<<FILE patches/archive/008.dis_mas_p015.1.sql>>>
/* =========================================================
   #8 disease_master
   目的: 疾病コード(6桁)と名称(大/中/小)のマスタ
   規模: 100〜200行想定、参照頻度が高く更新稀
   方針:
     - 参照キーは code6（6桁, 一意）と id（INT PK）
     - uuid は BINARY(16)（v7想定）で付番（トリガで自動）
     - 名称3列は 10文字程度想定 → VARCHAR(32)で統一
     - display_* は生成列（MariaDBでは PERSISTENT を使用）
     - 一覧最適化用の複合索引 (deleted_at, updated_at, id) を付与
     - utf8mb4 + ROW_FORMAT=DYNAMIC を明示
   MariaDB 10.5 留意:
     - 生成列の保存型は STORED ではなく PERSISTENT を使用
     - CHECK は 10.2+ で有効
   ========================================================= */

DROP TABLE IF EXISTS disease_master;
CREATE TABLE IF NOT EXISTS disease_master (
  -- 主キー（自動採番）。参照は基本これか code6 を用いる
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  -- グローバル識別子（クライアント/連携用）。BINARY(16)で省容量
  uuid BINARY(16) NOT NULL UNIQUE,

  -- 正規疾病コード（6桁, 先頭ゼロ保持）。外部文書・カルテでの照合に使用
  code6 CHAR(6) NOT NULL,

  /* -------- 生成列（検索補助） --------
     major/middle/minor は code6 のサブパートを切り出して保持。
     VIRTUAL: 計算コスト最小／実ストレージ非消費。
  */
  major_code  CHAR(2) GENERATED ALWAYS AS (SUBSTR(code6,1,2)) VIRTUAL,
  middle_code CHAR(2) GENERATED ALWAYS AS (SUBSTR(code6,3,2)) VIRTUAL,
  minor_code  CHAR(2) GENERATED ALWAYS AS (SUBSTR(code6,5,2)) VIRTUAL,

  /* 表示用のフォーマット済コード。
     MariaDB 10.5: 保存型は PERSISTENT を使用（※STORED ではない）
     → 並び替え/検索に利用する場面で I/O を抑制できる
  */
  display_code CHAR(8) GENERATED ALWAYS AS (
    CONCAT(SUBSTR(code6,1,2),'-',SUBSTR(code6,3,2),'-',SUBSTR(code6,5,2))
  ) PERSISTENT,  -- CHANGED: STORED → PERSISTENT（MariaDB 10.5）

  /* -------- 名称（実体） --------
     10文字前後想定だが余裕を見て32。UTF-8でも1Bヘッダの範囲に収まる
  */
  major_name   VARCHAR(32)  NOT NULL,  -- 大分類名（章レベル）
  middle_name  VARCHAR(32)  NOT NULL,  -- 中分類名（検索で最も使う）
  minor_name   VARCHAR(32)  NOT NULL,  -- 小分類名（症状名など）

  /* 例: 「中分類名（小分類名）」。
     最大長 32 + 1 + 32 + 1 = 66 → VARCHAR(66)
     PERSISTENT: 一覧表示での描画コストを削減
  */
  display_name VARCHAR(66) GENERATED ALWAYS AS
    (CONCAT(middle_name, '（', minor_name, '）')) PERSISTENT,  -- CHANGED: STORED → PERSISTENT

  -- 法令・届出関連の備考（任意）
  legal_note TEXT NULL,

  -- 運用フラグ
  is_active     TINYINT(1) NOT NULL DEFAULT 1,  -- 0で非表示（論理的に廃止）
  is_reportable TINYINT(1) NOT NULL DEFAULT 0,  -- 届出対象か

  -- 監査系（ソフトデリート + 楽観ロック）
  created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at  DATETIME NULL,
  row_version BIGINT UNSIGNED NOT NULL DEFAULT 1,

  /* 制約・索引
     - code6 は一意（重複登録防止）
     - CHECK で6桁数字を厳格化（アプリ側と二重防御）
     - major/middle はコード検索用の補助索引
     - 名称は is_active を先頭にした前方一致系の複合プレフィックス索引
     - 一覧最適化（削除フラグ/更新時刻/PK）の複合索引
  */
  UNIQUE KEY uq_disease_code6 (code6),
  CHECK (code6 REGEXP '^[0-9]{6}$'),
  INDEX idx_disease_major (major_code),
  INDEX idx_disease_mm    (major_code, middle_code),
  INDEX idx_disease_name  (is_active, middle_name(32), minor_name(32)),
  INDEX idx_quality       (deleted_at, updated_at, id)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- UUIDの自動採番（v7想定）。未実装環境では UNHEX(REPLACE(UUID(),'-','')) で代替可
DROP TRIGGER IF EXISTS bi_disease_master_uuid;
CREATE TRIGGER bi_disease_master_uuid
BEFORE INSERT ON disease_master
FOR EACH ROW
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());


/* =========================================================
   disease_rinkoku_rules
   目的: 病名ごとの凛告（申告理由）候補を提示する最小ルール集
   規模: 病名×数語。UIでの選択肢提示を高速化
   方針:
     - disease_id で disease_master に従属
     - rinkoku_text は短文（最大128）
     - is_active と display_order で表示制御
     - 取得用複合索引 (disease_id, is_active, display_order, id)
   ========================================================= */

DROP TABLE IF EXISTS disease_rinkoku_rules;
CREATE TABLE IF NOT EXISTS disease_rinkoku_rules (
  id   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid BINARY(16) NOT NULL UNIQUE,

  -- 対象の病名。disease_master(id) に従属
  disease_id INT UNSIGNED NOT NULL,

  -- 凛告候補（UIに出す短い語句）。日本語想定で余裕を見て128
  rinkoku_text   VARCHAR(128) NOT NULL,

  -- 表示順。小さいほど上位に表示
  display_order  SMALLINT UNSIGNED NOT NULL DEFAULT 100,

  -- 運用フラグ/監査
  is_active  TINYINT(1) NOT NULL DEFAULT 1,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 代表的な取得クエリを満たす複合索引
  INDEX idx_drr_fetch (disease_id, is_active, display_order, id),

  -- 親マスタのコード編集に追随（更新CASCADE）/削除制限（RESTRICT）
  CONSTRAINT fk_drr_disease
    FOREIGN KEY (disease_id) REFERENCES disease_master(id)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- UUIDの自動採番（v7想定）
DROP TRIGGER IF EXISTS bi_drr_uuid;
CREATE TRIGGER bi_drr_uuid
BEFORE INSERT ON disease_rinkoku_rules
FOR EACH ROW
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
<<<END patches/archive/008.dis_mas_p015.1.sql>>>

<<<FILE patches/archive/008.dis_mas_p015.sql>>>
DROP TABLE IF EXISTS disease_master;
CREATE TABLE IF NOT EXISTS disease_master (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              CHAR(36) NOT NULL UNIQUE,

  -- 正規コード（6桁・先頭ゼロ保持）
  code6             CHAR(6)  NOT NULL,  -- 例: '045501'

  -- 派生列（検索性向上）
  major_code        CHAR(2)  GENERATED ALWAYS AS (SUBSTR(code6,1,2)) VIRTUAL,
  middle_code       CHAR(2)  GENERATED ALWAYS AS (SUBSTR(code6,3,2)) VIRTUAL,
  minor_code        CHAR(2)  GENERATED ALWAYS AS (SUBSTR(code6,5,2)) VIRTUAL,
  display_code      CHAR(8)  GENERATED ALWAYS AS
                     (CONCAT(SUBSTR(code6,1,2),'-',SUBSTR(code6,3,2),'-',SUBSTR(code6,5,2))) STORED,

  -- 名称
  major_name        VARCHAR(100) NOT NULL,
  middle_name       VARCHAR(255) NOT NULL,
  minor_name        VARCHAR(255) NOT NULL,
  display_name      VARCHAR(300) GENERATED ALWAYS AS
                     (CONCAT(middle_name, '（', minor_name, '）')) STORED,

  legal_note        TEXT NULL,
  is_active         TINYINT(1) NOT NULL DEFAULT 1,
  is_reportable     TINYINT(1) NOT NULL DEFAULT 0,

  -- 監査
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at        DATETIME NULL,
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,

  -- 制約・索引
  UNIQUE KEY uq_disease_code6 (code6),
  CHECK (code6 REGEXP '^[0-9]{6}$'),
  INDEX idx_disease_major (major_code),
  INDEX idx_disease_mm    (major_code, middle_code),
  INDEX idx_disease_name  (is_active, middle_name, minor_name),
  INDEX idx_quality       (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

DROP TABLE IF EXISTS disease_rinkoku_rules;
CREATE TABLE IF NOT EXISTS disease_rinkoku_rules (
  id            INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid          CHAR(36)     NOT NULL UNIQUE,

  -- 対象の病名（#8）
  disease_id    INT UNSIGNED NOT NULL,               -- ↔ disease_master(id)

  -- 凛告候補（申告理由の短文）
  rinkoku_text  VARCHAR(128) NOT NULL,               -- 例: '無発情', '下痢', '元気なし'

  -- 表示順（小さいほど上）
  display_order SMALLINT UNSIGNED NOT NULL DEFAULT 100,

  -- 運用最小限
  is_active     TINYINT(1)   NOT NULL DEFAULT 1,
  created_at    DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at    DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 索引・制約
  INDEX idx_drr_fetch (disease_id, is_active, display_order, id),
  CONSTRAINT fk_drr_disease
    FOREIGN KEY (disease_id) REFERENCES disease_master(id)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

<<<END patches/archive/008.dis_mas_p015.sql>>>

<<<FILE patches/archive/008.dis_to_chtit_p015.2.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   vetDB p015.1 — chart+disease 統合 DDL（新規インストール用）
   ---------------------------------------------------------
   本ファイルは p013 からの差分をブロック/行コメントで明示します。
   スキーマCOMMENTは使用しません（説明はコメントのみ）。
   ========================================================= */

/* =========================================================
   全体方針（p013 との差分）
   - DIFF:p013 -> disease_master を 6桁 code6/名称3分割/生成列 に刷新
   - DIFF:p013 -> chief complaint サジェスト用の rules テーブルを新設
   - DIFF:p013 -> ヘッダ編集は chart_header_drafts（強整合＋可変）に集約
   - DIFF:p013 -> 確定は chart_headers（不変スナップ）。status は printed/voided のみ
   - DIFF:p013 -> headers から individual/farm/insurance の FK を撤去（弱リンク化）
   - 共通: UUID は BINARY(16) v7想定、utf8mb4/utf8mb4_unicode_ci
   ========================================================= */

/* 再デプロイ安全化：トリガ→子→親の順にDROP */
DROP TRIGGER IF EXISTS tr_chart_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_headers_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bu_rowver;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_disease_master_bi_uuid_v7;

DROP TABLE IF EXISTS chart_items;
DROP TABLE IF EXISTS chart_checkups;
DROP TABLE IF EXISTS chart_headers;
DROP TABLE IF EXISTS chart_header_drafts;
DROP TABLE IF EXISTS disease_chief_complaint_rules;
DROP TABLE IF EXISTS disease_master;

/* =========================================================
   1) disease_master — 疾病マスタ
   ---------------------------------------------------------
   DIFF:p013
     - code VARCHAR(32) / name 単一 → code6 CHAR(6) 固定 + 名称 3分割
     - display_code / display_name を Generated(PERSISTENT)で追加
     - 6桁数字の CHECK を追加
   ========================================================= */
CREATE TABLE IF NOT EXISTS disease_master (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,            -- 数値主キー
  uuid              BINARY(16) NOT NULL UNIQUE,                         -- v7 UUID

  code6             CHAR(6) NOT NULL UNIQUE,                            -- 6桁コード（0埋め必須）
  major_name        VARCHAR(32) NOT NULL,                               -- 大分類名
  middle_name       VARCHAR(32) NOT NULL,                               -- 中分類名
  minor_name        VARCHAR(32) NOT NULL,                               -- 小分類名

  major_code        CHAR(2) AS (SUBSTRING(code6, 1, 2)) VIRTUAL,        -- 先頭2桁
  middle_code       CHAR(2) AS (SUBSTRING(code6, 3, 2)) VIRTUAL,        -- 中間2桁
  minor_code        CHAR(2) AS (SUBSTRING(code6, 5, 2)) VIRTUAL,        -- 末尾2桁

  display_code      VARCHAR(8)
    AS (CONCAT_WS('-', major_code, middle_code, minor_code)) PERSISTENT, -- 表示コード XX-YY-ZZ
  display_name      VARCHAR(255)
    AS (CONCAT_WS(' / ', major_name, middle_name, minor_name)) PERSISTENT, -- 表示名称 major / middle / minor

  is_active         TINYINT(1) NOT NULL DEFAULT 1,                     -- 有効フラグ
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,                -- 将来の差分同期/並行制御
  deleted_at        DATETIME NULL,                                     -- 論理削除（マスタのみ許容）
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  CHECK (code6 REGEXP '^[0-9]{6}$'),

  INDEX idx_dm_name (major_name, middle_name, minor_name),
  INDEX idx_dm_list (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_disease_master_bi_uuid_v7
BEFORE INSERT ON disease_master
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   2) disease_chief_complaint_rules — 主訴（凛告）サジェスト
   ---------------------------------------------------------
   DIFF:p013
     - 新設。旧 rinkoku_rules の命名統一版（chief_complaint）
     - UIサジェスト用、選択結果はヘッダ側の chief_complaint に保存
   ========================================================= */
CREATE TABLE IF NOT EXISTS disease_chief_complaint_rules (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  disease_id             INT UNSIGNED NOT NULL,                   -- ↔ disease_master.id
  chief_complaint_text   VARCHAR(128) NOT NULL,                   -- サジェスト表示文言
  display_order          SMALLINT UNSIGNED NOT NULL DEFAULT 0,    -- 昇順で上位表示
  is_active              TINYINT(1) NOT NULL DEFAULT 1,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  CONSTRAINT fk_dccr_disease
    FOREIGN KEY (disease_id) REFERENCES disease_master(id)
    ON UPDATE CASCADE ON DELETE CASCADE,

  INDEX idx_dccr_fetch (disease_id, is_active, display_order, id),
  INDEX idx_dccr_text  (chief_complaint_text)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/* =========================================================
   3) chart_header_drafts — 編集中ヘッダ（強整合＋可変）
   ---------------------------------------------------------
   DIFF:p013
     - 新設。日常業務の作成・編集の器
     - individuals/farms/insurance_enrollments へ FK を付与（強整合）
     - 疾病コードは disease_master(code6) 参照（SET NULL）
     - row_version/ deleted_at を持つ（可変のため）
     - status は 'open','closed','issued'
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_header_drafts (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                 -- v7 UUID（TRIGGER付与）

  /* 強整合FK（削除はRESTRICT、保険は任意でSET NULL） */
  individual_uuid           BINARY(16) NOT NULL,                        -- ↔ individuals.uuid
  farm_uuid                 BINARY(16) NOT NULL,                        -- ↔ farms.uuid
  insurance_enrollment_id   INT UNSIGNED NULL,                          -- ↔ insurance_enrollments.id

  fiscal_year               YEAR NULL,                                  -- 編集中はNULL許容
  claim_month               TINYINT UNSIGNED NULL,                      -- 1..12
  CHECK (claim_month IS NULL OR claim_month BETWEEN 1 AND 12),

  outcome_code              TINYINT UNSIGNED NULL,                      -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  draft_status              ENUM('open','closed','issued') NOT NULL DEFAULT 'open',  -- open治療中/closed転帰済/issuedスナップ発行済
  status_note               VARCHAR(255) NULL,

  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  issued_at                 DATETIME NULL,

  /* 任意のスナップ（プレビュー用途） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  updated_by                INT UNSIGNED NULL,
  row_version               BIGINT UNSIGNED NOT NULL DEFAULT 1,          -- 楽観ロック
  deleted_at                DATETIME NULL,                                -- ソフトデリート
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 強整合FK */
  CONSTRAINT fk_chd_individual
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_chd_farm
    FOREIGN KEY (farm_uuid)      REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_chd_insenroll
    FOREIGN KEY (insurance_enrollment_id) REFERENCES insurance_enrollments(id)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_chd_dis1 FOREIGN KEY (disease1_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_chd_dis2 FOREIGN KEY (disease2_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_chd_dis3 FOREIGN KEY (disease3_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,

  /* 一覧/検索最適化 */
  INDEX idx_hdr_drafts_open   (individual_uuid, draft_status, created_at),
  INDEX idx_hdr_drafts_period (fiscal_year, claim_month),
  INDEX idx_hdr_drafts_dis1   (disease1_code),
  INDEX idx_hdr_drafts_dis2   (disease2_code),
  INDEX idx_hdr_drafts_dis3   (disease3_code),
  INDEX idx_hdr_drafts_farm   (farm_uuid),
  INDEX idx_hdr_drafts_list   (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bi_uuid_v7
BEFORE INSERT ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bu_rowver
BEFORE UPDATE ON chart_header_drafts
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;

/* =========================================================
   4) chart_headers — 確定スナップ（不変）
   ---------------------------------------------------------
   DIFF:p013
     - draft 状態は保持しない（保存時点で outcome 済み＝closed 相当）
     - status は 'printed','voided' のみ（未印刷は NULL）
     - individual/farm/insurance の FK を撤去（弱リンク化）
     - disease*_code は CHAR(6) + disease_master(code6) に参照付与（最小限）
     - deleted_at を撤去（不変スナップは voided で扱う）
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_headers (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                -- v7 UUID

  /* 追跡弱リンク（確定後は変更しないためFKなしでも可） */
  individual_uuid           BINARY(16) NOT NULL,
  farm_uuid                 BINARY(16) NOT NULL,
  insurance_enrollment_id   INT UNSIGNED NULL,

  /* 保険期間識別 */
  fiscal_year               YEAR NOT NULL,
  claim_month               TINYINT UNSIGNED NOT NULL,                 -- 1..12
  CHECK (claim_month BETWEEN 1 AND 12),

  /* 転帰・期間（確定値） */
  outcome_code              TINYINT UNSIGNED NOT NULL,                 -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  /* 主訴・診断（スナップ） */
  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  /* 疾病スナップ（6桁コード＋表示名） */
  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  /* 金額・点数合計（スナップ） */
  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  /* ステータス：printed / voided（未印刷はNULL） */
  status                    ENUM('printed','voided') NULL DEFAULT NULL,
  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at                 DATETIME NULL,
  void_reason               VARCHAR(255) NULL,

  /* スナップ時の表示/保険情報（任意） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 疾病コードのみ最小限の参照整合性は不要のため削除 */

  /* インデックス（p013 の意図を踏襲） */
  INDEX idx_chart_headers_period      (fiscal_year, claim_month),
  INDEX idx_chart_headers_status      (status),
  INDEX idx_chart_headers_individual  (individual_uuid),
  INDEX idx_chart_headers_farm        (farm_uuid),
  INDEX idx_chart_headers_outcome     (outcome_code),
  INDEX idx_chart_headers_dis1        (disease1_code),
  INDEX idx_chart_headers_dis2        (disease2_code),
  INDEX idx_chart_headers_dis3        (disease3_code),
  INDEX idx_ch_list                   (updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_headers_bi_uuid_v7
BEFORE INSERT ON chart_headers
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   5) chart_checkups — 確定スナップ配下（SOAP/TPR）
   ---------------------------------------------------------
   DIFF:p013
     - 構成は踏襲。親は chart_headers.uuid（CASCADE）
     - UUID 自動採番トリガを明示
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   BINARY(16) NOT NULL UNIQUE,             -- 行UUID
  chart_uuid             BINARY(16) NOT NULL,                    -- ↔ chart_headers.uuid
  seq_no                 INT UNSIGNED NOT NULL,                  -- ヘッダ内の並び

  source_checkup_uuid    BINARY(16) NOT NULL,                    -- 由来 checkups.uuid（監査）
  source_visit_uuid      BINARY(16) NULL,                        -- 由来 visits.uuid（任意）

  checkup_at             DATETIME NULL,                          -- 受診日時

  subjective_text        TEXT NULL,
  objective_text         TEXT NULL,
  assessment_text        TEXT NULL,
  plan_text              TEXT NULL,
  clinical_course_text   TEXT NULL,

  tpr_temp_c             DECIMAL(4,1) NULL,
  tpr_pulse_bpm          SMALLINT UNSIGNED NULL,
  tpr_resp_bpm           SMALLINT UNSIGNED NULL,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_chart_checkups_hdr_seq (chart_uuid, seq_no),
  INDEX idx_chart_checkups_hdr (chart_uuid),

  CONSTRAINT fk_chart_checkups_header
    FOREIGN KEY (chart_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_checkups_bi_uuid_v7
BEFORE INSERT ON chart_checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   6) chart_items — 確定スナップ明細（点数×価格 両立）
   ---------------------------------------------------------
   DIFF:p013
     - chart_items.uuid の採用と自動採番トリガ（p013系の拡張方針を踏襲）
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_items (
  id                       INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                     BINARY(16) NOT NULL UNIQUE,           -- 明細UUID
  chart_checkup_uuid       BINARY(16) NOT NULL,                  -- ↔ chart_checkups.uuid
  within_checkup_line_no   INT UNSIGNED NOT NULL,                -- 受診回内の行順

  source_checkup_uuid      BINARY(16) NOT NULL,                  -- 由来 checkups.uuid（監査）
  treatment_uuid           BINARY(16) NULL,                      -- 由来 treatment_master.uuid 等（任意）

  description              VARCHAR(255) NOT NULL,
  qty_unit                 VARCHAR(32) NULL,
  quantity                 DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type                 ENUM('insurance','private') NOT NULL,
  unit_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points          INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point            DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate                 DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen             INT UNSIGNED NOT NULL DEFAULT 0,

  created_at               DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_chart_items_parent (chart_checkup_uuid, within_checkup_line_no),

  CONSTRAINT fk_chart_items_cc
    FOREIGN KEY (chart_checkup_uuid) REFERENCES chart_checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_items_bi_uuid_v7
BEFORE INSERT ON chart_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;
<<<END patches/archive/008.dis_to_chtit_p015.2.sql>>>

<<<FILE patches/archive/009.ttm_mas_set_p016.1.sql>>>
/* =====================================================================
   vetDB treatment_* install — p016.1r5（p015.1寄せ / usage_textに一本化）
   仕様:
     • on-label: treatment_disease_rules に (treatment_uuid, disease_id) 行が存在 → true
       - その行の disease_specific が非空なら UI に任意表示
     • off-label: 表示なし／DB禁止なし（存在判定のみ）
     • UUID: BINARY(16) v7 を COALESCE(NEW.uuid, uuid_v7_bin()) で自動採番
     • 文字コード: utf8mb4 / COLLATE=utf8mb4_unicode_ci / ROW_FORMAT=DYNAMIC
     • 一覧索引: idx_quality(deleted_at, updated_at, id)
     • 復活・維持: idx_visibility（sets）, idx_treatment（set_items）
   ===================================================================== */

SET NAMES utf8mb4;

/* 再デプロイ安全化（子→親の順） */
DROP TRIGGER IF EXISTS bi_treatment_set_items_uuid;
DROP TRIGGER IF EXISTS bu_treatment_set_items_rowver;
DROP TRIGGER IF EXISTS bi_treatment_sets_uuid;
DROP TRIGGER IF EXISTS bu_treatment_sets_rowver;
DROP TRIGGER IF EXISTS bi_treatment_disease_rules_uuid;
DROP TRIGGER IF EXISTS bu_treatment_disease_rules_rowver;
DROP TRIGGER IF EXISTS bi_treatment_master_uuid;
DROP TRIGGER IF EXISTS bu_treatment_master_rowver;

DROP TABLE IF EXISTS treatment_set_items;
DROP TABLE IF EXISTS treatment_sets;
DROP TABLE IF EXISTS treatment_disease_rules;
DROP TABLE IF EXISTS treatment_master;

/* =====================================================================
   1) treatment_master — 処置/薬剤マスタ
      - スナップ元: name/qty_unit/default_pay_type/current_*/tax_rate/usage_text
      - usage_text に「全体向け注意（旧global_advice）」も含める（一本化）
   ===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_master (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,                   -- UUIDv7(bin16)
  code                 VARCHAR(50) NOT NULL,                         -- 院内/製剤コード（空不可）
  name                 VARCHAR(255) NOT NULL,                        -- 表示名
  type                 ENUM('procedure','medication') NOT NULL,      -- 区分
  qty_unit             VARCHAR(32) NOT NULL,                         -- 単位（checkup_items と統一）
  default_pay_type     ENUM('insurance','private') NOT NULL DEFAULT 'insurance',

  /* 点数/価格は整数運用（スナップ時の丸め不要） */
  current_b_points     INT UNSIGNED NULL,
  current_a_points     INT UNSIGNED NULL,
  current_price_yen    INT UNSIGNED NULL,

  /* 税率（例 0.10）— checkup_items と同桁 */
  tax_rate             DECIMAL(4,2) NOT NULL,

  /* 任意メタ（一本化: 全体向け注意・用法メモもここへ） */
  dosage_per_kg        DECIMAL(10,4) NULL,                           -- 体重1kgあたり
  usage_text           TEXT NULL,                                    -- 全体向け注意/用法等の自由記述

  /* 運用 */
  is_active            TINYINT(1) NOT NULL DEFAULT 1,
  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME NULL,                                -- SoftDelete
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,           -- 楽観ロック

  /* 索引 */
  UNIQUE KEY uq_ttm_code (code),
  KEY    idx_ttm_active (is_active, name),
  KEY    idx_quality (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_master_uuid
BEFORE INSERT ON treatment_master
FOR EACH ROW
BEGIN
  /* uuid 未指定なら v7(BIN16) を採番 */
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_master_rowver
BEFORE UPDATE ON treatment_master
FOR EACH ROW
BEGIN
  /* 更新毎に row_version を +1 */
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
   2) treatment_disease_rules — 適用可病名の割当（存在判定＋任意テキスト）
      - 行が存在 → on-label
      - disease_specific が非空なら UI に任意表示（病名特異の注意）
   ===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_disease_rules (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,           -- UUIDv7(bin16)
  treatment_uuid   BINARY(16) NOT NULL,                  -- ↔ treatment_master.uuid
  disease_id       INT UNSIGNED NOT NULL,                -- ↔ disease_master.id
  disease_specific TEXT NULL,                            -- on-label時の任意表示文（病名特異）
  is_active        TINYINT(1) NOT NULL DEFAULT 1,        -- 論停止
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tdr_pair (treatment_uuid, disease_id),   -- 重複禁止
  KEY idx_tdr_treat (treatment_uuid),
  KEY idx_tdr_dis   (disease_id),
  KEY idx_quality   (deleted_at, updated_at, id),

  CONSTRAINT fk_tdr_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tdr_disease_id
    FOREIGN KEY (disease_id) REFERENCES disease_master(id)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_disease_rules_uuid
BEFORE INSERT ON treatment_disease_rules
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_disease_rules_rowver
BEFORE UPDATE ON treatment_disease_rules
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
   3) treatment_sets — 個人/共有セット（所有者: users.uuid）
      - idx_visibility を維持（可視性での一覧最適化）
   ===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_sets (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,               -- UUIDv7(bin16)
  user_uuid    BINARY(16) NOT NULL,                      -- ↔ users.uuid
  name         VARCHAR(100) NOT NULL,
  note         VARCHAR(255) NULL,
  sequence_no  INT UNSIGNED NOT NULL DEFAULT 1,
  visibility   ENUM('private','shared') NOT NULL DEFAULT 'shared',
  is_active    TINYINT(1) NOT NULL DEFAULT 1,
  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_ts_owner (user_uuid, is_active, sequence_no),
  KEY idx_visibility (visibility),
  KEY idx_quality  (deleted_at, updated_at, id),

  CONSTRAINT fk_treatment_sets_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_sets_uuid
BEFORE INSERT ON treatment_sets
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_sets_rowver
BEFORE UPDATE ON treatment_sets
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
   4) treatment_set_items — セット構成要素
      - idx_treatment(treatment_uuid) を維持（逆引き最適化）
   ===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_set_items (
  id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid            BINARY(16) NOT NULL UNIQUE,            -- UUIDv7(bin16)
  set_uuid        BINARY(16) NOT NULL,                   -- ↔ treatment_sets.uuid
  treatment_uuid  BINARY(16) NOT NULL,                   -- ↔ treatment_master.uuid
  sequence_no     INT UNSIGNED NOT NULL DEFAULT 1,
  preset_quantity DECIMAL(10,2) NULL,                    -- items.quantity と桁合わせ（10,2）
  created_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at      DATETIME NULL,
  row_version     BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tsi_item (set_uuid, treatment_uuid),     -- 同一セット×同一処置は1回のみ
  KEY idx_tsi_set_seq (set_uuid, sequence_no),
  KEY idx_treatment (treatment_uuid),
  KEY idx_quality     (deleted_at, updated_at, id),

  CONSTRAINT fk_tsi_set_uuid
    FOREIGN KEY (set_uuid) REFERENCES treatment_sets(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tsi_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_set_items_uuid
BEFORE INSERT ON treatment_set_items
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_set_items_rowver
BEFORE UPDATE ON treatment_set_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/archive/009.ttm_mas_set_p016.1.sql>>>

<<<FILE patches/archive/009.ttm_mas_set_p016.2.sql>>>
/* =====================================================================
   vetDB treatment_* install — p016.1r6（disease_uuid 統一 / p016.1 準拠）
   仕様（要点）:
     • on-label: treatment_disease_rules に (treatment_uuid, disease_uuid) が存在 → true
       - disease_specific が非空なら UI に任意表示
     • off-label: 表示なし／DB禁止なし（存在判定のみ）
     • UUID: BINARY(16) v7 を COALESCE(NEW.uuid, uuid_v7_bin()) で自動採番
     • 文字コード: utf8mb4 / COLLATE=utf8mb4_unicode_ci / ROW_FORMAT=DYNAMIC
     • 一覧索引: idx_quality(deleted_at, updated_at, id)
     • 維持: idx_visibility（sets）, idx_treatment（set_items）
   ===================================================================== */

SET NAMES utf8mb4;

/* -------------------------------------------------------------
   再デプロイ安全化（依存順: 子 → 親）
------------------------------------------------------------- */
DROP TRIGGER IF EXISTS bi_treatment_set_items_uuid;
DROP TRIGGER IF EXISTS bu_treatment_set_items_rowver;
DROP TRIGGER IF EXISTS bi_treatment_sets_uuid;
DROP TRIGGER IF EXISTS bu_treatment_sets_rowver;
DROP TRIGGER IF EXISTS bi_treatment_disease_rules_uuid;
DROP TRIGGER IF EXISTS bu_treatment_disease_rules_rowver;
DROP TRIGGER IF EXISTS bi_treatment_master_uuid;
DROP TRIGGER IF EXISTS bu_treatment_master_rowver;

DROP TABLE IF EXISTS treatment_set_items;
DROP TABLE IF EXISTS treatment_sets;
DROP TABLE IF EXISTS treatment_disease_rules;
DROP TABLE IF EXISTS treatment_master;

/* =====================================================================
  1) treatment_master — 処置/薬剤マスタ
     - スナップ元: name/qty_unit/default_pay_type/current_*/tax_rate/usage_text
     - usage_text に「全体向け注意（旧global_advice）」も含める（一本化）
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_master (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,                   -- UUIDv7(bin16)
  code                 VARCHAR(50)  NOT NULL,                        -- 院内/製剤コード（空不可）
  name                 VARCHAR(255) NOT NULL,                        -- 表示名
  type                 ENUM('procedure','medication') NOT NULL,      -- 区分
  qty_unit             VARCHAR(32)  NOT NULL,                        -- 単位（checkup_items と統一）
  default_pay_type     ENUM('insurance','private') NOT NULL DEFAULT 'insurance',

  -- 点数/価格（整数運用）
  current_b_points     INT UNSIGNED NULL,
  current_a_points     INT UNSIGNED NULL,
  current_price_yen    INT UNSIGNED NULL,

  -- 税率（例 0.10）— checkup_items と同桁
  tax_rate             DECIMAL(4,2) NOT NULL,

  -- 任意メタ（一本化: 全体向け注意・用法等）
  dosage_per_kg        DECIMAL(10,4) NULL,                           -- 体重1kgあたり
  usage_text           TEXT NULL,

  -- 運用
  is_active            TINYINT(1) NOT NULL DEFAULT 1,
  created_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME  NULL,                                -- SoftDelete
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,            -- 楽観ロック

  -- 索引
  UNIQUE KEY uq_ttm_code (code),
  KEY    idx_ttm_active (is_active, name),
  KEY    idx_quality (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_master_uuid
BEFORE INSERT ON treatment_master
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_master_rowver
BEFORE UPDATE ON treatment_master
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  2) treatment_disease_rules — 適用可病名の割当（存在判定＋任意テキスト）
     - 行が存在 → on-label
     - disease_specific が非空なら UI に任意表示（病名特異の注意）
     - ★ disease_id → disease_uuid（BINARY(16)）に統一
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_disease_rules (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,           -- UUIDv7(bin16)
  treatment_uuid   BINARY(16) NOT NULL,                  -- ↔ treatment_master.uuid
  disease_uuid     BINARY(16) NOT NULL,                  -- ↔ disease_master.uuid（★変更点）
  disease_specific TEXT NULL,                            -- on-label時の任意表示文（病名特異）
  is_active        TINYINT(1) NOT NULL DEFAULT 1,
  created_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME  NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tdr_pair (treatment_uuid, disease_uuid), -- 重複禁止
  KEY idx_tdr_treat (treatment_uuid),
  KEY idx_tdr_dis   (disease_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),

  CONSTRAINT fk_tdr_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tdr_disease_uuid
    FOREIGN KEY (disease_uuid)   REFERENCES disease_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_disease_rules_uuid
BEFORE INSERT ON treatment_disease_rules
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_disease_rules_rowver
BEFORE UPDATE ON treatment_disease_rules
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  3) treatment_sets — 個人/共有セット（所有者: users.uuid）
     - idx_visibility で一覧最適化
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_sets (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,               -- UUIDv7(bin16)
  user_uuid    BINARY(16) NOT NULL,                      -- ↔ users.uuid
  name         VARCHAR(100) NOT NULL,
  note         VARCHAR(255) NULL,
  sequence_no  INT UNSIGNED NOT NULL DEFAULT 1,
  visibility   ENUM('private','shared') NOT NULL DEFAULT 'shared',
  is_active    TINYINT(1) NOT NULL DEFAULT 1,

  created_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME  NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_ts_owner (user_uuid, is_active, sequence_no),
  KEY idx_visibility (visibility),
  KEY idx_quality  (deleted_at, updated_at, id),

  CONSTRAINT fk_treatment_sets_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_sets_uuid
BEFORE INSERT ON treatment_sets
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_sets_rowver
BEFORE UPDATE ON treatment_sets
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  4) treatment_set_items — セット構成要素
     - idx_treatment(treatment_uuid) を維持（逆引き最適化）
     - 展開は全行ON（フラグ不要）／preset_quantity があれば最優先
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_set_items (
  id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid            BINARY(16) NOT NULL UNIQUE,            -- UUIDv7(bin16)
  set_uuid        BINARY(16) NOT NULL,                   -- ↔ treatment_sets.uuid
  treatment_uuid  BINARY(16) NOT NULL,                   -- ↔ treatment_master.uuid
  sequence_no     INT UNSIGNED NOT NULL DEFAULT 1,
  preset_quantity DECIMAL(10,2) NULL,                    -- p016.1方針（10,2）

  created_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at      DATETIME  NULL,
  row_version     BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tsi_item (set_uuid, treatment_uuid),     -- 同一セット×同一処置は1回
  KEY idx_tsi_set_seq (set_uuid, sequence_no),
  KEY idx_treatment (treatment_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),

  CONSTRAINT fk_tsi_set_uuid
    FOREIGN KEY (set_uuid)       REFERENCES treatment_sets(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tsi_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_set_items_uuid
BEFORE INSERT ON treatment_set_items
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_set_items_rowver
BEFORE UPDATE ON treatment_set_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/archive/009.ttm_mas_set_p016.2.sql>>>

<<<FILE patches/archive/009.ttm_mas_set_p016.3.sql>>>
/* =====================================================================
   vetDB treatment_* install — p016.2-CSIFH(min, FK=master-only)
   方針（最低適用）:
     • clinic_uuid(BINARY(16)) を全表に追加して当時値固定
     • 子表は BEFORE INSERT で clinic_uuid を親から継承（NULL時のみ）
     • clinic_uuid は全表で更新禁止
     • clinics への FK は treatment_master のみに付与（他表は付与しない）
     • 院別一覧最適化 idx_clinic_list(clinic_uuid, deleted_at, updated_at, id) を全表に付与
     • p016.2 の disease_uuid(BINARY(16)) を維持
   前提:
     • clinics(uuid), users(uuid, clinic_uuid), disease_master(uuid) が先に存在
   ===================================================================== */

SET NAMES utf8mb4;

/* 再デプロイ安全化（依存順: 子 → 親） */
DROP TRIGGER IF EXISTS bi_treatment_set_items_uuid;
DROP TRIGGER IF EXISTS bu_treatment_set_items_rowver;
DROP TRIGGER IF EXISTS bi_treatment_sets_uuid;
DROP TRIGGER IF EXISTS bu_treatment_sets_rowver;
DROP TRIGGER IF EXISTS bi_treatment_disease_rules_uuid;
DROP TRIGGER IF EXISTS bu_treatment_disease_rules_rowver;
DROP TRIGGER IF EXISTS bi_treatment_master_uuid;
DROP TRIGGER IF EXISTS bu_treatment_master_rowver;

DROP TABLE IF EXISTS treatment_set_items;
DROP TABLE IF EXISTS treatment_sets;
DROP TABLE IF EXISTS treatment_disease_rules;
DROP TABLE IF EXISTS treatment_master;

/* =====================================================================
  1) treatment_master — 処置/薬剤マスタ（ルート）
     - clinic_uuid はアプリ必須（以後、不変）
     - clinics への FK を付与（★この表のみ）
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_master (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,                   -- UUIDv7(bin16)
  clinic_uuid          BINARY(16) NOT NULL,                          -- ↔ clinics.uuid（当時値・不変）
  code                 VARCHAR(50)  NOT NULL,
  name                 VARCHAR(255) NOT NULL,
  type                 ENUM('procedure','medication') NOT NULL,
  qty_unit             VARCHAR(32)  NOT NULL,
  default_pay_type     ENUM('insurance','private') NOT NULL DEFAULT 'insurance',

  /* 点数/価格（整数運用） */
  current_b_points     INT UNSIGNED NULL,
  current_a_points     INT UNSIGNED NULL,
  current_price_yen    INT UNSIGNED NULL,

  /* 税率 */
  tax_rate             DECIMAL(4,2) NOT NULL,

  /* 任意メタ（一本化） */
  dosage_per_kg        DECIMAL(10,4) NULL,
  usage_text           TEXT NULL,

  /* 運用 */
  is_active            TINYINT(1) NOT NULL DEFAULT 1,
  created_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME  NULL,
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,

  /* 索引 */
  UNIQUE KEY uq_ttm_code (code),
  KEY    idx_ttm_active (is_active, name),
  KEY    idx_quality (deleted_at, updated_at, id),
  KEY    idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  /* FK（★この表のみ clinics を参照） */
  CONSTRAINT fk_ttm_clinic_uuid
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_master_uuid
BEFORE INSERT ON treatment_master
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_master_rowver
BEFORE UPDATE ON treatment_master
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_master';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  2) treatment_disease_rules — 適用可病名（存在判定＋任意表示）
     - clinic_uuid を親（treatment_master）から継承（NULL時のみ）
     - clinics への FK は付けない（ご要望）
     - disease_uuid は p016.2 の方針を維持
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_disease_rules (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,           -- UUIDv7(bin16)
  clinic_uuid      BINARY(16) NOT NULL,                  -- 当時値（FKなし）
  treatment_uuid   BINARY(16) NOT NULL,                  -- ↔ treatment_master.uuid
  disease_uuid     BINARY(16) NOT NULL,                  -- ↔ disease_master.uuid
  disease_specific TEXT NULL,
  is_active        TINYINT(1) NOT NULL DEFAULT 1,
  created_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME  NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tdr_pair (treatment_uuid, disease_uuid),
  KEY idx_tdr_treat (treatment_uuid),
  KEY idx_tdr_dis   (disease_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  /* 既存参照は維持 */
  CONSTRAINT fk_tdr_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tdr_disease_uuid
    FOREIGN KEY (disease_uuid)   REFERENCES disease_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_disease_rules_uuid
BEFORE INSERT ON treatment_disease_rules
FOR EACH ROW
BEGIN
  DECLARE v_parent_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_master）から clinic_uuid を継承（NULL時のみ設定） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT tm.clinic_uuid INTO v_parent_clinic
      FROM treatment_master tm
     WHERE tm.uuid = NEW.treatment_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_parent_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_disease_rules_rowver
BEFORE UPDATE ON treatment_disease_rules
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_disease_rules';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  3) treatment_sets — 個人/共有セット（所有者: users.uuid）
     - clinic_uuid を親（users）から継承（NULL時のみ）
     - clinics への FK は付けない（ご要望）
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_sets (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,               -- UUIDv7(bin16)
  clinic_uuid  BINARY(16) NOT NULL,                      -- 当時値（FKなし）
  user_uuid    BINARY(16) NOT NULL,                      -- ↔ users.uuid
  name         VARCHAR(100) NOT NULL,
  note         VARCHAR(255) NULL,
  sequence_no  INT UNSIGNED NOT NULL DEFAULT 1,
  visibility   ENUM('private','shared') NOT NULL DEFAULT 'shared',
  is_active    TINYINT(1) NOT NULL DEFAULT 1,

  created_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME  NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_ts_owner (user_uuid, is_active, sequence_no),
  KEY idx_visibility (visibility),
  KEY idx_quality  (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_treatment_sets_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_sets_uuid
BEFORE INSERT ON treatment_sets
FOR EACH ROW
BEGIN
  DECLARE v_user_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（users）から clinic_uuid を継承（NULL時のみ設定） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT u.clinic_uuid INTO v_user_clinic
      FROM users u
     WHERE u.uuid = NEW.user_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_user_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_sets_rowver
BEFORE UPDATE ON treatment_sets
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_sets';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  4) treatment_set_items — セット構成要素
     - clinic_uuid を親（treatment_sets）から継承（NULL時のみ）
     - clinics への FK は付けない（ご要望）
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_set_items (
  id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid            BINARY(16) NOT NULL UNIQUE,            -- UUIDv7(bin16)
  clinic_uuid     BINARY(16) NOT NULL,                   -- 当時値（FKなし）
  set_uuid        BINARY(16) NOT NULL,                   -- ↔ treatment_sets.uuid
  treatment_uuid  BINARY(16) NOT NULL,                   -- ↔ treatment_master.uuid
  sequence_no     INT UNSIGNED NOT NULL DEFAULT 1,
  preset_quantity DECIMAL(10,2) NULL,                    -- p016.2方針（10,2）

  created_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at      DATETIME  NULL,
  row_version     BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tsi_item (set_uuid, treatment_uuid),
  KEY idx_tsi_set_seq (set_uuid, sequence_no),
  KEY idx_treatment (treatment_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_tsi_set_uuid
    FOREIGN KEY (set_uuid)       REFERENCES treatment_sets(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tsi_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_set_items_uuid
BEFORE INSERT ON treatment_set_items
FOR EACH ROW
BEGIN
  DECLARE v_set_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_sets）から clinic_uuid を継承（NULL時のみ設定） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT ts.clinic_uuid INTO v_set_clinic
      FROM treatment_sets ts
     WHERE ts.uuid = NEW.set_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_set_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_set_items_rowver
BEFORE UPDATE ON treatment_set_items
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_set_items';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/archive/009.ttm_mas_set_p016.3.sql>>>

<<<FILE patches/archive/012.clinic_settings_p018.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   clinic_settings — クリニック共通設定（p014.3 / p016.1 / p017.1 整合）
   - 税率は小数表現（10% = 0.10）
   - yen_per_point は DECIMAL(8,2)
   - copay_rate は DECIMAL(5,4)（receipt_* と一致）
   - 端数処理は method を ENUM('floor','round','ceil') に統一
     ※ 発行時: clinic_settings.tax_rounding_method → receipt_* .tax_rounding にそのままコピー
   ========================================================= */

DROP TABLE IF EXISTS clinic_settings;
CREATE TABLE clinic_settings (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* ---------- 請求・点数関連 ---------- */
  yen_per_point             DECIMAL(8,2) NOT NULL DEFAULT 10.00,   -- 1点=10円
  copay_rate                DECIMAL(5,4) NOT NULL DEFAULT 0.1000,  -- 10% = 0.1000

  /* ---------- 税率・端数処理 ---------- */
  tax_rate_default          DECIMAL(4,2) NOT NULL DEFAULT 0.10,    -- 10%は0.10（小数）
  tax_rounding_method       ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',
  tax_rounding_scope        ENUM('line','total') NOT NULL DEFAULT 'line',

  /* ---------- インボイス/帳票ヘッダ ---------- */
  invoice_qualified_number  VARCHAR(32)  NULL,
  invoice_number_format     VARCHAR(64)  NULL,   -- 例: 'INV-{YYYY}-{SEQ6}'
  clinic_display_name       VARCHAR(128) NULL,
  clinic_address            VARCHAR(255) NULL,
  clinic_phone              VARCHAR(32)  NULL,

  /* ---------- 監査/削除・並行制御（v1p9方針） ---------- */
  row_version               BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at                DATETIME NULL,

  /* ---------- 作成・更新 ---------- */
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化（v1p9の共通方針） */
  KEY idx_clinic_settings_list (deleted_at, updated_at, id)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;
<<<END patches/archive/012.clinic_settings_p018.sql>>>

<<<FILE patches/archive/012.clinics_sett_p018.2.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   clinics — テナント（病院）親テーブル
   方針:
     - BINARY(16) UUID（v7推奨）
     - サブドメイン/独自ドメインでテナント解決（NULL許容UNIQUE）
     - v1p9流: row_version, SoftDelete, 一覧索引
     - 帳票系の表示・税設定は clinic_settings 側へ集約
   ========================================================= */

-- 再デプロイ安全化（既存トリガ削除）
DROP TRIGGER IF EXISTS tr_clinics_bi_uuid;
DROP TRIGGER IF EXISTS tr_clinics_bu_rowver;

CREATE TABLE IF NOT EXISTS clinics (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* 一意識別子（v7 UUID推奨） */
  uuid                BINARY(16) NOT NULL UNIQUE,

  /* 管理・内部用の正式名称（帳票表示は clinic_settings 側で上書き可） */
  name                VARCHAR(128) NOT NULL,

  /* テナント解決キー（どちらか/両方を利用） */
  subdomain           VARCHAR(63)  NULL,           -- 例: foo → https://foo.example.com
  custom_domain       VARCHAR(255) NULL,           -- 例: https://clinic-foo.jp

  /* 運用属性（UI/帳票の既定値） */
  time_zone           VARCHAR(64)  NOT NULL DEFAULT 'Asia/Tokyo',  -- IANA TZ
  locale              VARCHAR(16)  NOT NULL DEFAULT 'ja-JP',       -- BCP47
  currency            CHAR(3)      NOT NULL DEFAULT 'JPY',         -- ISO-4217
  country_code        CHAR(2)      NULL,                           -- ISO-3166-1

  /* サポート窓口（運用連絡先。帳票の連絡先は settings 側で上書き可能） */
  support_email       VARCHAR(191) NULL,
  support_phone       VARCHAR(32)  NULL,

  /* 内部メモ（監査ログではない。自由記入） */
  notes               TEXT NULL,

  /* 運用状態 */
  status              ENUM('active','suspended','closed') NOT NULL DEFAULT 'active',

  /* ドメイン検証（任意運用） */
  domain_verified_at  DATETIME NULL,

  /* 監査・並行制御（v1p9） */
  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,

  /* 作成・更新時刻 */
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧・差分最適化インデックス（v1p9既定形） */
  KEY idx_clinics_list (deleted_at, updated_at, id),

  /* 解決キー（NULL許容のユニーク） */
  UNIQUE KEY uq_clinics_subdomain     (subdomain),
  UNIQUE KEY uq_clinics_custom_domain (custom_domain),

  /* 名称検索の補助 */
  INDEX idx_clinics_name (name)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- UUID自動付与（アプリ側で付与するなら不要）
CREATE TRIGGER tr_clinics_bi_uuid
BEFORE INSERT ON clinics
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END;

-- 楽観ロック: 更新ごとに row_version を +1
CREATE TRIGGER tr_clinics_bu_rowver
BEFORE UPDATE ON clinics
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END;


/* =========================================================
   clinic_settings — クリニック共通設定（p018.1 拡張版）
   追加点:
     - clinic_uuid BINARY(16) NOT NULL UNIQUE（多病院対応のテナントキー）
     - billing_contact_name VARCHAR(128)
     - invoice_logo_path VARCHAR(255)
     - receipt_footer_text VARCHAR(255)
     - receipt_footer_invoice_number CHAR(14)（T+13桁, フッター用）
   方針:
     - 税率は小数表現（10% = 0.10）
     - yen_per_point: DECIMAL(8,2), copay_rate: DECIMAL(5,4)
     - 端数処理: ENUM('floor','round','ceil'), 適用範囲: ENUM('line','total')
     - 一覧索引 v1p9形（deleted_at, updated_at, id）
     - clinics へのFKは張らず、アプリ層でテナントスコープを徹底
   ========================================================= */

-- 新規インストール用
CREATE TABLE IF NOT EXISTS clinic_settings (
  id                         INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* 多病院対応のテナントキー（1院=1行を UNIQUEで強制） */
  clinic_uuid                BINARY(16) NOT NULL,
  UNIQUE KEY uq_clinic_settings_one (clinic_uuid),

  /* ---------- 請求・点数関連 ---------- */
  yen_per_point              DECIMAL(8,2)  NOT NULL DEFAULT 10.00,  -- 1点=10円
  copay_rate                 DECIMAL(5,4)  NOT NULL DEFAULT 0.1000, -- 10% = 0.1000

  /* ---------- 税率・端数処理 ---------- */
  tax_rate_default           DECIMAL(4,2)  NOT NULL DEFAULT 0.10,   -- 10%は0.10（小数）
  tax_rounding_method        ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',
  tax_rounding_scope         ENUM('line','total')        NOT NULL DEFAULT 'line',

  /* ---------- インボイス/帳票ヘッダ ---------- */
  invoice_qualified_number   VARCHAR(32)  NULL,
  invoice_number_format      VARCHAR(64)  NULL,  -- 例: 'INV-{YYYY}-{SEQ6}'
  clinic_display_name        VARCHAR(128) NULL,
  clinic_address             VARCHAR(255) NULL,
  clinic_phone               VARCHAR(32)  NULL,

  /* NEW: 請求窓口担当者名（帳票/経理運用に利用） */
  billing_contact_name       VARCHAR(128) NULL,

  /* NEW: 帳票ロゴ（S3等のパス想定） */
  invoice_logo_path          VARCHAR(255) NULL,

  /* NEW: レシート定型フッター */
  receipt_footer_text        VARCHAR(255) NULL,

  /* NEW: フッター用インボイス登録番号（T+13桁） */
  receipt_footer_invoice_number CHAR(14) NULL
    COMMENT '適格請求書発行事業者番号（T+13桁）; フッター表示用',

  /* ---------- 監査/削除・並行制御（v1p9方針） ---------- */
  row_version                BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at                 DATETIME NULL,

  /* ---------- 作成・更新 ---------- */
  created_at                 DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                 DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化（v1p9の共通方針） */
  KEY idx_clinic_settings_list (deleted_at, updated_at, id)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

/* 形式厳格化を行いたい場合（対応環境のみ有効化）：
ALTER TABLE clinic_settings
  ADD CONSTRAINT chk_receipt_footer_invoice_number_format
  CHECK (
    receipt_footer_invoice_number IS NULL
    OR receipt_footer_invoice_number REGEXP '^T[0-9]{13}$'
  );
*/
<<<END patches/archive/012.clinics_sett_p018.2.sql>>>

<<<FILE patches/archive/012.clinics_setti_p018.1.sql>>>
SET NAMES utf8mb4;

DROP TRIGGER IF EXISTS tr_clinics_bi_uuid;
DROP TRIGGER IF EXISTS tr_clinics_bu_rowver;

CREATE TABLE IF NOT EXISTS clinics (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* 一意識別子（v7 UUID推奨） */
  uuid                BINARY(16) NOT NULL UNIQUE,

  /* 管理・内部用の正式名称（帳票表示は clinic_settings 側で上書き可） */
  name                VARCHAR(128) NOT NULL,

  /* テナント解決キー（どちらか/両方を利用） */
  subdomain           VARCHAR(63)  NULL,           -- 例: foo → https://foo.example.com
  custom_domain       VARCHAR(255) NULL,           -- 例: https://clinic-foo.jp

  /* 運用属性（UI/帳票の既定値） */
  time_zone           VARCHAR(64)  NOT NULL DEFAULT 'Asia/Tokyo',  -- IANA TZ
  locale              VARCHAR(16)  NOT NULL DEFAULT 'ja-JP',       -- BCP47
  currency            CHAR(3)      NOT NULL DEFAULT 'JPY',         -- ISO-4217
  country_code        CHAR(2)      NULL,                           -- ISO-3166-1

  /* サポート窓口（運用連絡先。帳票の連絡先は settings 側で上書き可能） */
  support_email       VARCHAR(191) NULL,
  support_phone       VARCHAR(32)  NULL,

  /* 内部メモ（監査ログではない。自由記入） */
  notes               TEXT NULL,

  /* 運用状態 */
  status              ENUM('active','suspended','closed') NOT NULL DEFAULT 'active',

  /* ドメイン検証（任意運用） */
  domain_verified_at  DATETIME NULL,

  /* 監査・並行制御（v1p9） */
  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,

  /* 作成・更新時刻 */
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧・差分最適化インデックス（v1p9既定形） */
  KEY idx_clinics_list (deleted_at, updated_at, id),

  /* 解決キー（NULL許容のユニーク） */
  UNIQUE KEY uq_clinics_subdomain     (subdomain),
  UNIQUE KEY uq_clinics_custom_domain (custom_domain),

  /* 名称検索の補助 */
  INDEX idx_clinics_name (name)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

-- UUID自動付与（アプリ側で付与するなら不要）
CREATE TRIGGER tr_clinics_bi_uuid
BEFORE INSERT ON clinics
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END;

-- 楽観ロック: 更新ごとに row_version を +1
CREATE TRIGGER tr_clinics_bu_rowver
BEFORE UPDATE ON clinics
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END;

SET NAMES utf8mb4;

/* =========================================================
   clinic_settings — クリニック共通設定（p014.3 / p016.1 / p017.1 整合）
   - 税率は小数表現（10% = 0.10）
   - yen_per_point は DECIMAL(8,2)
   - copay_rate は DECIMAL(5,4)（receipt_* と一致）
   - 端数処理は method を ENUM('floor','round','ceil') に統一
     ※ 発行時: clinic_settings.tax_rounding_method → receipt_* .tax_rounding にそのままコピー
   ========================================================= */

DROP TABLE IF EXISTS clinic_settings;
CREATE TABLE clinic_settings (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* ---------- 請求・点数関連 ---------- */
  yen_per_point             DECIMAL(8,2) NOT NULL DEFAULT 10.00,   -- 1点=10円
  copay_rate                DECIMAL(5,4) NOT NULL DEFAULT 0.1000,  -- 10% = 0.1000

  /* ---------- 税率・端数処理 ---------- */
  tax_rate_default          DECIMAL(4,2) NOT NULL DEFAULT 0.10,    -- 10%は0.10（小数）
  tax_rounding_method       ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',
  tax_rounding_scope        ENUM('line','total') NOT NULL DEFAULT 'line',

  /* ---------- インボイス/帳票ヘッダ ---------- */
  invoice_qualified_number  VARCHAR(32)  NULL,
  invoice_number_format     VARCHAR(64)  NULL,   -- 例: 'INV-{YYYY}-{SEQ6}'
  clinic_display_name       VARCHAR(128) NULL,
  clinic_address            VARCHAR(255) NULL,
  clinic_phone              VARCHAR(32)  NULL,

  /* ---------- 監査/削除・並行制御（v1p9方針） ---------- */
  row_version               BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at                DATETIME NULL,

  /* ---------- 作成・更新 ---------- */
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化（v1p9の共通方針） */
  KEY idx_clinic_settings_list (deleted_at, updated_at, id)
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;
<<<END patches/archive/012.clinics_setti_p018.1.sql>>>

<<<FILE patches/archive/013.insu_enro_p019.1.sql>>>
SET NAMES utf8mb4;

/* ======================================================================
   Insurance Enrollment — Fresh Install (Long-Comment Edition, v1p9 style)
   ----------------------------------------------------------------------
   目的
     - 農家（farm_user）ごとの保険加入履歴を「追記主義」で管理し、
       「今日有効な1行 or 最終記録の1行」に“自動代表化”するビューを提供する。
     - 画面・集計は、原則ビュー（insurance_current / insurance_current_status）を参照すれば足りる。

   v1p9 ポリシー
     - 楽観ロック: row_version（BIGINT UNSIGNED）
     - 論理削除: deleted_at
     - 一覧最適化インデックス: (deleted_at, updated_at, id)

   ENUM（英語）
     - status: 'insured' | 'non_insured' | 'unknown'
       ※“入力値の状態”。ビュー側の“最終ラベル”とは別物。

   無効化の二段構え
     - voided_at : 誤登録等の取消（監査上は残す）
     - deleted_at: 削除相当（最終手段）

   期間扱い
     - start_date / end_date は片側 NULL を許容（最小入力で運用可）
     - 両端 NULL も許容し、ビュー上は “常に today-valid” と扱う
     - CHECK制約で start_date <= end_date（NULL はスルー）

   ビュー要点
     - insurance_current
       * farm_user_id ごとに ROW_NUMBER() で代表行を1行に確定
       * 優先: 「今日有効」→（なければ）「最終記録」（end DESC → start DESC → id DESC）
       * days_to_end を算出（end_date が NULL なら NULL）

     - insurance_current_status
       * UI/集計向け “最終ラベル” を英語で提供
         'active' / 'renewal_overdue' / 'renewal_due_soon' / 'non_insured' / 'insured' / 'unknown'

   前提
     - MySQL 8.0+（Window関数使用）
   ====================================================================== */


/* ----------------------------------------------------------------------
   0) 依存ビュー先にDROP（定義順序の都合）
   ---------------------------------------------------------------------- */
DROP VIEW IF EXISTS `insurance_current_status`;
DROP VIEW IF EXISTS `insurance_current`;


/* ----------------------------------------------------------------------
   1) 本体テーブル
   ---------------------------------------------------------------------- */
DROP TABLE IF EXISTS `insurance_enrollments`;
CREATE TABLE IF NOT EXISTS `insurance_enrollments` (
  /* 識別子（AUTO_INCREMENT 主キー）
     - 歴史的背景により主キーは INT。
     - 監査・タイブレークに id を用いる（新しい=大きい）。 */
  `id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* 所有者（テナント）側識別 */
  `farm_user_id` INT UNSIGNED NOT NULL,

  /* 加入者コード（共済番号など8桁を想定） */
  `subscriber_code` CHAR(8) NOT NULL,

  /* 入力ステータス（英語）
     - insured : 加入として入力
     - non_insured : 非加入として入力
     - unknown : 不明/未判定
     ※「今日有効かどうか」はビュー側（期間判定）で判断。 */
  `status` ENUM('insured','non_insured','unknown') NOT NULL DEFAULT 'unknown',

  /* 期間（端NULL許容）— 両端NULLも today-valid */
  `start_date` DATE NULL,
  `end_date`   DATE NULL,

  /* 会計年度（任意） */
  `fiscal_year` YEAR NULL,

  /* 情報源・備考（任意） */
  `source_note` VARCHAR(255) NULL,

  /* 無効化(取消)と理由 — voided 行はランキング対象から除外 */
  `voided_at`   DATETIME NULL,
  `void_reason` VARCHAR(255) NULL,

  /* v1p9: 楽観ロック & 論理削除 & 監査 */
  `row_version` BIGINT UNSIGNED NOT NULL DEFAULT 1,  -- 更新毎に+1
  `deleted_at`  DATETIME NULL,                       -- 削除相当（最終手段）
  `created_by`  INT UNSIGNED NULL,                   -- 誰が作成したか（任意）
  `created_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 期間検索・代表化前の絞り込みで有効 */
  INDEX `idx_user_dates` (`farm_user_id`, `start_date`, `end_date`),

  /* コード検索・監査用 */
  INDEX `idx_code` (`subscriber_code`),

  /* v1p9: 一覧最適化（差分同期や更新順ソートで有効） */
  KEY `idx_enroll_list` (`deleted_at`, `updated_at`, `id`),

  /* 期間整合性（NULLはスルー）
     - 一部MySQLでは CHECK を無視するためアプリ層検証も併用推奨。 */
  CHECK ( `start_date` IS NULL OR `end_date` IS NULL OR `start_date` <= `end_date` ),

  /* ★ 追加: FK（farm_user_id → farm_users.id）*/
  CONSTRAINT `fk_ins_enro_farm_user`
    FOREIGN KEY (`farm_user_id`) REFERENCES `farm_users`(`id`)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


/* ----------------------------------------------------------------------
   2) row_version 自動インクリメント用トリガ
      - アプリ側で管理する場合は本トリガは不要。
   ---------------------------------------------------------------------- */
DROP TRIGGER IF EXISTS `tr_insurance_enrollments_rowver_bu`;
DELIMITER $$
CREATE TRIGGER `tr_insurance_enrollments_rowver_bu`
BEFORE UPDATE ON `insurance_enrollments`
FOR EACH ROW
BEGIN
  /* 更新のたびに row_version を +1。
     競合検知: UPDATE ... WHERE row_version=:client_version で0件なら競合。 */
  SET NEW.`row_version` = OLD.`row_version` + 1;
END$$
DELIMITER ;


/* ----------------------------------------------------------------------
   3) 現在有効 or 最終記録 を1行に代表化するビュー
      名称: insurance_current
   ---------------------------------------------------------------------- */
CREATE VIEW `insurance_current` AS
WITH ranked AS (
  SELECT
    e.*,

    /* 今日有効？（端NULL許容） */
    CASE
      WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
       AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
      THEN 1 ELSE 0
    END AS is_today_valid,

    /* 代表順位（昇順）:
       0: today-valid（最優先）, 1: not today-valid（後回し）
       次に期限の新しさ→開始日の新しさ→新しいid を優先。 */
    ROW_NUMBER() OVER (
      PARTITION BY e.farm_user_id
      ORDER BY
        CASE
          WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
           AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
          THEN 0 ELSE 1
        END,
        COALESCE(e.end_date,  '9999-12-31') DESC,
        COALESCE(e.start_date,'9999-12-31') DESC,
        e.id DESC
    ) AS rn
  FROM `insurance_enrollments` e
  /* ランキング対象外（取消・削除相当は除外） */
  WHERE e.voided_at IS NULL AND e.deleted_at IS NULL
)
SELECT
  r.*,
  /* 残日数: end_date が存在するときのみ算出（DATEDIFF=a-b） */
  CASE WHEN r.end_date IS NULL THEN NULL
       ELSE DATEDIFF(r.end_date, CURDATE())
  END AS days_to_end
FROM ranked r
/* 代表行のみ */
WHERE r.rn = 1;


/* ----------------------------------------------------------------------
   4) UI / 集計向け “最終ラベル” ビュー
      名称: insurance_current_status
   ---------------------------------------------------------------------- */
CREATE VIEW `insurance_current_status` AS
SELECT
  c.farm_user_id,
  c.subscriber_code,
  c.start_date,
  c.end_date,
  c.days_to_end,
  /* 最終ラベル（英語／ENUMに追従） */
  CASE
    WHEN c.is_today_valid = 1 THEN 'active'
    WHEN c.end_date IS NOT NULL AND c.end_date < CURDATE() THEN 'renewal_overdue'
    WHEN c.end_date IS NOT NULL
         AND c.end_date >= CURDATE()
         AND c.end_date <= (CURDATE() + INTERVAL 30 DAY)
      THEN 'renewal_due_soon'
    WHEN c.status = 'non_insured' THEN 'non_insured'
    WHEN c.status = 'insured'     THEN 'insured'
    ELSE 'unknown'
  END AS current_status
FROM `insurance_current` c;
<<<END patches/archive/013.insu_enro_p019.1.sql>>>

<<<FILE patches/archive/013.insu_enro_p019.sql>>>
SET NAMES utf8mb4;

/* ======================================================================
   Insurance Enrollment — Fresh Install (Long-Comment Edition, v1p9 style)
   ----------------------------------------------------------------------
   ■ 目的
     - 農家（farm_user）ごとの保険加入履歴を「追記主義」で管理し、
       「今日有効な1行 or 最終記録の1行」に“自動代表化”するビューを提供する。
     - 画面・集計は、原則ビュー（insurance_current / insurance_current_status）を参照すれば足りる。

   ■ v1p9 ポリシーの反映
     - 楽観的ロック用 row_version（BIGINT UNSIGNED）
     - 論理削除カラム deleted_at
     - 一覧最適化インデックス (deleted_at, updated_at, id)

   ■ ENUM（英語／改訂）
     - status: 'insured' | 'non_insured' | 'unknown'   ※ 'draft' は廃止
       * “入力値の状態”であり、ビュー側の“最終ラベル”とは別物。
       * 例: 期限切れの場合、status='insured' でも current_status では
             'renewal_overdue' を優先表示する。

   ■ 無効化の二段構え
     - voided_at   : 誤登録などの「取消」。監査上は残す（推奨）。
     - deleted_at  : 削除相当（最終手段）。原則アプリからは使わず void を推奨。

   ■ 期間扱いの原則
     - start_date / end_date は片側 NULL を許容（最小入力で運用可）。
     - 両端 NULL も許容し、ビューでは “常に today-valid” と見なす仕様。
       → 実務運用では UI で最低1端の入力を推奨。
     - CHECK制約で「start_date <= end_date」を緩く強制（NULLはスルー）。
       * 一部MySQLでは CHECK が無視されるため、アプリ層検証も併用推奨。

   ■ ビューの要点
     - insurance_current:
         * farm_user_id ごとに ROW_NUMBER() で 1行に代表化。
         * 優先順位: 「今日有効」→（なければ）「最終記録」
           最終記録の定義は end_date DESC → start_date DESC → id DESC。
         * 残日数 days_to_end も算出（end_date が NULL なら NULL）。
     - insurance_current_status:
         * UI/集計向けに “最終ラベル” を英語で提供。
           'active' / 'renewal_overdue' / 'renewal_due_soon'
           / 'non_insured' / 'insured' / 'unknown'

   ■ バージョン要件
     - Window関数（ROW_NUMBER, OVER, PARTITION BY, ORDER BY）を使用。
       → MySQL 8.0+ / MariaDB（対応版）が前提。

   ====================================================================== */


/* ----------------------------------------------------------------------
   0) 依存ビュー先にDROP（定義順序の都合）
   ---------------------------------------------------------------------- */
DROP VIEW IF EXISTS `insurance_current_status`;
DROP VIEW IF EXISTS `insurance_current`;


/* ----------------------------------------------------------------------
   1) 本体テーブル
   ---------------------------------------------------------------------- */
DROP TABLE IF EXISTS `insurance_enrollments`;

CREATE TABLE IF NOT EXISTS `insurance_enrollments` (
  /* 識別子（AUTO_INCREMENT 主キー）
     - 歴史的背景により主キーは INT。
     - 監査・タイブレークに id を用いる（新しい=大きい）。 */
  `id`              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* 所有者（テナント）側識別 */
  `farm_user_id`    INT UNSIGNED NOT NULL,

  /* 加入者コード等（共済番号など8桁を想定） */
  `subscriber_code` CHAR(8)       NOT NULL,

  /* 入力ステータス（英語／改訂）
     - insured      : 加入として入力された状態
     - non_insured  : 非加入として入力された状態
     - unknown      : 不明/未判定
     - ※「今日有効かどうか」はビュー側（期間判定）で判断する。 */
  `status`          ENUM('insured','non_insured','unknown')
                      NOT NULL DEFAULT 'unknown',

  /* 期間（端NULL許容）
     - 両端NULLも許容（ビュー上は常に today-valid と扱う）。 */
  `start_date`      DATE NULL,
  `end_date`        DATE NULL,

  /* 会計年度（任意） */
  `fiscal_year`     YEAR NULL,

  /* 情報源・備考（任意） */
  `source_note`     VARCHAR(255) NULL,

  /* 無効化(取消)と理由
     - voided行はランキング対象から除外。 */
  `voided_at`       DATETIME NULL,
  `void_reason`     VARCHAR(255) NULL,

  /* v1p9: 楽観ロック & 論理削除 & 監査 */
  `row_version`     BIGINT UNSIGNED NOT NULL DEFAULT 1,  -- 更新毎に+1
  `deleted_at`      DATETIME NULL,                       -- 削除相当（最終手段）

  `created_by`      INT UNSIGNED NULL,                   -- 誰が作成したか（任意）
  `created_at`      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                  ON UPDATE CURRENT_TIMESTAMP,

  /* 期間検索・代表化前の絞り込みで有効 */
  INDEX `idx_user_dates` (`farm_user_id`, `start_date`, `end_date`),

  /* コード検索・監査用 */
  INDEX `idx_code` (`subscriber_code`),

  /* v1p9: 一覧最適化（差分同期や更新順ソートで有効） */
  KEY `idx_enroll_list` (`deleted_at`, `updated_at`, `id`),

  /* 期間整合性（NULLはスルー）
     - 一部MySQLでは CHECK が無視されるためアプリ層検証も併用推奨。 */
  CHECK (
    `start_date` IS NULL
    OR `end_date` IS NULL
    OR `start_date` <= `end_date`
  )
) ENGINE=InnoDB
  DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci;


/* ----------------------------------------------------------------------
   2) row_version 自動インクリメント用トリガ
      - アプリ側で管理する場合は本トリガは不要。
   ---------------------------------------------------------------------- */
DROP TRIGGER IF EXISTS `tr_insurance_enrollments_rowver_bu`;
DELIMITER $$
CREATE TRIGGER `tr_insurance_enrollments_rowver_bu`
BEFORE UPDATE ON `insurance_enrollments`
FOR EACH ROW
BEGIN
  /* 更新のたびに row_version を +1。
     競合検知: UPDATE ... WHERE row_version=:client_version で0件なら競合。 */
  SET NEW.`row_version` = OLD.`row_version` + 1;
END$$
DELIMITER ;


/* ----------------------------------------------------------------------
   3) 現在有効 or 最終記録 を1行に代表化するビュー
      名称: insurance_current
   ----------------------------------------------------------------------
   ■ 中間CTE ranked の中身
     - e.* : 元行の全カラム
     - is_today_valid : 「今日有効」なら1, それ以外は0
       判定: (start <= today OR start IS NULL) AND (end >= today OR end IS NULL)
       ※ 両端NULLも today-valid（最小入力でも“有効”）
     - rn : farm_user_id 内での順位（ROW_NUMBER）
       優先: [1]今日有効 → [2]end_date新しい → [3]start_date新しい → [4]id大きい
   ---------------------------------------------------------------------- */
CREATE VIEW `insurance_current` AS
WITH ranked AS (
  SELECT
    e.*,

    /* 今日有効？（端NULL許容） */
    CASE
      WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
       AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
      THEN 1 ELSE 0
    END AS is_today_valid,

    /* 代表順位（昇順）:
       0: today-valid（最優先）, 1: not today-valid（後回し）
       次に期限の新しさ→開始日の新しさ→新しいid を優先する。 */
    ROW_NUMBER() OVER (
      PARTITION BY e.farm_user_id
      ORDER BY
        CASE
          WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
           AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
          THEN 0 ELSE 1
        END,
        COALESCE(e.end_date,   '9999-12-31') DESC,
        COALESCE(e.start_date, '9999-12-31') DESC,
        e.id DESC
    ) AS rn

  FROM `insurance_enrollments` e
  /* ランキング対象外（取消・削除相当は除外） */
  WHERE e.voided_at IS NULL
    AND e.deleted_at IS NULL
)
SELECT
  r.*,

  /* 残日数: end_date が存在するときのみ算出（DATEDIFF=a-b）。 */
  CASE WHEN r.end_date IS NULL THEN NULL
       ELSE DATEDIFF(r.end_date, CURDATE())
  END AS days_to_end

FROM ranked r
/* 代表行のみ */
WHERE r.rn = 1;


/* ----------------------------------------------------------------------
   4) UI / 集計向け “最終ラベル” ビュー
      名称: insurance_current_status
   ----------------------------------------------------------------------
   ■ ラベル決定の優先順
     A) 今日有効                 → 'active'
     B) 期限切れ（end < today）  → 'renewal_overdue'
     C) 30日以内に期限到来       → 'renewal_due_soon'
     D) それ以外                 → 入力 status を踏襲
        - 'non_insured' / 'insured'
        - その他は 'unknown'
   ---------------------------------------------------------------------- */
CREATE VIEW `insurance_current_status` AS
SELECT
  c.farm_user_id,
  c.subscriber_code,
  c.start_date,
  c.end_date,
  c.days_to_end,

  /* 最終ラベル（英語／ENUM改訂に追従） */
  CASE
    WHEN c.is_today_valid = 1 THEN 'active'
    WHEN c.end_date IS NOT NULL AND c.end_date < CURDATE() THEN 'renewal_overdue'
    WHEN c.end_date IS NOT NULL
         AND c.end_date >= CURDATE()
         AND c.end_date <= (CURDATE() + INTERVAL 30 DAY) THEN 'renewal_due_soon'
    WHEN c.status = 'non_insured' THEN 'non_insured'
    WHEN c.status = 'insured'     THEN 'insured'
    ELSE 'unknown'
  END AS current_status

FROM `insurance_current` c;o
<<<END patches/archive/013.insu_enro_p019.sql>>>

<<<FILE patches/archive/020.fa_us_ind_mir_p020.1.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   VetDB — SoT + farmDB mirrors（users系の命名整理版・最終DDL）
   変更点:
     - farms から non_insured カラムとその索引を削除
   命名:
     - vet_users   : 獣医（VetDBユーザー）※farm_users同型＋clinic_branch_name
     - farm_users  : 農家ユーザー（VetDB側 SoT, 各farmに所属）
     - farmdb_farm_users_mirror : 農家ユーザー（FarmDB側の写し）※farm_usersと同型
   共通方針:
     - UUID=BINARY(16)（v7想定）/ utf8mb4_unicode_ci
     - row_version は BEFORE UPDATE で +1（mirrorの farmdb_farms_mirror は除外）
     - mirrorにはFK/CHECKは張らない
   ========================================================= */


/* =========================================================
   0) farms — SoT（個体/請求の基点）
   ========================================================= */
DROP TABLE IF EXISTS farms;
CREATE TABLE farms (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL,

  name              VARCHAR(120) NOT NULL,
  billing_name      VARCHAR(120) NULL,
  billing_address   VARCHAR(255) NULL,

  row_hash          CHAR(64) NULL,                  -- 任意：差分検出用

  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                  ON UPDATE CURRENT_TIMESTAMP,
  deleted_at        DATETIME NULL,
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_farms_uuid (uuid),
  KEY idx_farms_name (name),
  KEY idx_farms_list (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farms_bi_uuid_v7
BEFORE INSERT ON farms
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farms_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farms_bu_rowver_lockuuid
BEFORE UPDATE ON farms
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   1) vet_users — SoT（獣医：VetDBユーザー）
   - farm_users と同型の基本項目＋分院名 clinic_branch_name を追加
   ========================================================= */
DROP TABLE IF EXISTS vet_users;
CREATE TABLE vet_users (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL,

  display_name        VARCHAR(100) NOT NULL,
  email               VARCHAR(255) NULL,
  phone               VARCHAR(50)  NULL,
  role_label          VARCHAR(100) NULL,       -- 例: 院長/獣医師/スタッフ
  clinic_branch_name  VARCHAR(120) NULL,       -- 分院名（多院対応はしないためテキスト）

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                     ON UPDATE CURRENT_TIMESTAMP,
  deleted_at          DATETIME NULL,
  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_vet_users_uuid (uuid),
  KEY idx_vet_users_name  (display_name),
  KEY idx_vet_users_email (email),
  KEY idx_vet_users_list  (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_vet_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bi_uuid_v7
BEFORE INSERT ON vet_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_vet_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bu_rowver_lockuuid
BEFORE UPDATE ON vet_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;                -- UUIDは不変
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   2) farm_users — SoT（農家ユーザー：各farmに所属）
   ========================================================= */
DROP TABLE IF EXISTS farm_users;
CREATE TABLE farm_users (
  id             INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid           BINARY(16) NOT NULL,
  farm_uuid      BINARY(16) NOT NULL,           -- ↔ farms.uuid（所属farm）

  display_name   VARCHAR(100) NOT NULL,
  email          VARCHAR(255) NULL,
  phone          VARCHAR(50)  NULL,
  role_label     VARCHAR(100) NULL,             -- 例: 場長/経理/担当

  created_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                ON UPDATE CURRENT_TIMESTAMP,
  deleted_at     DATETIME NULL,
  row_version    BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_farm_users_uuid (uuid),
  KEY idx_farm_users_farm     (farm_uuid, display_name),
  KEY idx_farm_users_email    (email),
  KEY idx_farm_users_list     (deleted_at, updated_at, id),

  CONSTRAINT fk_farm_users_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bi_uuid_v7
BEFORE INSERT ON farm_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farm_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   3) farmDB mirrors — farms（読み取り専用）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farms_mirror;
CREATE TABLE farmdb_farms_mirror (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid               BINARY(16) NOT NULL,      -- farmDB側 farm.uuid
  name               VARCHAR(120) NOT NULL,
  billing_name       VARCHAR(120) NULL,
  billing_address    VARCHAR(255) NULL,

  deleted_at         DATETIME NULL,
  updated_at_source  DATETIME NULL,            -- farmDB側の更新時刻

  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                   ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_fdb_farms_uuid (uuid),
  KEY idx_fdb_farms_name (name),
  KEY idx_fdb_farms_updated (updated_at_source)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_farms_bi_uuid_v7
BEFORE INSERT ON farmdb_farms_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_farms_bu_lock_uuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_farms_bu_lock_uuid
BEFORE UPDATE ON farmdb_farms_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;   -- mirrorのUUIDは不変
END$$
DELIMITER ;


/* =========================================================
   4) farmDB mirrors — individuals（読み取り専用）
   - vetDB individuals（p014.4）と同型（FK/CHECKなし）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_individuals_mirror;
CREATE TABLE farmdb_individuals_mirror (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,
  farm_uuid             BINARY(16) NOT NULL,      -- FKは張らない
  user_uuid             BINARY(16) NULL,

  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,

  sire_name             VARCHAR(100) NULL,

  genetic_dam_uuid      BINARY(16) NULL,
  nursing_dam_uuid      BINARY(16) NULL,
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,

  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                   ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_fdb_individuals_ear_tag (ear_tag),
  KEY idx_fdb_individuals_farm_name   (farm_uuid, name),
  KEY idx_fdb_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_fdb_individuals_farm_status (farm_uuid, status),
  KEY idx_fdb_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_fdb_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_fdb_individuals_list        (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_individuals_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_individuals_bi_uuid_v7
BEFORE INSERT ON farmdb_individuals_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_individuals_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_individuals_bu_rowver_lockuuid
BEFORE UPDATE ON farmdb_individuals_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   5) farmDB mirrors — farm_users（読み取り専用・改称版）
   - 名称: farmdb_farm_users_mirror
   - 内容: vetDBの farm_users と同型（FKなし）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farm_users_mirror;
CREATE TABLE farmdb_farm_users_mirror (
  id             INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid           BINARY(16) NOT NULL,
  farm_uuid      BINARY(16) NOT NULL,           -- 所属farm（FKは張らない）

  display_name   VARCHAR(100) NOT NULL,
  email          VARCHAR(255) NULL,
  phone          VARCHAR(50)  NULL,
  role_label     VARCHAR(100) NULL,

  created_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                ON UPDATE CURRENT_TIMESTAMP,
  deleted_at     DATETIME NULL,
  row_version    BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_fdb_farm_users_uuid (uuid),
  KEY idx_fdb_farm_users_farm   (farm_uuid, display_name),
  KEY idx_fdb_farm_users_email  (email),
  KEY idx_fdb_farm_users_list   (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_farm_users_bi_uuid_v7
BEFORE INSERT ON farmdb_farm_users_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farmdb_farm_users_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   6) entity_links — SoT と farmDBミラーの対応表
   ========================================================= */
DROP TABLE IF EXISTS entity_links;
CREATE TABLE entity_links (
  id            BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  entity_type   ENUM('farm','individual','farm_user') NOT NULL,
  local_uuid    BINARY(16) NOT NULL,   -- VetDB（SoT）側 UUID
  remote_uuid   BINARY(16) NOT NULL,   -- farmDB（mirror）側 UUID
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_entity_link (entity_type, local_uuid, remote_uuid),
  KEY idx_entity_link_local  (entity_type, local_uuid),
  KEY idx_entity_link_remote (entity_type, remote_uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/archive/020.fa_us_ind_mir_p020.1.sql>>>

<<<FILE patches/archive/020.fa_us_ind_mir_p020.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   VetDB — SoT + farmDB mirrors（users系の命名整理版・最終DDL）
   命名:
     - vet_users   : 獣医（VetDBユーザー）※farm_users同型＋clinic_branch_name
     - farm_users  : 農家ユーザー（VetDB側 SoT, 各farmに所属）
     - farmdb_farm_users_mirror : 農家ユーザー（FarmDB側の写し）※farm_usersと同型
   共通方針:
     - UUID=BINARY(16)（v7想定）/ utf8mb4_unicode_ci
     - row_version は BEFORE UPDATE で +1（mirrorのfarm/farmdb_farms_mirrorは除外）
     - mirrorにはFK/CHECKは張らない（上流の一時的不整合を受け止める）
   ========================================================= */


/* =========================================================
   0) farms — SoT（個体/請求の基点）
   - non_insured: p014.3の方針を本文に反映
   ========================================================= */
DROP TABLE IF EXISTS farms;
CREATE TABLE farms (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL,

  name              VARCHAR(120) NOT NULL,
  billing_name      VARCHAR(120) NULL,
  billing_address   VARCHAR(255) NULL,
  non_insured       TINYINT(1)  NOT NULL DEFAULT 0,  -- 0:加入/1:非加入（UI既定）

  row_hash          CHAR(64) NULL,                  -- 任意：差分検出用

  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                  ON UPDATE CURRENT_TIMESTAMP,
  deleted_at        DATETIME NULL,
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_farms_uuid (uuid),
  KEY idx_farms_name (name),
  KEY idx_farms_non_insured (non_insured),
  KEY idx_farms_list (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farms_bi_uuid_v7
BEFORE INSERT ON farms
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farms_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farms_bu_rowver_lockuuid
BEFORE UPDATE ON farms
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   1) vet_users — SoT（獣医：VetDBユーザー）
   - farm_users と同型の基本項目＋分院名 clinic_branch_name を追加
   ========================================================= */
DROP TABLE IF EXISTS vet_users;
CREATE TABLE vet_users (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL,

  display_name        VARCHAR(100) NOT NULL,
  email               VARCHAR(255) NULL,
  phone               VARCHAR(50)  NULL,
  role_label          VARCHAR(100) NULL,       -- 例: 院長/獣医師/スタッフ
  clinic_branch_name  VARCHAR(120) NULL,       -- 分院名（多院対応はしないためテキスト）

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                     ON UPDATE CURRENT_TIMESTAMP,
  deleted_at          DATETIME NULL,
  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_vet_users_uuid (uuid),
  KEY idx_vet_users_name  (display_name),
  KEY idx_vet_users_email (email),
  KEY idx_vet_users_list  (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_vet_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bi_uuid_v7
BEFORE INSERT ON vet_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_vet_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bu_rowver_lockuuid
BEFORE UPDATE ON vet_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;                -- UUIDは不変
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   2) farm_users — SoT（農家ユーザー：各farmに所属）
   ========================================================= */
DROP TABLE IF EXISTS farm_users;
CREATE TABLE farm_users (
  id             INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid           BINARY(16) NOT NULL,
  farm_uuid      BINARY(16) NOT NULL,           -- ↔ farms.uuid（所属farm）

  display_name   VARCHAR(100) NOT NULL,
  email          VARCHAR(255) NULL,
  phone          VARCHAR(50)  NULL,
  role_label     VARCHAR(100) NULL,             -- 例: 場長/経理/担当

  created_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                ON UPDATE CURRENT_TIMESTAMP,
  deleted_at     DATETIME NULL,
  row_version    BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_farm_users_uuid (uuid),
  KEY idx_farm_users_farm     (farm_uuid, display_name),
  KEY idx_farm_users_email    (email),
  KEY idx_farm_users_list     (deleted_at, updated_at, id),

  CONSTRAINT fk_farm_users_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bi_uuid_v7
BEFORE INSERT ON farm_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farm_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   3) farmDB mirrors — farms（読み取り専用）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farms_mirror;
CREATE TABLE farmdb_farms_mirror (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid               BINARY(16) NOT NULL,      -- farmDB側 farm.uuid
  name               VARCHAR(120) NOT NULL,
  billing_name       VARCHAR(120) NULL,
  billing_address    VARCHAR(255) NULL,

  deleted_at         DATETIME NULL,
  updated_at_source  DATETIME NULL,            -- farmDB側の更新時刻

  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                   ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_fdb_farms_uuid (uuid),
  KEY idx_fdb_farms_name (name),
  KEY idx_fdb_farms_updated (updated_at_source)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_farms_bi_uuid_v7
BEFORE INSERT ON farmdb_farms_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_farms_bu_lock_uuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_farms_bu_lock_uuid
BEFORE UPDATE ON farmdb_farms_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;   -- mirrorのUUIDは不変
END$$
DELIMITER ;


/* =========================================================
   4) farmDB mirrors — individuals（読み取り専用）
   - vetDB individuals（p014.4）と同型（FK/CHECKなし）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_individuals_mirror;
CREATE TABLE farmdb_individuals_mirror (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,
  farm_uuid             BINARY(16) NOT NULL,      -- FKは張らない
  user_uuid             BINARY(16) NULL,

  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,

  sire_name             VARCHAR(100) NULL,

  genetic_dam_uuid      BINARY(16) NULL,
  nursing_dam_uuid      BINARY(16) NULL,
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,

  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                   ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_fdb_individuals_ear_tag (ear_tag),
  KEY idx_fdb_individuals_farm_name   (farm_uuid, name),
  KEY idx_fdb_individuals_farm_birth  (farm_uuid, birth_date),
  KEY idx_fdb_individuals_farm_status (farm_uuid, status),
  KEY idx_fdb_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_fdb_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_fdb_individuals_list        (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_individuals_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_individuals_bi_uuid_v7
BEFORE INSERT ON farmdb_individuals_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_individuals_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_individuals_bu_rowver_lockuuid
BEFORE UPDATE ON farmdb_individuals_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   5) farmDB mirrors — farm_users（読み取り専用・改称版）
   - 名称: farmdb_farm_users_mirror
   - 内容: vetDBの farm_users と同型（FKなし）
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farm_users_mirror;
CREATE TABLE farmdb_farm_users_mirror (
  id             INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid           BINARY(16) NOT NULL,
  farm_uuid      BINARY(16) NOT NULL,           -- 所属farm（FKは張らない）

  display_name   VARCHAR(100) NOT NULL,
  email          VARCHAR(255) NULL,
  phone          VARCHAR(50)  NULL,
  role_label     VARCHAR(100) NULL,

  created_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                                ON UPDATE CURRENT_TIMESTAMP,
  deleted_at     DATETIME NULL,
  row_version    BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_fdb_farm_users_uuid (uuid),
  KEY idx_fdb_farm_users_farm   (farm_uuid, display_name),
  KEY idx_fdb_farm_users_email  (email),
  KEY idx_fdb_farm_users_list   (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_fdb_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_fdb_farm_users_bi_uuid_v7
BEFORE INSERT ON farmdb_farm_users_mirror
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_fdb_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_fdb_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farmdb_farm_users_mirror
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
   6) entity_links — SoT と farmDBミラーの対応表
   ========================================================= */
DROP TABLE IF EXISTS entity_links;
CREATE TABLE entity_links (
  id            BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  entity_type   ENUM('farm','individual','farm_user') NOT NULL,
  local_uuid    BINARY(16) NOT NULL,   -- VetDB（SoT）側 UUID
  remote_uuid   BINARY(16) NOT NULL,   -- farmDB（mirror）側 UUID
  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_entity_link (entity_type, local_uuid, remote_uuid),
  KEY idx_entity_link_local  (entity_type, local_uuid),
  KEY idx_entity_link_remote (entity_type, remote_uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/archive/020.fa_us_ind_mir_p020.sql>>>

<<<FILE patches/archive/025.receipt-p017.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   Receipts（下書き→確定スナップ）— 統合DDL（意図付き）
   ---------------------------------------------------------
   ■全体設計方針
     - 「下書き(receipt_header_drafts)」で集計・編集を行い、
       発行(issued)時に不変スナップ（receipt_headers / receipt_checkups / receipt_items）を作成。
     - 下書きは“可変”：row_version / deleted_at を持つ（強い整合が必要）。
     - スナップは“不変”：論理削除なし。取消は status='voided' + voided_at で扱う。
     - UI側ルール：checkups/ checkup_items の「手動付け替えUI」を出さない前提。
         → 付け替えによる矛盾ガードTRIGGERは置かない（簡潔＆運用で防止）。
     - 冪等性：発行処理の再実行・並行実行に備え、スナップ側に UNIQUE を付与。
       （INSERT IGNORE と組み合わせると再実行に強い）

   ■スナップの対象集合
     - 「issued の瞬間」に、draft_uuid に紐づく checkups 配下の checkup_items をそのまま取り込む。
       （= checkups.receipt_header_drafts_uuid がキー。item直付けは現行運用では使用しない）

   ■UUID／ストレージ
     - UUIDは BINARY(16) の v7 を使用（uuid_v7_bin()）。見出しキーはAUTO_INCREMENT + uuid の二段。
     - 文字コードは utf8mb4、COLLATEは utf8mb4_unicode_ci、ROW_FORMAT=DYNAMIC 推奨。

   ■月末請求
     - 集計基準は receipt_headers（非void）を推奨。
       drafts は WIP/進捗管理用。

   ■このDDLに含む内容
     1) receipt_header_drafts（下書きヘッダ）
     2) 既存 checkups / checkup_items に draft 直付けカラムの追加（ON DELETE SET NULL）
        ※ 現行の抽出は checkups のみ参照。item側は将来拡張・整合性観察用。
     3) receipt_headers / receipt_checkups / receipt_items（不変スナップ）
        - 重複防止 UNIQUE を定義
   ========================================================= */

/* --- 再デプロイ安全化：トリガを先に、次いで子→親の順でDROP --- */
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bu_rowver;
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_headers_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_uuid_v7;

DROP TABLE IF EXISTS receipt_items;
DROP TABLE IF EXISTS receipt_checkups;
DROP TABLE IF EXISTS receipt_headers;
DROP TABLE IF EXISTS receipt_header_drafts;

/* =========================================================
   1) 下書きヘッダ：集計の本体（可変）
   ---------------------------------------------------------
   - 集計列（点/円/税/負担）を保持し、発行時にスナップへコピー。
   - status: open / closed / issued
     ・issued_at / issued_receipt_uuid でスナップの対応関係を残す（相互追跡用）。
   - row_version: 楽観ロック。UIは If-Match 的更新を推奨。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_header_drafts (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（下書きの識別）

  /* 任意のスコープ（印字や絞り込み用。FKは貼らず弱リンク） */
  farm_uuid             BINARY(16) NULL,
  title                 VARCHAR(120) NULL,
  note                  VARCHAR(255) NULL,

  /* 状態遷移（発行で issued に） */
  status                ENUM('open','closed','issued') NOT NULL DEFAULT 'open',
  issued_at             DATETIME NULL,                               -- issued 遷移時刻
  issued_by_user_id     INT UNSIGNED NULL,
  issued_receipt_uuid   BINARY(16) NULL,                             -- 対応する receipt_headers.uuid（作成後にセット）

  /* クリニック設定スナップ：行計算・集計の基準 */
  yen_per_point         DECIMAL(8,2) NOT NULL DEFAULT 10.00,         -- 1点=10円 等
  copay_rate            DECIMAL(5,4) NOT NULL DEFAULT 0.1000,        -- 10% は 0.1000
  tax_rounding          ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',

  /* 集計（税抜→税→税込） */
  total_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 自由価格（税抜）
  subtotal_yen          INT UNSIGNED NOT NULL DEFAULT 0,             -- 点換算円 + 自由価格（税抜）
  tax_yen               INT UNSIGNED NOT NULL DEFAULT 0,
  total_insurance_yen   INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（保険）
  total_private_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（自由）
  patient_copay_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 患者負担
  insurer_pay_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 保険者負担

  /* 監査（可変テーブルなので row_version / deleted_at を保持） */
  created_by            INT UNSIGNED NULL,
  updated_by            INT UNSIGNED NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at            DATETIME NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化 */
  KEY idx_receipt_drafts_list (deleted_at, updated_at, id),
  KEY idx_receipt_drafts_farm (farm_uuid, deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bi_uuid_v7
BEFORE INSERT ON receipt_header_drafts
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bu_rowver
BEFORE UPDATE ON receipt_header_drafts
FOR EACH ROW
BEGIN
  /* 楽観ロック用 row_version を自動インクリメント */
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;

/* =========================================================
   2) 既存2表に直付け（UIで付替え操作なし／ドラフト削除で自動デタッチ）
   ---------------------------------------------------------
   - checkups.receipt_header_drafts_uuid:
       スナップ抽出の起点（必須）。発行時は「このdraftにぶら下がるcheckups配下のitems」を採用。
   - checkup_items.receipt_header_drafts_uuid:
       現行抽出では未使用（将来の部分請求/観察用/クエリ補助に備える）。
       ※ 追加が不要ならこのALTERは省いても動作します。
   - ON DELETE SET NULL: draft 削除時に自動デタッチ（UIでは“削除してから再紐付け”という運用に効く）。
   ========================================================= */
ALTER TABLE checkups
  ADD COLUMN receipt_header_drafts_uuid BINARY(16) NULL AFTER individual_uuid,
  ADD KEY idx_checkups_rhd (receipt_header_drafts_uuid, id),
  ADD CONSTRAINT fk_checkups_rhd
    FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE checkup_items
  ADD COLUMN receipt_header_drafts_uuid BINARY(16) NULL AFTER checkup_uuid,
  ADD KEY idx_ckpitems_rhd (receipt_header_drafts_uuid, id),
  ADD CONSTRAINT fk_ckpitems_rhd
    FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL;

/* =========================================================
   3) 確定ヘッダ：不変スナップ（弱リンク）
   ---------------------------------------------------------
   - printed/voided を status で持つ（未印刷はNULL）。voidedは取消記録。
   - クリニック設定・集計はdraftからコピー（不変化）。
   - 月末請求の集計基準として使用（voided除外）。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_headers (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（スナップの識別）
  farm_uuid           BINARY(16) NULL,                             -- 弱リンク（将来の参照用）
  receipt_no          VARCHAR(40) NULL UNIQUE,                     -- 任意の対外発番（UI採番）
  title               VARCHAR(120) NULL,
  note                VARCHAR(255) NULL,

  issued_at           DATETIME NOT NULL,                           -- 発行日時（スナップ時刻）
  issued_by_user_id   INT UNSIGNED NULL,

  status              ENUM('printed','voided') NULL DEFAULT NULL,  -- 未印刷(NULL)/印刷済/取消
  printed_at          DATETIME NULL,
  printed_count       INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at           DATETIME NULL,
  void_reason         VARCHAR(255) NULL,
  voided_by_user_id   INT UNSIGNED NULL,

  /* クリニック設定スナップ（固定） */
  yen_per_point       DECIMAL(8,2) NOT NULL,
  copay_rate          DECIMAL(5,4) NOT NULL,
  tax_rounding        ENUM('floor','round','ceil') NOT NULL,

  /* 集計スナップ（固定） */
  total_b_points      INT UNSIGNED NOT NULL,
  total_a_points      INT UNSIGNED NOT NULL,
  total_price_yen     INT UNSIGNED NOT NULL,
  subtotal_yen        INT UNSIGNED NOT NULL,
  tax_yen             INT UNSIGNED NOT NULL,
  total_insurance_yen INT UNSIGNED NOT NULL,
  total_private_yen   INT UNSIGNED NOT NULL,
  patient_copay_yen   INT UNSIGNED NOT NULL,
  insurer_pay_yen     INT UNSIGNED NOT NULL,

  /* 任意：印字/レイアウト用のクリニック情報 */
  clinic_snapshot_json JSON NULL,

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 代表的な検索用インデックス */
  KEY idx_rcpt_hdr_issued (issued_at, id),
  KEY idx_rcpt_hdr_status (status, issued_at, id),
  KEY idx_rcpt_hdr_farm   (farm_uuid, issued_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_headers_bi_uuid_v7
BEFORE INSERT ON receipt_headers
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   4) 確定：チェックアップスナップ（不変）
   ---------------------------------------------------------
   - receipt_checkups.uuid は items から参照するため “列UUID” を持つ。
   - source_checkup_uuid には元の checkups.uuid を保存（監査・追跡）。
   - UNIQUE(receipt_header_uuid, source_checkup_uuid) で
     同一レシート内の二重取り込みを防止（発行再実行への保険）。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_checkups (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7（items から参照）
  receipt_header_uuid BINARY(16) NOT NULL,                         -- ↔ receipt_headers.uuid（弱リンク）
  source_checkup_uuid BINARY(16) NOT NULL,                         -- 由来：checkups.uuid
  checkup_at          DATETIME NULL,                               -- 任意：診療日時など
  individual_uuid     BINARY(16) NULL,                             -- 任意：印字補助
  individual_label    VARCHAR(120) NULL,                           -- 任意：個体表示名 等
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一ヘッダ内で同一sourceは一度だけ） */
  UNIQUE KEY uq_rcpt_hdr_src (receipt_header_uuid, source_checkup_uuid),

  KEY idx_rcpt_ckp_hdr   (receipt_header_uuid, id),
  KEY idx_rcpt_ckp_src   (source_checkup_uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_checkups_bi_uuid_v7
BEFORE INSERT ON receipt_checkups
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番（items が参照するため必須） */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   5) 確定：行為明細スナップ（不変）
   ---------------------------------------------------------
   - receipt_items は receipt_checkups.uuid を参照（ヘッダは辿れる）。
   - source_checkup_item_id に元の checkup_items.id を保存（監査）。
   - UNIQUE(receipt_checkup_uuid, source_checkup_item_id) で
     同一チェックアップスナップ内の二重取り込みを防止。
   - 計算列（subtotal_yen/tax_yen/total_yen）は発行時に再計算し値保存。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  receipt_checkup_uuid   BINARY(16) NOT NULL,                       -- ↔ receipt_checkups.uuid（弱リンク）
  source_checkup_item_id INT UNSIGNED NOT NULL,                     -- 由来：checkup_items.id

  /* マスタ/入力の当時値スナップ（印字・再現に必要な範囲を保持） */
  description            VARCHAR(255) NOT NULL,                      -- 例: 処置/薬品名
  qty_unit               VARCHAR(32)  NULL,                          -- 例: mL, 回, 錠...
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  /* 点数/自由価格の両立 */
  pay_type               ENUM('insurance','private') NOT NULL DEFAULT 'insurance',
  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  /* 税と金額（行で算出→ヘッダで合算） */
  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,            -- 税抜
  tax_yen                INT UNSIGNED NOT NULL DEFAULT 0,
  total_yen              INT UNSIGNED NOT NULL DEFAULT 0,            -- 税込

  note                   VARCHAR(255) NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一チェックアップスナップ内の同一sourceは一度だけ） */
  UNIQUE KEY uq_rcptitem_ckp_src (receipt_checkup_uuid, source_checkup_item_id),

  KEY idx_rcpt_items_ckpuuid (receipt_checkup_uuid, id),
  KEY idx_rcpt_items_source  (source_checkup_item_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/archive/025.receipt-p017.sql>>>

<<<FILE patches/archive/025.receipt_p017.1.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   Receipts（下書き→確定スナップ）— 統合DDL（意図付き）
   ---------------------------------------------------------
   ■全体設計方針
     - 「下書き(receipt_header_drafts)」で集計・編集を行い、
       発行(issued)時に不変スナップ（receipt_headers / receipt_checkups / receipt_items）を作成。
     - 下書きは“可変”：row_version / deleted_at を持つ（強い整合が必要）。
     - スナップは“不変”：論理削除なし。取消は status='voided' + voided_at で扱う。
     - UI側ルール：checkups/ checkup_items の「手動付け替えUI」を出さない前提。
       → 付け替えによる矛盾ガードTRIGGERは置かない（簡潔＆運用で防止）。
     - 冪等性：発行処理の再実行・並行実行に備え、スナップ側に UNIQUE を付与。
       （INSERT IGNORE と組み合わせると再実行に強い）

   ■スナップの対象集合
     - 「issued の瞬間」に、:draft_uuid に紐づく checkups 配下の checkup_items をそのまま取り込む。
       （= checkups.receipt_header_drafts_uuid がキー。item直付け列は現行では未使用）

   ■UUID／ストレージ
     - UUIDは BINARY(16) v7（uuid_v7_bin()）。文字コードは utf8mb4 / utf8mb4_unicode_ci。
   ========================================================= */

/* --- 再デプロイ安全化：トリガを先に、次いで子→親の順でDROP --- */
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bu_rowver;
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_headers_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_uuid_v7;

DROP TABLE IF EXISTS receipt_items;
DROP TABLE IF EXISTS receipt_checkups;
DROP TABLE IF EXISTS receipt_headers;
DROP TABLE IF EXISTS receipt_header_drafts;

/* =========================================================
   1) 下書きヘッダ：集計の本体（可変）
   ---------------------------------------------------------
   - 集計列（点/円/税/負担）を保持し、発行時にスナップへコピー。
   - status: open / closed / issued
     ・issued_at / issued_receipt_uuid でスナップの対応関係を残す（相互追跡用）。
   - row_version: 楽観ロック。UIは If-Match 的更新を推奨。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_header_drafts (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（下書きの識別）

  /* 任意のスコープ（印字や絞り込み用。FKは貼らず弱リンク） */
  farm_uuid             BINARY(16) NULL,
  title                 VARCHAR(120) NULL,
  note                  VARCHAR(255) NULL,

  /* 状態遷移（発行で issued に） */
  status                ENUM('open','closed','issued') NOT NULL DEFAULT 'open',
  issued_at             DATETIME NULL,                               -- issued 遷移時刻
  issued_by_user_id     INT UNSIGNED NULL,
  issued_receipt_uuid   BINARY(16) NULL,                             -- 対応する receipt_headers.uuid（作成後にセット）

  /* クリニック設定スナップ：行計算・集計の基準 */
  yen_per_point         DECIMAL(8,2) NOT NULL DEFAULT 10.00,         -- 例: 1点=10円
  copay_rate            DECIMAL(5,4) NOT NULL DEFAULT 0.1000,        -- 例: 10% は 0.1000
  tax_rounding          ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',

  /* 集計（税抜→税→税込） */
  total_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 自由価格（税抜）
  subtotal_yen          INT UNSIGNED NOT NULL DEFAULT 0,             -- 点換算円 + 自由価格（税抜）
  tax_yen               INT UNSIGNED NOT NULL DEFAULT 0,
  total_insurance_yen   INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（保険）
  total_private_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（自由）
  patient_copay_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 患者負担
  insurer_pay_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 保険者負担

  /* 監査（可変テーブルなので row_version / deleted_at を保持） */
  created_by            INT UNSIGNED NULL,
  updated_by            INT UNSIGNED NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at            DATETIME NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化 */
  KEY idx_receipt_drafts_list (deleted_at, updated_at, id),
  KEY idx_receipt_drafts_farm (farm_uuid, deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bi_uuid_v7
BEFORE INSERT ON receipt_header_drafts
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bu_rowver
BEFORE UPDATE ON receipt_header_drafts
FOR EACH ROW
BEGIN
  /* 楽観ロック用 row_version を自動インクリメント */
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;

/* =========================================================
   2) （ここでは ALTER を除外）既存表への付加は別ファイルで管理
   ---------------------------------------------------------
   - ① checkups ALTER と ② checkup_items ALTER は本DDLから除外。
   - マイグレーション順を制御しやすくするため、スキーマ作成と ALTER を分離。
   ========================================================= */

/* =========================================================
   3) 確定ヘッダ：不変スナップ（弱リンク）
   ---------------------------------------------------------
   - printed/voided を status で持つ（未印刷はNULL）。voidedは取消記録。
   - クリニック設定・集計は draft からコピー（不変化）。
   - 月末請求の集計基準として使用（voided除外）。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_headers (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（スナップの識別）
  farm_uuid           BINARY(16) NULL,                             -- 弱リンク（将来の参照用）
  receipt_no          VARCHAR(40) NULL UNIQUE,                     -- 任意の対外発番（UI採番）
  title               VARCHAR(120) NULL,
  note                VARCHAR(255) NULL,

  issued_at           DATETIME NOT NULL,                           -- 発行日時（スナップ時刻）
  issued_by_user_id   INT UNSIGNED NULL,

  status              ENUM('printed','voided') NULL DEFAULT NULL,  -- 未印刷(NULL)/印刷済/取消
  printed_at          DATETIME NULL,
  printed_count       INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at           DATETIME NULL,
  void_reason         VARCHAR(255) NULL,
  voided_by_user_id   INT UNSIGNED NULL,

  /* クリニック設定スナップ（固定） */
  yen_per_point       DECIMAL(8,2) NOT NULL,
  copay_rate          DECIMAL(5,4) NOT NULL,
  tax_rounding        ENUM('floor','round','ceil') NOT NULL,

  /* 集計スナップ（固定） */
  total_b_points      INT UNSIGNED NOT NULL,
  total_a_points      INT UNSIGNED NOT NULL,
  total_price_yen     INT UNSIGNED NOT NULL,
  subtotal_yen        INT UNSIGNED NOT NULL,
  tax_yen             INT UNSIGNED NOT NULL,
  total_insurance_yen INT UNSIGNED NOT NULL,
  total_private_yen   INT UNSIGNED NOT NULL,
  patient_copay_yen   INT UNSIGNED NOT NULL,
  insurer_pay_yen     INT UNSIGNED NOT NULL,

  /* 任意：印字/レイアウト用のクリニック情報 */
  clinic_snapshot_json JSON NULL,

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 代表的な検索用インデックス */
  KEY idx_rcpt_hdr_issued (issued_at, id),
  KEY idx_rcpt_hdr_status (status, issued_at, id),
  KEY idx_rcpt_hdr_farm   (farm_uuid, issued_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_headers_bi_uuid_v7
BEFORE INSERT ON receipt_headers
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   4) 確定：チェックアップスナップ（不変）
   ---------------------------------------------------------
   - receipt_checkups.uuid は items から参照するため “列UUID” を持つ。
   - source_checkup_uuid には元の checkups.uuid を保存（監査・追跡）。
   - UNIQUE(receipt_header_uuid, source_checkup_uuid) で
     同一レシート内の二重取り込みを防止（発行再実行への保険）。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_checkups (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7（items から参照）
  receipt_header_uuid BINARY(16) NOT NULL,                         -- ↔ receipt_headers.uuid（弱リンク）
  source_checkup_uuid BINARY(16) NOT NULL,                         -- 由来：checkups.uuid
  checkup_at          DATETIME NULL,                               -- 任意：診療日時など
  individual_uuid     BINARY(16) NULL,                             -- 任意：印字補助
  individual_label    VARCHAR(120) NULL,                           -- 任意：個体表示名 等
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一ヘッダ内で同一sourceは一度だけ） */
  UNIQUE KEY uq_rcpt_hdr_src (receipt_header_uuid, source_checkup_uuid),

  KEY idx_rcpt_ckp_hdr   (receipt_header_uuid, id),
  KEY idx_rcpt_ckp_src   (source_checkup_uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_checkups_bi_uuid_v7
BEFORE INSERT ON receipt_checkups
FOR EACH ROW
BEGIN
  /* uuid未指定なら v7 を自動採番（items が参照するため必須） */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   5) 確定：行為明細スナップ（不変）
   ---------------------------------------------------------
   - receipt_items は receipt_checkups.uuid を参照（ヘッダは辿れる）。
   - source_checkup_item_id に元の checkup_items.id を保存（監査）。
   - UNIQUE(receipt_checkup_uuid, source_checkup_item_id) で
     同一チェックアップスナップ内の二重取り込みを防止。
   - 計算列（subtotal_yen/tax_yen/total_yen）は発行時に再計算し値保存。
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  receipt_checkup_uuid   BINARY(16) NOT NULL,                       -- ↔ receipt_checkups.uuid（弱リンク）
  source_checkup_item_id INT UNSIGNED NOT NULL,                     -- 由来：checkup_items.id

  /* マスタ/入力の当時値スナップ（印字・再現に必要な範囲を保持） */
  description            VARCHAR(255) NOT NULL,                      -- 例: 処置/薬品名
  qty_unit               VARCHAR(32)  NULL,                          -- 例: mL, 回, 錠...
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  /* 点数/自由価格の両立 */
  pay_type               ENUM('insurance','private') NOT NULL DEFAULT 'insurance',
  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  /* 税と金額（行で算出→ヘッダで合算） */
  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,            -- 税抜
  tax_yen                INT UNSIGNED NOT NULL DEFAULT 0,
  total_yen              INT UNSIGNED NOT NULL DEFAULT 0,            -- 税込

  note                   VARCHAR(255) NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一チェックアップスナップ内の同一sourceは一度だけ） */
  UNIQUE KEY uq_rcptitem_ckp_src (receipt_checkup_uuid, source_checkup_item_id),

  KEY idx_rcpt_items_ckpuuid (receipt_checkup_uuid, id),
  KEY idx_rcpt_items_source  (source_checkup_item_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/archive/025.receipt_p017.1.sql>>>

<<<FILE patches/_003.visits.draft.sql>>>
/* ---------------------------------------------------------
   visits — 訪問記録（予定ではなく実施ログ）
   方針:,
     - UUIDは BINARY(16) / UUIDv7 を BEFORE INSERT で自動採番
     - UTC保存（表示はアプリ側でTZ変換）
     - row_version による楽観ロック（BEFORE UPDATEで+1）
     - list用複合索引 (deleted_at, updated_at, id)
     - FlowA: 個体は checkups 側で visit に紐付ける（visitsには individual_uuid を置かない）
   依存:
     - uuid_v7_bin(), uuid_bin_to_hex(), uuid_hex_to_bin() は p012.2 で作成済み想定
   --------------------------------------------------------- */

DROP TABLE IF EXISTS `visits`;

CREATE TABLE IF NOT EXISTS `visits` (
  `id`               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT 'サロゲートID',
  `uuid`             BINARY(16) NOT NULL UNIQUE COMMENT 'UUIDv7 (bin16)',
  `farm_uuid`        BINARY(16) NOT NULL COMMENT '訪問先Farm（FKは任意、別DBミラー可）',

  `visit_started_at` DATETIME   NOT NULL COMMENT '訪問開始(UTC)',
  `visit_ended_at`   DATETIME   NULL     COMMENT '訪問終了(UTC)',
  `location_text`    VARCHAR(180) NULL   COMMENT '地名/目印（任意）',
  `note`             VARCHAR(255) NULL   COMMENT '簡易メモ（任意）',

  `row_version`      BIGINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '楽観ロック用',
  `deleted_at`       DATETIME NULL,
  `created_at`       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 一覧/範囲クエリ最適化
  INDEX `idx_visits_farm_started` (`farm_uuid`, `visit_started_at`),
  INDEX `idx_visits_started` (`visit_started_at`),
  KEY   `idx_visits_list` (`deleted_at`, `updated_at`, `id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  COMMENT='Farm単位の訪問実施ログ。個体はcheckups経由で紐付ける';

/* ---------- トリガ: UUID自動付与（UUIDv7/bin16） ---------- */
DROP TRIGGER IF EXISTS `bi_visits_uuid`;
DELIMITER $$
CREATE TRIGGER `bi_visits_uuid`
BEFORE INSERT ON `visits`
FOR EACH ROW
BEGIN
  -- uuid未指定なら自動採番（全ゼロ対策も含む）
  IF NEW.`uuid` IS NULL OR NEW.`uuid` = 0x00000000000000000000000000000000 THEN
    SET NEW.`uuid` = uuid_v7_bin();
  END IF;

  -- visit_started_at未指定なら現在UTCで初期化
  IF NEW.`visit_started_at` IS NULL THEN
    SET NEW.`visit_started_at` = UTC_TIMESTAMP();
  END IF;
END$$
DELIMITER ;

/* ---------- トリガ: row_version自動インクリメント ---------- */
DROP TRIGGER IF EXISTS `bu_visits_rowver`;
DELIMITER $$
CREATE TRIGGER `bu_visits_rowver`
BEFORE UPDATE ON `visits`
FOR EACH ROW
BEGIN
  SET NEW.`row_version` = OLD.`row_version` + 1;
END$$
DELIMITER ;

/* ----（任意）デバッグ用ビュー：hex表記でUUIDを確認したい場合 ----
DROP VIEW IF EXISTS v_visits_text;
CREATE VIEW v_visits_text AS
SELECT
  id,
  LOWER(uuid_bin_to_hex(uuid)) AS uuid,
  LOWER(uuid_bin_to_hex(farm_uuid)) AS farm_uuid,
  visit_started_at, visit_ended_at,
  location_text, note,
  row_version, deleted_at, created_at, updated_at
FROM visits;
-- ---------------------------------------------------------- */
<<<END patches/_003.visits.draft.sql>>>

<<<FILE patches/_checkup_tr_individuals_bu_rowver.sql>>>
/* 131_checkup_tr_individuals_bu_rowver.sql */
-- @phase: trigger
-- @provides: trigger:tr_individuals_bu_rowver
-- @requires: table:individuals

DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;

DELIMITER $$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  /* 履歴固定方針のため clinic_uuid は自動更新しない（必要時はアプリで明示更新） */
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;
<<<END patches/_checkup_tr_individuals_bu_rowver.sql>>>

<<<FILE patches/A010_checkups_create_receipt_header_drafts.sql>>>
/* checkups分割時に混入したスタブのためアーカイブ。010_checkup_create_receipt_header_drafts.sql */
-- @phase: create
-- @provides: table:receipt_header_drafts
-- @requires:

DROP TABLE IF EXISTS receipt_header_drafts;

CREATE TABLE receipt_header_drafts (
  id   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid BINARY(16) NOT NULL UNIQUE,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/A010_checkups_create_receipt_header_drafts.sql>>>

<<<FILE patches/checkups_desease_chart_p6.1.sql>>>
SET NAMES utf8mb4;

-- 任意：病名マスタ（既存があれば作成不要）
CREATE TABLE IF NOT EXISTS disease_master (
  id    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  code  VARCHAR(32) NOT NULL UNIQUE,
  name  VARCHAR(255) NOT NULL,
  INDEX idx_name (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 1) カルテヘッダ（請求単位＋各種スナップショット）
CREATE TABLE IF NOT EXISTS chart_headers (
  id                       INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                     CHAR(36) NOT NULL UNIQUE,

  -- 紐付け
  individual_uuid          CHAR(36) NOT NULL,      -- ↔ individuals.uuid
  farm_uuid                CHAR(36) NOT NULL,      -- ↔ farms.uuid
  insurance_enrollment_id  INT UNSIGNED NULL,      -- ↔ insurance_enrollments.id（任意）

  -- 期間識別（保険年度）
  fiscal_year              YEAR NOT NULL,
  claim_month              TINYINT UNSIGNED NOT NULL,  -- 1-12

  -- 転帰・日付・回数
  outcome_code             TINYINT UNSIGNED NOT NULL,  -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date               DATE NULL,                  -- 発病
  first_visit_date         DATE NULL,                  -- 初診
  last_visit_date          DATE NULL,                  -- 終診
  outcome_date             DATE NULL,                  -- 転帰
  visit_count              INT UNSIGNED NOT NULL DEFAULT 0,   -- カルテ内 checkups 件数（閉帳時に確定）

  -- 主訴・自由診断名
  chief_complaint          VARCHAR(255) NULL,
  diagnosis_text           VARCHAR(255) NULL,

  -- 病名（第1〜第3を直書きスナップショット）
  disease1_code            VARCHAR(32)  NULL,
  disease1_name            VARCHAR(255) NULL,
  disease2_code            VARCHAR(32)  NULL,
  disease2_name            VARCHAR(255) NULL,
  disease3_code            VARCHAR(32)  NULL,
  disease3_name            VARCHAR(255) NULL,

  -- 集計（閉帳時に確定）
  total_b_points           INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points           INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen          INT UNSIGNED NOT NULL DEFAULT 0,   -- 自費合計
  subtotal_yen             INT UNSIGNED NOT NULL DEFAULT 0,   -- 点換算＋自費
  patient_copay_yen        INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen          INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                  INT UNSIGNED NOT NULL DEFAULT 0,

  -- ステータス
  status ENUM('draft','closed','issued','voided') NOT NULL DEFAULT 'draft',
  closed_at                DATETIME NULL,
  issued_at                DATETIME NULL,
  printed_at               DATETIME NULL,
  printed_count            INT UNSIGNED NOT NULL DEFAULT 0,

  -- ▼ 農家スナップショット（farms 準拠）
  farm_name                VARCHAR(255) NULL,
  farm_address             VARCHAR(255) NULL,
  farm_insurance_number    VARCHAR(64)  NULL,

  -- ▼ 個体スナップショット（individuals 準拠）
  animal_name              VARCHAR(255) NULL,
  ear_tag                  VARCHAR(32)  NULL,
  dam_name                 VARCHAR(255) NULL,
  dam_ear_tag              VARCHAR(32)  NULL,
  breed_code               VARCHAR(32)  NULL,
  kyosai_purpose_code      VARCHAR(32)  NULL,  -- ※個体属性としてこちらに保持

  -- ▼ 病院情報（自由形式）
  clinic_snapshot_json     JSON NULL,

  -- ▼ 保険加入スナップショット（insurance_enrollments 主要列）
  ins_farm_user_id         INT UNSIGNED NULL,
  ins_subscriber_code      CHAR(8) NULL,
  ins_status               ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date           DATE NULL,
  ins_end_date             DATE NULL,
  ins_fiscal_year          YEAR NULL,
  ins_source_note          VARCHAR(255) NULL,

  created_by               INT UNSIGNED NULL,
  deleted_at               DATETIME NULL,
  created_at               DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at               DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- インデックス
  INDEX idx_period     (fiscal_year, claim_month),
  INDEX idx_status     (status),
  INDEX idx_individual (individual_uuid),
  INDEX idx_farm       (farm_uuid),
  INDEX idx_outcome    (outcome_code),
  INDEX idx_disease1   (disease1_code),
  INDEX idx_disease2   (disease2_code),
  INDEX idx_disease3   (disease3_code),

  -- 外部キー
  CONSTRAINT fk_ch_hdr_individual
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_ch_hdr_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_ch_hdr_ins
    FOREIGN KEY (insurance_enrollment_id) REFERENCES insurance_enrollments(id)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 2) カルテ内「各回の診療」スナップ（checkups のコピー／親）
CREATE TABLE IF NOT EXISTS chart_checkups (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 CHAR(36) NOT NULL UNIQUE,      -- スナップ側のcheckup-uuid
  chart_uuid           CHAR(36) NOT NULL,             -- ↔ chart_headers.uuid
  seq_no               INT UNSIGNED NOT NULL,         -- ヘッダ内の並び（日時昇順など）
  source_checkup_uuid  CHAR(36) NOT NULL,             -- 元のcheckups.uuid
  source_visit_uuid    CHAR(36) NULL,                 -- 任意：元のvisits.uuid

  checkup_at           DATETIME NULL,                 -- 受診日時スナップ
  -- SOAP/TPR/現症・経過（スナップ）
  subjective_text      TEXT NULL,
  objective_text       TEXT NULL,
  assessment_text      TEXT NULL,
  plan_text            TEXT NULL,
  clinical_course_text TEXT NULL,
  tpr_temp_c           DECIMAL(4,1) NULL,
  tpr_pulse_bpm        SMALLINT UNSIGNED NULL,
  tpr_resp_bpm         SMALLINT UNSIGNED NULL,

  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_hdr_seq (chart_uuid, seq_no),
  INDEX idx_hdr (chart_uuid),

  CONSTRAINT fk_chart_checkups_header
    FOREIGN KEY (chart_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 3) カルテ明細スナップ（checkup_items のコピー／子）※冗長なし＝ヘッダ列を持たない
CREATE TABLE IF NOT EXISTS chart_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  chart_checkup_uuid     CHAR(36) NOT NULL,             -- ↔ chart_checkups.uuid（親子）
  within_checkup_line_no INT UNSIGNED NOT NULL,         -- 受診回内の行順

  source_checkup_uuid    CHAR(36) NOT NULL,             -- 由来（監査用）
  treatment_uuid         CHAR(36) NULL,                 -- 任意参照
  description            VARCHAR(255) NOT NULL,

  qty_unit               VARCHAR(32) NULL,
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type               ENUM('insurance','private') NOT NULL,

  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_parent (chart_checkup_uuid, within_checkup_line_no),

  CONSTRAINT fk_ci_cc
    FOREIGN KEY (chart_checkup_uuid) REFERENCES chart_checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 4) 原本：checkups（カルテ接続・対象外・SOAP/TPR）
CREATE TABLE IF NOT EXISTS checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   CHAR(36) NOT NULL UNIQUE,

  visit_uuid             CHAR(36) NOT NULL,        -- ↔ visits.uuid
  individual_uuid        CHAR(36) NOT NULL,        -- ↔ individuals.uuid

  chart_header_uuid      CHAR(36) NULL,            -- 未接続=NULL
  claim_exclusion        ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached   TINYINT(1) NOT NULL DEFAULT 0,

  -- SOAP
  subjective_text        TEXT NULL,
  objective_text         TEXT NULL,
  assessment_text        TEXT NULL,
  plan_text              TEXT NULL,

  -- TPR
  tpr_temp_c             DECIMAL(4,1) NULL,
  tpr_pulse_bpm          SMALLINT UNSIGNED NULL,
  tpr_resp_bpm           SMALLINT UNSIGNED NULL,

  clinical_course_text   TEXT NULL,                -- 現症・経過
  status                 ENUM('draft','ready') NOT NULL DEFAULT 'draft',

  created_by             INT UNSIGNED NULL,
  deleted_at             DATETIME NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_visit_individual (visit_uuid, individual_uuid),
  INDEX idx_individual (individual_uuid),
  INDEX idx_claim (chart_header_uuid, claim_exclusion, has_insurance_cached, individual_uuid),

  CONSTRAINT fk_cu_visit
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_cu_individual
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_cu_chart_header
    FOREIGN KEY (chart_header_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 5) 原本：checkup_items（v1p2互換・pay_typeを'insurance'/'private'で統一）
CREATE TABLE IF NOT EXISTS checkup_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   CHAR(36) NOT NULL UNIQUE,
  checkup_uuid           CHAR(36) NOT NULL,        -- ↔ checkups.uuid
  treatment_uuid         CHAR(36) NULL,
  description            VARCHAR(255) NOT NULL,

  qty_unit               VARCHAR(32) NULL,
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type               ENUM('insurance','private') NOT NULL,

  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,

  deleted_at             DATETIME NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_items (checkup_uuid, pay_type),
  CONSTRAINT fk_ci_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
<<<END patches/checkups_desease_chart_p6.1.sql>>>

<<<FILE patches/checkups_p012.1.sql>>>
/* ============================================================
  checkups — BINARY(16) 版（MariaDB 10.5）／クライアント32桁hex・API境界のみ変換

  ■方針
    - クライアント（PWA）は UUID を **32桁hex（小文字、ダッシュ無し）** で扱う。
    - APIでは受信時に **UNHEX(…)=BINARY(16)** へ、返却時は **LOWER(HEX(…))** へ変換。
    - DBはすべて **BINARY(16)** で保存し、JOIN/索引/容量を最適化。
    - UUID未指定（クライアント発番できない）時は、**DBトリガが v7 を自動付与**。
    - GUIの可読用途は **ビュー** で提供（本体テーブルはクリーンを維持）。

  ■カラム/外部キー
    - `uuid` / `visit_uuid` / `individual_uuid` / `chart_header_uuid` は **BINARY(16)**。
    - `visits` / `individuals` / `chart_headers` 側の `uuid` も **BINARY(16) + UNIQUE** 前提。
    - （旧コメント）訪問のFK名は要望どおり **fk_visit_uuid1**。
    - （修正）FK命名規則に合わせ **fk_checkups_visit_uuid** に統一。

  ■文字コード（整合性）
    - 本テーブルは **DEFAULT CHARSET = utf8mb4, COLLATE = utf8mb4_unicode_ci** を明示。
    - アプリ内の他テーブルも **同一** に統一（混在は JOIN/比較で不具合の元）。
      例: ALTER DATABASE your_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

  ■API境界の使い方（例）
    - 受信: 32桁hex → `UNHEX(:uuid_hex)` で渡す（未指定なら NULL）
    - 返却: `SELECT LOWER(HEX(uuid)) AS uuid_hex ...`

  ■備考
    - レプリケーションは、関数で RAND() を使うため **ROWベース**推奨。
    - 親行はすでに存在していること（**親→子の順でINSERT**）。
============================================================ */

-- ========== ユーティリティ関数（hex⇄bin, v7生成） ==========
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16))
RETURNS CHAR(32)
DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36))
RETURNS BINARY(16)
DETERMINISTIC
BEGIN
  -- PWAは 32桁hex を送る前提だが、ダッシュ付きを混ぜても受けられるように REPLACE
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str()
RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;       DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);         DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);           DECLARE t_mid CHAR(4);

  SET ts_ms  = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  SET r12    = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail   = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin()
RETURNS BINARY(16)
NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

-- ========== 再デプロイ安全化 ==========
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP VIEW IF EXISTS checkups_hex_v;
DROP TABLE IF EXISTS checkups;

-- ========== 本体テーブル ==========
CREATE TABLE IF NOT EXISTS checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  -- 主キー相当の一意UUID（BINARY16）
  uuid                   BINARY(16) NOT NULL UNIQUE,

  -- 親FK（BINARY16）
  visit_uuid             BINARY(16) NOT NULL,      -- ↔ visits.uuid
  individual_uuid        BINARY(16) NOT NULL,      -- ↔ individuals.uuid
  chart_header_uuid      BINARY(16) NULL,          -- ↔ chart_headers.uuid

  -- SOAP（p1命名）
  s_subjective           TEXT NULL,
  o_objective            TEXT NULL,
  a_assessment           TEXT NULL,
  p_plan                 TEXT NULL,

  -- TPR（p1命名）
  temp_c                 DECIMAL(4,1) NULL,        -- 体温[℃]
  pulse_bpm              SMALLINT UNSIGNED NULL,   -- 脈拍[bpm]
  resp_bpm               SMALLINT UNSIGNED NULL,   -- 呼吸[bpm]

  -- 現症・経過
  clinical_course        TEXT NULL,

  -- 請求/運用（#2系）
  claim_exclusion        ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached   TINYINT(1) NOT NULL DEFAULT 0,

  status                 ENUM('draft','ready') NOT NULL DEFAULT 'draft',

  created_by             INT UNSIGNED NULL,
  deleted_at             DATETIME NULL,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 制約・索引
  -- （旧コメント）UNIQUE KEY uq_checkups_visit_individual (visit_uuid, individual_uuid),
  -- （修正）同一 visit×individual で複数の checkups を許可するため UNIQUE を撤去。
  --         代替として探索用の複合インデックスを追加（下記）。

  INDEX idx_checkups_visit (visit_uuid),
  INDEX idx_checkups_individual (individual_uuid),

  -- ▼追加：探索・並び用の複合インデックス（どちらか/両方運用可）
  INDEX idx_checkups_visit_individual_created (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_individual_uuid    (visit_uuid, individual_uuid, uuid),

  INDEX idx_claim (chart_header_uuid, claim_exclusion, has_insurance_cached, individual_uuid),

  -- 外部キー（命名規則を統一）
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_checkups_chart_header_uuid
    FOREIGN KEY (chart_header_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- ========== BEFORE INSERT: uuid 未指定なら DB が v7 を自動付与 ==========
DELIMITER $$
CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  -- アプリが uuid を送らない/NULL の場合のみ自動採番（v7, BINARY16）
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

-- 5) checkup_items（p012準拠）
CREATE TABLE IF NOT EXISTS checkup_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   BINARY(16) NOT NULL UNIQUE,
  checkup_uuid           BINARY(16) NOT NULL,            -- ↔ checkups.uuid
  treatment_uuid         BINARY(16) NULL,                -- 任意参照
  description            VARCHAR(255) NOT NULL,

  qty_unit               VARCHAR(32) NULL,
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type               ENUM('insurance','private') NOT NULL,

  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,

  deleted_at             DATETIME NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),

  CONSTRAINT fk_checkup_items_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

-- ========== 管理・デバッグ用ビュー（返却時にhex文字列で見たい時） ==========
/*
  本番アプリはBINARY16を直接扱い、返却時に HEX() で文字列化すればよい。
  ただし、GUI/手検証で可読にしたい場合はこのビューを使う。
  ※本体テーブルはクリーンのまま（生成列など付けない）。
*/
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)        AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid)   AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm, clinical_course,
  claim_exclusion, has_insurance_cached, status,
  created_by, deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/checkups_p012.1.sql>>>

<<<FILE patches/checkups_p012.2.sql>>>
/* =========================================================
   checkups / checkup_items — p012.1 準拠＋指定4点のみ適用
   変更点:
     1) row_version 追加（両テーブル）
     2) list index 追加（(deleted_at, updated_at, id)）
     3) ゼロUUID混入防止（0x00.. → 自動採番）
     4) ROW_FORMAT=DYNAMIC 明示
   ポリシー変更:
     - checkups.chart_header_uuid は弱いリンク（FKなし、索引のみ）
   ========================================================= */

/* ========== ユーティリティ関数（p012.1 そのまま） ========== */
DELIMITER $$
DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32) DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16) DETERMINISTIC
BEGIN
  -- ダッシュ混在も受容
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36) NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  SET r12 = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16) NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$
DELIMITER ;

/* ========== 再デプロイ安全化 ========== */
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;
DROP VIEW    IF EXISTS checkups_hex_v;
DROP TABLE   IF EXISTS checkup_items;
DROP TABLE   IF EXISTS checkups;

/* ========== 本体テーブル：checkups（p012.1＋4点｜弱リンク） ========== */
CREATE TABLE IF NOT EXISTS checkups (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  -- 主キー相当の一意UUID（BINARY16）
  uuid              BINARY(16) NOT NULL UNIQUE,

  -- 親（BINARY16）
  visit_uuid        BINARY(16) NOT NULL,   -- ↔ visits.uuid
  individual_uuid   BINARY(16) NOT NULL,   -- ↔ individuals.uuid
  chart_header_uuid BINARY(16) NULL,       -- スナップへの弱リンク（FKなし）

  -- SOAP（p012.1 命名）
  s_subjective      TEXT NULL,
  o_objective       TEXT NULL,
  a_assessment      TEXT NULL,
  p_plan            TEXT NULL,

  -- TPR（p012.1 命名）
  temp_c            DECIMAL(4,1) NULL,           -- 体温[℃]
  pulse_bpm         SMALLINT UNSIGNED NULL,      -- 脈拍[bpm]
  resp_bpm          SMALLINT UNSIGNED NULL,      -- 呼吸[bpm]

  -- 現症・経過
  clinical_course   TEXT NULL,

  -- 請求/運用（p012.1）
  claim_exclusion       ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached  TINYINT(1) NOT NULL DEFAULT 0,
  status                ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by            INT UNSIGNED NULL,

  /* 追加1) row_version */
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,

  deleted_at        DATETIME NULL,
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 索引（p012.1 既存＋弱リンク用の単一列索引を追加）
  INDEX idx_checkups_visit (visit_uuid),
  INDEX idx_checkups_individual (individual_uuid),
  INDEX idx_checkups_visit_individual_created (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_individual_uuid    (visit_uuid, individual_uuid, uuid),
  INDEX idx_claim (chart_header_uuid, claim_exclusion, has_insurance_cached, individual_uuid),
  INDEX idx_checkups_chart_header (chart_header_uuid),  -- ★弱リンク用の単一列索引

  /* 追加2) list index */
  KEY   idx_checkups_list (deleted_at, updated_at, id),

  -- 外部キー（chart_header_uuid 以外は従来通り）
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid)      REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT

  -- ★chart_header_uuid へのFKは張らない（弱リンク）
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/* ========== BEFORE INSERT: uuid 未指定/ゼロなら v7 自動付与（変更点3） ========== */
DELIMITER $$
CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

/* ========== BEFORE UPDATE: row_version 自動インクリメント（変更点1） ========== */
CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ========== 明細テーブル：checkup_items（p012.1＋4点） ========== */
CREATE TABLE IF NOT EXISTS checkup_items (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,

  checkup_uuid         BINARY(16) NOT NULL,  -- ↔ checkups.uuid
  treatment_uuid       BINARY(16) NULL,      -- 任意参照

  description          VARCHAR(255) NOT NULL,
  qty_unit             VARCHAR(32) NULL,
  quantity             DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type             ENUM('insurance','private') NOT NULL,

  unit_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points      INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point        DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen   INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate             DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen         INT UNSIGNED NOT NULL DEFAULT 0,

  /* 追加1) row_version */
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,

  deleted_at           DATETIME NULL,
  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),

  /* 追加2) list index */
  KEY   idx_checkup_items_list (deleted_at, updated_at, id),

  CONSTRAINT fk_checkup_items_checkup
    FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
/* ========== BEFORE INSERT: uuid 未指定/ゼロなら v7 自動付与（変更点3） ========== */
CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$

/* ========== BEFORE UPDATE: row_version 自動インクリメント（変更点1） ========== */
CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* ========== 可読ビュー（p012.1 そのまま） ========== */
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)        AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid)   AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm,
  clinical_course,
  claim_exclusion, has_insurance_cached, status, created_by,
  deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/checkups_p012.2.sql>>>

<<<FILE patches/checkups_p012.sql>>>
/* ============================================================
  checkups — BINARY(16) 版（MariaDB 10.5）／クライアント32桁hex・API境界のみ変換

  ■方針
    - クライアント（PWA）は UUID を **32桁hex（小文字、ダッシュ無し）** で扱う。
    - APIでは受信時に **UNHEX(…)=BINARY(16)** へ、返却時は **LOWER(HEX(…))** へ変換。
    - DBはすべて **BINARY(16)** で保存し、JOIN/索引/容量を最適化。
    - UUID未指定（クライアント発番できない）時は、**DBトリガが v7 を自動付与**。
    - GUIの可読用途は **ビュー** で提供（本体テーブルはクリーンを維持）。

  ■カラム/外部キー
    - `uuid` / `visit_uuid` / `individual_uuid` / `chart_header_uuid` は **BINARY(16)**。
    - `visits` / `individuals` / `chart_headers` 側の `uuid` も **BINARY(16) + UNIQUE** 前提。
    - （旧コメント）訪問のFK名は要望どおり **fk_visit_uuid1**。
    - （修正）FK命名規則に合わせ **fk_checkups_visit_uuid** に統一。

  ■文字コード（整合性）
    - 本テーブルは **DEFAULT CHARSET = utf8mb4, COLLATE = utf8mb4_unicode_ci** を明示。
    - アプリ内の他テーブルも **同一** に統一（混在は JOIN/比較で不具合の元）。
      例: ALTER DATABASE your_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

  ■API境界の使い方（例）
    - 受信: 32桁hex → `UNHEX(:uuid_hex)` で渡す（未指定なら NULL）
    - 返却: `SELECT LOWER(HEX(uuid)) AS uuid_hex ...`

  ■備考
    - レプリケーションは、関数で RAND() を使うため **ROWベース**推奨。
    - 親行はすでに存在していること（**親→子の順でINSERT**）。
============================================================ */

-- ========== ユーティリティ関数（hex⇄bin, v7生成） ==========
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16))
RETURNS CHAR(32)
DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36))
RETURNS BINARY(16)
DETERMINISTIC
BEGIN
  -- PWAは 32桁hex を送る前提だが、ダッシュ付きを混ぜても受けられるように REPLACE
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str()
RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
  DECLARE ts_ms BIGINT UNSIGNED;  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;       DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);         DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);           DECLARE t_mid CHAR(4);

  SET ts_ms  = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');

  SET r12    = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'),
                      LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail   = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi  = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);

  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin()
RETURNS BINARY(16)
NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

-- ========== 再デプロイ安全化 ==========
DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP VIEW IF EXISTS checkups_hex_v;
DROP TABLE IF EXISTS checkups;

-- ========== 本体テーブル ==========
CREATE TABLE IF NOT EXISTS checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  -- 主キー相当の一意UUID（BINARY16）
  uuid                   BINARY(16) NOT NULL UNIQUE,

  -- 親FK（BINARY16）
  visit_uuid             BINARY(16) NOT NULL,      -- ↔ visits.uuid
  individual_uuid        BINARY(16) NOT NULL,      -- ↔ individuals.uuid
  chart_header_uuid      BINARY(16) NULL,          -- ↔ chart_headers.uuid

  -- SOAP（p1命名）
  s_subjective           TEXT NULL,
  o_objective            TEXT NULL,
  a_assessment           TEXT NULL,
  p_plan                 TEXT NULL,

  -- TPR（p1命名）
  temp_c                 DECIMAL(4,1) NULL,        -- 体温[℃]
  pulse_bpm              SMALLINT UNSIGNED NULL,   -- 脈拍[bpm]
  resp_bpm               SMALLINT UNSIGNED NULL,   -- 呼吸[bpm]

  -- 現症・経過
  clinical_course        TEXT NULL,

  -- 請求/運用（#2系）
  claim_exclusion        ENUM('none','no_insurance','manual') NOT NULL DEFAULT 'none',
  has_insurance_cached   TINYINT(1) NOT NULL DEFAULT 0,

  status                 ENUM('draft','ready') NOT NULL DEFAULT 'draft',

  created_by             INT UNSIGNED NULL,
  deleted_at             DATETIME NULL,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 制約・索引
  -- （旧コメント）UNIQUE KEY uq_checkups_visit_individual (visit_uuid, individual_uuid),
  -- （修正）同一 visit×individual で複数の checkups を許可するため UNIQUE を撤去。
  --         代替として探索用の複合インデックスを追加（下記）。

  INDEX idx_checkups_visit (visit_uuid),
  INDEX idx_checkups_individual (individual_uuid),

  -- ▼追加：探索・並び用の複合インデックス（どちらか/両方運用可）
  INDEX idx_checkups_visit_individual_created (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_individual_uuid    (visit_uuid, individual_uuid, uuid),

  INDEX idx_claim (chart_header_uuid, claim_exclusion, has_insurance_cached, individual_uuid),

  -- 外部キー（命名規則を統一）
  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  CONSTRAINT fk_checkups_chart_header_uuid
    FOREIGN KEY (chart_header_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci;

-- ========== BEFORE INSERT: uuid 未指定なら DB が v7 を自動付与 ==========
DELIMITER $$
CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  -- アプリが uuid を送らない/NULL の場合のみ自動採番（v7, BINARY16）
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

-- ========== 管理・デバッグ用ビュー（返却時にhex文字列で見たい時） ==========
/*
  本番アプリはBINARY16を直接扱い、返却時に HEX() で文字列化すればよい。
  ただし、GUI/手検証で可読にしたい場合はこのビューを使う。
  ※本体テーブルはクリーンのまま（生成列など付けない）。
*/
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)              AS uuid_hex,
  uuid_bin_to_hex(visit_uuid)        AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid)   AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm, clinical_course,
  claim_exclusion, has_insurance_cached, status,
  created_by, deleted_at, created_at, updated_at
FROM checkups;
<<<END patches/checkups_p012.sql>>>

<<<FILE patches/checkups_p1_itd012.sql>>>
  -- SOAP カラム追加

CREATE TABLE IF NOT EXISTS checkups (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             CHAR(36) NOT NULL UNIQUE,
  visit_uuid       CHAR(36) NOT NULL,              -- ↔ visits.uuid
  individual_uuid  CHAR(36) NOT NULL,              -- ↔ individuals.uuid

  -- SOAP fields
  s_subjective     TEXT NULL COMMENT 'S: Subjective (owner-reported signs, history)',
  o_objective      TEXT NULL COMMENT 'O: Objective (exam findings, labs, imaging)',
  a_assessment     TEXT NULL COMMENT 'A: Assessment / differential & working dx',
  p_plan           TEXT NULL COMMENT 'P: Plan / therapy / next steps',

  -- TPR (vital signs)
  temp_c           DECIMAL(4,1) NULL COMMENT 'TPR: Temperature (°C)',
  pulse_bpm        SMALLINT UNSIGNED NULL COMMENT 'TPR: Pulse (beats/min)',
  resp_bpm         SMALLINT UNSIGNED NULL COMMENT 'TPR: Respiratory rate (breaths/min)',

  -- 現症・経過
  clinical_course  TEXT NULL COMMENT 'Clinical course / current condition',

  status           ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_checkups_visit_individual (visit_uuid, individual_uuid),
  INDEX idx_checkups_visit (visit_uuid),
  INDEX idx_checkups_individual (individual_uuid),

  CONSTRAINT fk_checkups_visit_uuid
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_checkups_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB;
<<<END patches/checkups_p1_itd012.sql>>>

<<<FILE patches/p014.5_002.indi_to_ckpit.sql>>>
SET NAMES utf8mb4;

/* ===================================================================
   vetDB — p014.4 改版（CSIFH-PureMirror v1 適用）
   -------------------------------------------------------------------
   目的（多病院対応 / 履歴固定）:
   - 各実データ行に clinic_uuid を「当時値」として固定保存。
   - 親の clinic_uuid を BEFORE INSERT トリガで継承（事後更新はしない）。
   - これにより、後から farms の所属クリニックを付け替えても、
     過去データの「属していた院」で高速絞り込みが可能。

   既存の保険方針は維持:
   - 非加入牧場では checkup_items.pay_type は UIで private 固定。
   - 加入牧場では insurance を優先表示（UI）。
   - DB側の保険ガードは非実装（APIで insurance 選択時のみJOIN検証）。

   依存:
   - clinics(uuid BINARY(16) PK) が存在すること（p018.2 等）。
   - farms に clinic_uuid BINARY(16) NOT NULL（FK→clinics(uuid)）が存在すること。

   注意:
   - 本DDLは新規インストール想定。再デプロイ簡略化のため DROP を先行。
   - 既存環境へは「列追加＋移行UPDATE＋トリガ追加」の順で段階適用すること。
   =================================================================== */

/* ================================================================
   再デプロイ安全化（存在すればDROP）
   - farms/users/clinics等の親は既存運用前提のため DROP しない
   ================================================================ */
DROP VIEW IF EXISTS checkups_insurance_context_v;
DROP VIEW IF EXISTS checkups_hex_v;
DROP VIEW IF EXISTS individuals_hex_v;

DROP TRIGGER IF EXISTS tr_individuals_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_individuals_bu_rowver;
DROP TRIGGER IF EXISTS tr_individuals_bi_clinic;

DROP TRIGGER IF EXISTS bi_visits_uuid;
DROP TRIGGER IF EXISTS bu_visits_rowver;
DROP TRIGGER IF EXISTS tr_visits_bi_clinic;

DROP TRIGGER IF EXISTS tr_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkups_bu_rowver;
DROP TRIGGER IF EXISTS tr_checkups_bi_clinic;

DROP TRIGGER IF EXISTS tr_checkup_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_checkup_items_bu_rowver;
DROP TRIGGER IF EXISTS tr_checkup_items_bi_clinic;

DROP TABLE IF EXISTS checkup_items;
DROP TABLE IF EXISTS checkups;
DROP TABLE IF EXISTS visits;
DROP TABLE IF EXISTS individuals;

/* receipt_header_drafts は FK整合のための最小スタブ（本番は p017 正式DDLで置換） */
DROP TABLE IF EXISTS receipt_header_drafts;

/* ================================================================
   UUIDユーティリティ関数（p012系踏襲）
   ================================================================ */
DELIMITER $$

DROP FUNCTION IF EXISTS uuid_bin_to_hex $$
CREATE FUNCTION uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32) DETERMINISTIC
BEGIN
  RETURN LOWER(HEX(b));
END$$

DROP FUNCTION IF EXISTS uuid_hex_to_bin $$
CREATE FUNCTION uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16) DETERMINISTIC
BEGIN
  RETURN UNHEX(REPLACE(LOWER(s), '-', ''));
END$$

DROP FUNCTION IF EXISTS uuid_v7_str $$
CREATE FUNCTION uuid_v7_str() RETURNS CHAR(36) NOT DETERMINISTIC
BEGIN
  /* 擬似 UUIDv7: ミリ秒エポック + 乱数（検証用） */
  DECLARE ts_ms BIGINT UNSIGNED;
  DECLARE ts_hex CHAR(12);
  DECLARE r12 INT UNSIGNED;
  DECLARE ver_hi CHAR(4);
  DECLARE var_hi CHAR(4);
  DECLARE tail CHAR(12);
  DECLARE t_hi CHAR(8);
  DECLARE t_mid CHAR(4);

  SET ts_ms = CAST(ROUND(UNIX_TIMESTAMP(CURRENT_TIMESTAMP(3))*1000) AS UNSIGNED);
  SET ts_hex = LPAD(HEX(ts_ms),12,'0');
  SET r12 = FLOOR(RAND()*POW(2,12));
  SET ver_hi = CONCAT('7', LPAD(HEX(r12),3,'0'));
  SET var_hi = CONCAT(ELT(FLOOR(RAND()*4)+1,'8','9','a','b'), LPAD(HEX(FLOOR(RAND()*POW(2,12))),3,'0'));
  SET tail = LPAD(HEX(FLOOR(RAND()*POW(2,48))),12,'0');

  SET t_hi = LEFT(ts_hex,8);
  SET t_mid = SUBSTRING(ts_hex,9,4);
  RETURN LOWER(CONCAT(t_hi,'-',t_mid,'-',ver_hi,'-',var_hi,'-',tail));
END$$

DROP FUNCTION IF EXISTS uuid_v7_bin $$
CREATE FUNCTION uuid_v7_bin() RETURNS BINARY(16) NOT DETERMINISTIC
BEGIN
  RETURN uuid_hex_to_bin(uuid_v7_str());
END$$

DELIMITER ;

/* ================================================================
   individuals
   ------------------------------------------------
   - clinic_uuid: 親farmsの当時値を固定保存（BI継承）。
   - farm_uuid: ON UPDATE CASCADE / ON DELETE RESTRICT。
   - 母参照: 自己参照分離・自己リンク禁止CHECK。
   - row_version: 楽観ロック。
   - 院用索引: idx_individuals_clinic(clinic_uuid, id)
   ================================================================ */
CREATE TABLE individuals (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,
  clinic_uuid           BINARY(16) NOT NULL,   -- ★ CSIFH: 所属院（履歴固定）
  farm_uuid             BINARY(16) NOT NULL,   -- ↔ farms.uuid
  user_uuid             BINARY(16) NULL,       -- ↔ users.uuid（担当メモ）
  name                  VARCHAR(100) NULL,
  ear_tag               CHAR(10) NULL,         -- 全国一意10桁（NULL可）
  status                ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender                ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date            DATE NULL,
  death_date            DATE NULL,
  sire_name             VARCHAR(100) NULL,     -- 父は名称メモのみ
  genetic_dam_uuid      BINARY(16) NULL,       -- 自己参照（遺伝母）
  nursing_dam_uuid      BINARY(16) NULL,       -- 自己参照（哺育母）
  genetic_dam_ear_tag   CHAR(10) NULL,
  genetic_dam_name      VARCHAR(100) NULL,
  nursing_dam_ear_tag   CHAR(10) NULL,
  nursing_dam_name      VARCHAR(100) NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at            DATETIME NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_individuals_ear_tag (ear_tag),
  KEY idx_individuals_farm_name (farm_uuid, name),
  KEY idx_individuals_farm_birth (farm_uuid, birth_date),
  KEY idx_individuals_farm_status (farm_uuid, status),
  KEY idx_individuals_genetic_dam (genetic_dam_uuid),
  KEY idx_individuals_nursing_dam (nursing_dam_uuid),
  KEY idx_individuals_list (deleted_at, updated_at, id),
  KEY idx_individuals_clinic (clinic_uuid, id),

  CONSTRAINT fk_individuals_clinic_uuid   FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_individuals_farm_uuid     FOREIGN KEY (farm_uuid)    REFERENCES farms(uuid)      ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_individuals_user_uuid     FOREIGN KEY (user_uuid)    REFERENCES users(uuid)      ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_individuals_genetic_dam   FOREIGN KEY (genetic_dam_uuid)  REFERENCES individuals(uuid) ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_individuals_nursing_dam   FOREIGN KEY (nursing_dam_uuid)  REFERENCES individuals(uuid) ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT chk_individuals_no_self_genetic CHECK (genetic_dam_uuid IS NULL OR genetic_dam_uuid <> uuid),
  CONSTRAINT chk_individuals_no_self_nursing CHECK (nursing_dam_uuid IS NULL OR nursing_dam_uuid <> uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$

CREATE TRIGGER tr_individuals_bi_uuid_v7
BEFORE INSERT ON individuals
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 親farmsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT f.clinic_uuid INTO @cu FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

CREATE TRIGGER tr_individuals_bu_rowver
BEFORE UPDATE ON individuals
FOR EACH ROW
BEGIN
  /* 履歴固定方針のため clinic_uuid は自動更新しない（必要時はアプリで明示更新） */
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;

/* 可読HEXビュー（clinic_uuid_hex を追加） */
CREATE OR REPLACE VIEW individuals_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)         AS uuid_hex,
  uuid_bin_to_hex(clinic_uuid)  AS clinic_uuid_hex,
  uuid_bin_to_hex(farm_uuid)    AS farm_uuid_hex,
  uuid_bin_to_hex(user_uuid)    AS user_uuid_hex,
  name, ear_tag, status, gender, birth_date, death_date, sire_name,
  uuid_bin_to_hex(genetic_dam_uuid)  AS genetic_dam_uuid_hex,
  genetic_dam_ear_tag, genetic_dam_name,
  uuid_bin_to_hex(nursing_dam_uuid)  AS nursing_dam_uuid_hex,
  nursing_dam_ear_tag, nursing_dam_name,
  deleted_at, created_at, updated_at
FROM individuals;

/* ================================================================
   visits
   ------------------------------------------------
   - clinic_uuid: 親farmsの当時値を固定保存（BI継承）。
   - visit_started_at: NULLならUTC現在時刻に初期化。
   - 院用索引: idx_visits_clinic(clinic_uuid, visit_started_at)
   ================================================================ */
CREATE TABLE visits (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,
  clinic_uuid      BINARY(16) NOT NULL,   -- ★ CSIFH
  farm_uuid        BINARY(16) NOT NULL,   -- ↔ farms.uuid
  visit_started_at DATETIME NOT NULL,
  visit_ended_at   DATETIME NULL,
  location_text    VARCHAR(180) NULL,
  note             VARCHAR(255) NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at       DATETIME NULL,
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_visits_farm (farm_uuid),
  KEY idx_visits_farm_started (farm_uuid, visit_started_at),
  KEY idx_visits_started (visit_started_at),
  KEY idx_visits_list (deleted_at, updated_at, id),
  KEY idx_visits_clinic (clinic_uuid, visit_started_at),

  CONSTRAINT fk_visits_clinic_uuid FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid) ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_visits_farm_uuid   FOREIGN KEY (farm_uuid)   REFERENCES farms(uuid)   ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$

CREATE TRIGGER bi_visits_uuid
BEFORE INSERT ON visits
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = 0x00000000000000000000000000000000 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
  IF NEW.visit_started_at IS NULL THEN
    SET NEW.visit_started_at = UTC_TIMESTAMP();
  END IF;

  /* CSIFH: 親farmsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT f.clinic_uuid INTO @cu FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

CREATE TRIGGER bu_visits_rowver
BEFORE UPDATE ON visits
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;

/* ================================================================
   checkups
   ------------------------------------------------
   - clinic_uuid: 優先 visit から、無ければ individual から継承（履歴固定）。
   - visit_uuid: NULL許容（親visit削除時は SET NULL）。
   - receipt_header_drafts_uuid: p017 直付け方針を維持。
   - 院用索引: idx_checkups_clinic(clinic_uuid, created_at)
   ================================================================ */
CREATE TABLE checkups (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,
  clinic_uuid  BINARY(16) NOT NULL,          -- ★ CSIFH
  visit_uuid   BINARY(16) NULL,              -- ↔ visits.uuid（SET NULL）
  individual_uuid BINARY(16) NOT NULL,       -- ↔ individuals.uuid（RESTRICT）

  /* p017: レシート草稿への直付け（草稿削除で自動デタッチ） */
  receipt_header_drafts_uuid BINARY(16) NULL, -- ↔ receipt_header_drafts.uuid

  /* 将来の確定カルテ弱リンク（FKなし） */
  chart_header_uuid BINARY(16) NULL,

  /* SOAP */
  s_subjective TEXT NULL,
  o_objective  TEXT NULL,
  a_assessment TEXT NULL,
  p_plan       TEXT NULL,

  /* TPR */
  temp_c     DECIMAL(4,1) NULL,
  pulse_bpm  SMALLINT UNSIGNED NULL,
  resp_bpm   SMALLINT UNSIGNED NULL,

  /* 現症・経過 */
  clinical_course TEXT NULL,

  /* 運用 */
  status      ENUM('draft','ready') NOT NULL DEFAULT 'draft',
  created_by  INT UNSIGNED NULL,
  row_version BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at  DATETIME NULL,
  created_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 索引 */
  INDEX idx_checkups_visit (visit_uuid),
  INDEX idx_checkups_individual (individual_uuid),
  INDEX idx_checkups_visit_ind_crt (visit_uuid, individual_uuid, created_at),
  INDEX idx_checkups_visit_ind_uuid (visit_uuid, individual_uuid, uuid),
  INDEX idx_checkups_chart_header (chart_header_uuid),
  KEY   idx_checkups_list (deleted_at, updated_at, id),
  KEY   idx_checkups_rhd (receipt_header_drafts_uuid, id),
  KEY   idx_checkups_clinic (clinic_uuid, created_at),

  /* 外部キー */
  CONSTRAINT fk_checkups_clinic_uuid   FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)     ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_checkups_visit_uuid    FOREIGN KEY (visit_uuid)   REFERENCES visits(uuid)      ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_checkups_individual_uuid FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid) ON UPDATE RESTRICT ON DELETE RESTRICT,
  CONSTRAINT fk_checkups_rhd           FOREIGN KEY (receipt_header_drafts_uuid) REFERENCES receipt_header_drafts(uuid) ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

DELIMITER $$

CREATE TRIGGER tr_checkups_bi_uuid_v7
BEFORE INSERT ON checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 優先 visit.clinic_uuid → 無ければ individual.clinic_uuid を継承 */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    IF NEW.visit_uuid IS NOT NULL THEN
      SELECT v.clinic_uuid INTO @cu FROM visits v WHERE v.uuid = NEW.visit_uuid LIMIT 1;
    ELSE
      SELECT i.clinic_uuid INTO @cu FROM individuals i WHERE i.uuid = NEW.individual_uuid LIMIT 1;
    END IF;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

CREATE TRIGGER tr_checkups_bu_rowver
BEFORE UPDATE ON checkups
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;

/* 可読HEXビュー（clinic_uuid_hex を追加） */
CREATE OR REPLACE VIEW checkups_hex_v AS
SELECT
  id,
  uuid_bin_to_hex(uuid)         AS uuid_hex,
  uuid_bin_to_hex(clinic_uuid)  AS clinic_uuid_hex,
  uuid_bin_to_hex(visit_uuid)   AS visit_uuid_hex,
  uuid_bin_to_hex(individual_uuid) AS individual_uuid_hex,
  uuid_bin_to_hex(chart_header_uuid) AS chart_header_uuid_hex,
  s_subjective, o_objective, a_assessment, p_plan,
  temp_c, pulse_bpm, resp_bpm, clinical_course,
  status, created_by, deleted_at, created_at, updated_at
FROM checkups;

/* ================================================================
   checkup_items
   ------------------------------------------------
   - clinic_uuid: 親checkupsの当時値を固定保存（BI継承）。
   - 保険/自費の両立カラムは据え置き。DEFAULT 'private' 推奨。
   - 院用索引: idx_checkup_items_clinic(clinic_uuid, id)
   ================================================================ */
CREATE TABLE checkup_items (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,
  clinic_uuid         BINARY(16) NOT NULL,   -- ★ CSIFH
  checkup_uuid        BINARY(16) NOT NULL,   -- ↔ checkups.uuid
  treatment_uuid      BINARY(16) NULL,       -- 任意参照（マスタ未確定でも可）
  description         VARCHAR(255) NOT NULL,
  qty_unit            VARCHAR(32) NULL,
  quantity            DECIMAL(10,2) NOT NULL DEFAULT 1,
  pay_type            ENUM('insurance','private') NOT NULL DEFAULT 'private',

  /* 点数/価格の両立 */
  unit_b_points       INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points       INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points     INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point       DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  unit_price_yen      INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen  INT UNSIGNED NOT NULL DEFAULT 0,
  tax_rate            DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen        INT UNSIGNED NOT NULL DEFAULT 0,

  row_version         BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at          DATETIME NULL,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_checkup_items_parent (checkup_uuid, pay_type),
  KEY   idx_checkup_items_list (deleted_at, updated_at, id),
  KEY   idx_checkup_items_clinic (clinic_uuid, id),

  CONSTRAINT fk_checkup_items_clinic FOREIGN KEY (clinic_uuid)  REFERENCES clinics(uuid)  ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_checkup_items_checkup FOREIGN KEY (checkup_uuid) REFERENCES checkups(uuid) ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

DELIMITER $$

CREATE TRIGGER tr_checkup_items_bi_uuid_v7
BEFORE INSERT ON checkup_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* CSIFH: 親checkupsの clinic_uuid を継承（履歴固定） */
  IF NEW.clinic_uuid IS NULL OR NEW.clinic_uuid = UNHEX(REPEAT('0',32)) THEN
    SELECT c.clinic_uuid INTO @cu FROM checkups c WHERE c.uuid = NEW.checkup_uuid LIMIT 1;
    SET NEW.clinic_uuid = @cu;
  END IF;
END$$

CREATE TRIGGER tr_checkup_items_bu_rowver
BEFORE UPDATE ON checkup_items
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$

DELIMITER ;

/* ================================================================
   ビュー: UI/API 補助
   ------------------------------------------------
   1) checkups_insurance_context_v:
      - checkup → individual → farm をJOINし、牧場の加入/非加入を返す。
      - UIの既定値に使う preferred_pay_type も返す。
      - 参照列は既存方針どおり簡潔に（clinic列は必要な画面のみ別途参照）。
   ================================================================ */
CREATE OR REPLACE VIEW checkups_insurance_context_v AS
SELECT
  c.uuid AS checkup_uuid,
  f.non_insured AS farm_non_insured,
  CASE WHEN f.non_insured = 1 THEN 'private' ELSE 'insurance' END AS preferred_pay_type
FROM checkups c
JOIN individuals i ON i.uuid = c.individual_uuid
JOIN farms f       ON f.uuid = i.farm_uuid;

/* ================================================================
   receipt_header_drafts — 最小スタブ
   ------------------------------------------------
   - p017 正式DDLに置換される前提。ここではFK満たすためだけにuuidを用意。
   ================================================================ */
CREATE TABLE receipt_header_drafts (
  id   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid BINARY(16) NOT NULL UNIQUE,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
<<<END patches/p014.5_002.indi_to_ckpit.sql>>>

<<<FILE patches/p015.3_008.dis_to_chtit.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   vetDB p015.1 (+ CSIFH-PureMirror v1) — chart+disease 統合 DDL
   ---------------------------------------------------------
   目的（CSIFH-PureMirror v1）
   - 多病院対応：実データに clinic_uuid を「当時値」で固定保存
   - 継承規則：
       chart_header_drafts  : farms.clinic_uuid を継承（可変：farm変更時は再継承）
       chart_headers        : farms.clinic_uuid を継承（確定時点の当時値）
       chart_checkups       : 親 chart_headers.clinic_uuid を継承
       chart_items          : 親 chart_checkups.clinic_uuid を継承
   - 疎結合方針：clinics への FK は**付与しない**（スナップ/移行容易性を優先）
   - 高速絞込：clinic_uuid 先頭の複合INDEXを付与
   ========================================================= */

/* 再デプロイ安全化：トリガ→子→親の順にDROP（原文＋CSIFH追加分） */
DROP TRIGGER IF EXISTS tr_chart_items_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_items_bi_clinic;
DROP TRIGGER IF EXISTS tr_chart_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_checkups_bi_clinic;
DROP TRIGGER IF EXISTS tr_chart_headers_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_headers_bi_clinic;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bu_rowver;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bu_clinic_sync;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_chart_header_drafts_bi_clinic;
DROP TRIGGER IF EXISTS tr_disease_master_bi_uuid_v7;

DROP TABLE IF EXISTS chart_items;
DROP TABLE IF EXISTS chart_checkups;
DROP TABLE IF EXISTS chart_headers;
DROP TABLE IF EXISTS chart_header_drafts;
DROP TABLE IF EXISTS disease_chief_complaint_rules;
DROP TABLE IF EXISTS disease_master;

/* =========================================================
   1) disease_master — 疾病マスタ（全院共通：clinic_uuid なし）
   --------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS disease_master (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,            -- 数値主キー
  uuid              BINARY(16) NOT NULL UNIQUE,                         -- v7 UUID

  code6             CHAR(6) NOT NULL UNIQUE,                            -- 6桁コード（0埋め必須）
  major_name        VARCHAR(32) NOT NULL,                               -- 大分類名
  middle_name       VARCHAR(32) NOT NULL,                               -- 中分類名
  minor_name        VARCHAR(32) NOT NULL,                               -- 小分類名

  major_code        CHAR(2) AS (SUBSTRING(code6, 1, 2)) VIRTUAL,        -- 先頭2桁
  middle_code       CHAR(2) AS (SUBSTRING(code6, 3, 2)) VIRTUAL,        -- 中間2桁
  minor_code        CHAR(2) AS (SUBSTRING(code6, 5, 2)) VIRTUAL,        -- 末尾2桁

  display_code      VARCHAR(8)
    AS (CONCAT_WS('-', major_code, middle_code, minor_code)) PERSISTENT, -- 表示コード XX-YY-ZZ
  display_name      VARCHAR(255)
    AS (CONCAT_WS(' / ', major_name, middle_name, minor_name)) PERSISTENT, -- 表示名称 major / middle / minor

  is_active         TINYINT(1) NOT NULL DEFAULT 1,                     -- 有効フラグ
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,                -- 将来の差分同期/並行制御
  deleted_at        DATETIME NULL,                                     -- 論理削除（マスタのみ許容）
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  CHECK (code6 REGEXP '^[0-9]{6}$'),

  INDEX idx_dm_name (major_name, middle_name, minor_name),
  INDEX idx_dm_list (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_disease_master_bi_uuid_v7
BEFORE INSERT ON disease_master
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

/* =========================================================
   2) disease_chief_complaint_rules — 主訴（凛告）サジェスト
   --------------------------------------------------------- */
CREATE TABLE IF NOT EXISTS disease_chief_complaint_rules (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  disease_id             INT UNSIGNED NOT NULL,                   -- ↔ disease_master.id
  chief_complaint_text   VARCHAR(128) NOT NULL,                   -- サジェスト表示文言
  display_order          SMALLINT UNSIGNED NOT NULL DEFAULT 0,    -- 昇順で上位表示
  is_active              TINYINT(1) NOT NULL DEFAULT 1,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  CONSTRAINT fk_dccr_disease
    FOREIGN KEY (disease_id) REFERENCES disease_master(id)
    ON UPDATE CASCADE ON DELETE CASCADE,

  INDEX idx_dccr_fetch (disease_id, is_active, display_order, id),
  INDEX idx_dccr_text  (chief_complaint_text)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/* =========================================================
   3) chart_header_drafts — 編集中ヘッダ（強整合＋可変）
   ---------------------------------------------------------
   CSIFH適用差分：
   - clinic_uuid 追加（NOT NULL）。INSERT時に farms から継承。
   - farm_uuid 変更時は clinic_uuid を再継承（可変のため）。
   - 院別絞込用 INDEX を追加。
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_header_drafts (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                 -- v7 UUID（TRIGGER付与）

  /* CSIFH: 当時の院（clinics.uuid）値を固定保持。clinics へのFKは付与しない */
  clinic_uuid               BINARY(16) NOT NULL,

  /* 強整合FK（削除はRESTRICT、保険は任意でSET NULL） */
  individual_uuid           BINARY(16) NOT NULL,                        -- ↔ individuals.uuid
  farm_uuid                 BINARY(16) NOT NULL,                        -- ↔ farms.uuid
  insurance_enrollment_id   INT UNSIGNED NULL,                          -- ↔ insurance_enrollments.id

  fiscal_year               YEAR NULL,                                  -- 編集中はNULL許容
  claim_month               TINYINT UNSIGNED NULL,                      -- 1..12
  CHECK (claim_month IS NULL OR claim_month BETWEEN 1 AND 12),

  outcome_code              TINYINT UNSIGNED NULL,                      -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  draft_status              ENUM('open','closed','issued') NOT NULL DEFAULT 'open',  -- open治療中/closed転帰済/issuedスナップ発行済
  status_note               VARCHAR(255) NULL,

  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  issued_at                 DATETIME NULL,

  /* 任意のスナップ（プレビュー用途） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  updated_by                INT UNSIGNED NULL,
  row_version               BIGINT UNSIGNED NOT NULL DEFAULT 1,          -- 楽観ロック
  deleted_at                DATETIME NULL,                                -- ソフトデリート
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 強整合FK */
  CONSTRAINT fk_chd_individual
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_chd_farm
    FOREIGN KEY (farm_uuid)      REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_chd_insenroll
    FOREIGN KEY (insurance_enrollment_id) REFERENCES insurance_enrollments(id)
    ON UPDATE CASCADE ON DELETE SET NULL,

  CONSTRAINT fk_chd_dis1 FOREIGN KEY (disease1_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_chd_dis2 FOREIGN KEY (disease2_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_chd_dis3 FOREIGN KEY (disease3_code) REFERENCES disease_master(code6)
    ON UPDATE CASCADE ON DELETE SET NULL,

  /* 一覧/検索最適化（院→更新） */
  INDEX idx_chd_clinic_list (clinic_uuid, deleted_at, updated_at, id),
  INDEX idx_hdr_drafts_open   (individual_uuid, draft_status, created_at),
  INDEX idx_hdr_drafts_period (fiscal_year, claim_month),
  INDEX idx_hdr_drafts_dis1   (disease1_code),
  INDEX idx_hdr_drafts_dis2   (disease2_code),
  INDEX idx_hdr_drafts_dis3   (disease3_code),
  INDEX idx_hdr_drafts_farm   (farm_uuid),
  INDEX idx_hdr_drafts_list   (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bi_uuid_v7
BEFORE INSERT ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
/* CSIFH: INSERT時に farms.clinic_uuid を継承（アプリから clinic_uuid を渡す必要なし） */
CREATE TRIGGER tr_chart_header_drafts_bi_clinic
BEFORE INSERT ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;

DELIMITER $$
/* 任意：draft 内で farm_uuid を変更した場合に clinic_uuid も再継承して整合させる */
CREATE TRIGGER tr_chart_header_drafts_bu_clinic_sync
BEFORE UPDATE ON chart_header_drafts
FOR EACH ROW
BEGIN
  IF NEW.farm_uuid <> OLD.farm_uuid THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
  /* row_version の更新は既存トリガで実施 */
END $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_chart_header_drafts_bu_rowver
BEFORE UPDATE ON chart_header_drafts
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;

/* =========================================================
   4) chart_headers — 確定スナップ（不変）
   ---------------------------------------------------------
   CSIFH適用差分：
   - clinic_uuid 追加（NOT NULL）。INSERT時に farms から継承。
   - 院別絞込 INDEX を追加。
   - 個体/牧場/保険は弱リンク（原文踏襲；FKなし）。
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_headers (
  id                        INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                      BINARY(16) NOT NULL UNIQUE,                -- v7 UUID

  clinic_uuid               BINARY(16) NOT NULL,                        -- 当時の院（clinics.uuid）値

  /* 追跡弱リンク（確定後は変更しないためFKなしでも可） */
  individual_uuid           BINARY(16) NOT NULL,
  farm_uuid                 BINARY(16) NOT NULL,
  insurance_enrollment_id   INT UNSIGNED NULL,

  /* 保険期間識別 */
  fiscal_year               YEAR NOT NULL,
  claim_month               TINYINT UNSIGNED NOT NULL,                 -- 1..12
  CHECK (claim_month BETWEEN 1 AND 12),

  /* 転帰・期間（確定値） */
  outcome_code              TINYINT UNSIGNED NOT NULL,                 -- 1治癒/2死亡/3法令殺/4廃用/5中止
  onset_date                DATE NULL,
  first_visit_date          DATE NULL,
  last_visit_date           DATE NULL,
  outcome_date              DATE NULL,
  visit_count               INT UNSIGNED NOT NULL DEFAULT 0,

  /* 主訴・診断（スナップ） */
  chief_complaint           VARCHAR(255) NULL,
  diagnosis_text            VARCHAR(255) NULL,

  /* 疾病スナップ（6桁コード＋表示名） */
  disease1_code             CHAR(6) NULL,
  disease1_name             VARCHAR(255) NULL,
  disease2_code             CHAR(6) NULL,
  disease2_name             VARCHAR(255) NULL,
  disease3_code             CHAR(6) NULL,
  disease3_name             VARCHAR(255) NULL,

  CHECK (disease1_code IS NULL OR disease1_code REGEXP '^[0-9]{6}$'),
  CHECK (disease2_code IS NULL OR disease2_code REGEXP '^[0-9]{6}$'),
  CHECK (disease3_code IS NULL OR disease3_code REGEXP '^[0-9]{6}$'),

  /* 金額・点数合計（スナップ） */
  total_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_yen              INT UNSIGNED NOT NULL DEFAULT 0,
  patient_copay_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  insurer_pay_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  tax_yen                   INT UNSIGNED NOT NULL DEFAULT 0,

  /* ステータス：printed / voided（未印刷はNULL） */
  status                    ENUM('printed','voided') NULL DEFAULT NULL,
  printed_at                DATETIME NULL,
  printed_count             INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at                 DATETIME NULL,
  void_reason               VARCHAR(255) NULL,

  /* スナップ時の表示/保険情報（任意） */
  farm_name                 VARCHAR(255) NULL,
  farm_address              VARCHAR(255) NULL,
  farm_insurance_number     VARCHAR(64)  NULL,
  animal_name               VARCHAR(255) NULL,
  ear_tag                   VARCHAR(32)  NULL,
  dam_name                  VARCHAR(255) NULL,
  dam_ear_tag               VARCHAR(32)  NULL,
  breed_code                VARCHAR(32)  NULL,
  kyosai_purpose_code       VARCHAR(32)  NULL,
  clinic_snapshot_json      JSON NULL,
  ins_farm_user_id          INT UNSIGNED NULL,
  ins_subscriber_code       CHAR(8) NULL,
  ins_status                ENUM('加入','非加入','不明','下書き') NULL,
  ins_start_date            DATE NULL,
  ins_end_date              DATE NULL,
  ins_fiscal_year           YEAR NULL,
  ins_source_note           VARCHAR(255) NULL,

  created_by                INT UNSIGNED NULL,
  created_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 索引（院→期間→更新） */
  INDEX idx_ch_clinic_list            (clinic_uuid, updated_at, id),
  INDEX idx_chart_headers_period      (fiscal_year, claim_month),
  INDEX idx_chart_headers_status      (status),
  INDEX idx_chart_headers_individual  (individual_uuid),
  INDEX idx_chart_headers_farm        (farm_uuid),
  INDEX idx_chart_headers_outcome     (outcome_code),
  INDEX idx_chart_headers_dis1        (disease1_code),
  INDEX idx_chart_headers_dis2        (disease2_code),
  INDEX idx_chart_headers_dis3        (disease3_code),
  INDEX idx_ch_list                   (updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_headers_bi_uuid_v7
BEFORE INSERT ON chart_headers
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
/* CSIFH: INSERT時に farms.clinic_uuid を継承して固定（確定スナップの当時値） */
CREATE TRIGGER tr_chart_headers_bi_clinic
BEFORE INSERT ON chart_headers
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT f.clinic_uuid INTO NEW.clinic_uuid
      FROM farms f
     WHERE f.uuid = NEW.farm_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   5) chart_checkups — 確定スナップ配下（SOAP/TPR）
   ---------------------------------------------------------
   CSIFH適用差分：
   - clinic_uuid 追加（NOT NULL）。INSERT時に親 chart_headers から継承。
   - 院別絞込 INDEX を追加。
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_checkups (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                   BINARY(16) NOT NULL UNIQUE,             -- 行UUID
  chart_uuid             BINARY(16) NOT NULL,                    -- ↔ chart_headers.uuid
  clinic_uuid            BINARY(16) NOT NULL,                    -- 当時の院（clinics.uuid）値
  seq_no                 INT UNSIGNED NOT NULL,                  -- ヘッダ内の並び

  source_checkup_uuid    BINARY(16) NOT NULL,                    -- 由来 checkups.uuid（監査）
  source_visit_uuid      BINARY(16) NULL,                        -- 由来 visits.uuid（任意）

  checkup_at             DATETIME NULL,                          -- 受診日時

  subjective_text        TEXT NULL,
  objective_text         TEXT NULL,
  assessment_text        TEXT NULL,
  plan_text              TEXT NULL,
  clinical_course_text   TEXT NULL,

  tpr_temp_c             DECIMAL(4,1) NULL,
  tpr_pulse_bpm          SMALLINT UNSIGNED NULL,
  tpr_resp_bpm           SMALLINT UNSIGNED NULL,

  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_chart_checkups_hdr_seq (chart_uuid, seq_no),
  INDEX idx_chart_checkups_hdr (chart_uuid),
  INDEX idx_cc_clinic (clinic_uuid, chart_uuid),

  CONSTRAINT fk_chart_checkups_header
    FOREIGN KEY (chart_uuid) REFERENCES chart_headers(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_checkups_bi_uuid_v7
BEFORE INSERT ON chart_checkups
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
/* CSIFH: INSERT時に親 chart_headers の clinic_uuid を継承して固定 */
CREATE TRIGGER tr_chart_checkups_bi_clinic
BEFORE INSERT ON chart_checkups
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT ch.clinic_uuid INTO NEW.clinic_uuid
      FROM chart_headers ch
     WHERE ch.uuid = NEW.chart_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   6) chart_items — 確定スナップ明細（点数×価格 両立）
   ---------------------------------------------------------
   CSIFH適用差分：
   - clinic_uuid 追加（NOT NULL）。INSERT時に親 chart_checkups から継承。
   - 院別絞込 INDEX を追加。
   ========================================================= */
CREATE TABLE IF NOT EXISTS chart_items (
  id                       INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                     BINARY(16) NOT NULL UNIQUE,           -- 明細UUID
  chart_checkup_uuid       BINARY(16) NOT NULL,                  -- ↔ chart_checkups.uuid
  clinic_uuid              BINARY(16) NOT NULL,                  -- 当時の院（clinics.uuid）値
  within_checkup_line_no   INT UNSIGNED NOT NULL,                -- 受診回内の行順

  source_checkup_uuid      BINARY(16) NOT NULL,                  -- 由来 checkups.uuid（監査）
  treatment_uuid           BINARY(16) NULL,                      -- 由来 treatment_master.uuid 等（任意）

  description              VARCHAR(255) NOT NULL,
  qty_unit                 VARCHAR(32) NULL,
  quantity                 DECIMAL(10,2) NOT NULL DEFAULT 1,

  pay_type                 ENUM('insurance','private') NOT NULL,
  unit_b_points            INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points            INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points          INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point            DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen           INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,

  tax_rate                 DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen             INT UNSIGNED NOT NULL DEFAULT 0,

  created_at               DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_chart_items_parent (chart_checkup_uuid, within_checkup_line_no),
  INDEX idx_ci_clinic         (clinic_uuid, chart_checkup_uuid),

  CONSTRAINT fk_chart_items_cc
    FOREIGN KEY (chart_checkup_uuid) REFERENCES chart_checkups(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

DELIMITER $$
CREATE TRIGGER tr_chart_items_bi_uuid_v7
BEFORE INSERT ON chart_items
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid) = 0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$
DELIMITER ;

DELIMITER $$
/* CSIFH: INSERT時に親 chart_checkups の clinic_uuid を継承して固定 */
CREATE TRIGGER tr_chart_items_bi_clinic
BEFORE INSERT ON chart_items
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid IS NULL OR LENGTH(NEW.clinic_uuid) = 0 THEN
    SELECT cc.clinic_uuid INTO NEW.clinic_uuid
      FROM chart_checkups cc
     WHERE cc.uuid = NEW.chart_checkup_uuid
     LIMIT 1;
  END IF;
END $$
DELIMITER ;
<<<END patches/p015.3_008.dis_to_chtit.sql>>>

<<<FILE patches/p016.4_009.ttm_mas_set.sql>>>
/* =====================================================================
   vetDB treatment_* install — p016.3 (CSIFH-PureMirror v1 / FK=master-only)
   方針:
     • clinic_uuid(BINARY(16)) を全表に追加して当時値固定
     • 子表は BEFORE INSERT で clinic_uuid を親から継承（NULL時のみ）
     • clinic_uuid は全表で更新禁止（不変ガード）
     • clinics への FK は treatment_master のみに付与（他表は付与しない）
     • 院別一覧 idx_clinic_list(clinic_uuid, deleted_at, updated_at, id)
     • disease_uuid(BINARY(16)) を維持（p016.2準拠）
   変更点:
     • treatment_master.code の一意性を院別へ: UNIQUE (clinic_uuid, code)
   前提:
     • clinics(uuid), users(uuid, clinic_uuid), disease_master(uuid) が先に存在
   ===================================================================== */

SET NAMES utf8mb4;

/* 再デプロイ安全化（依存順: 子 → 親） */
DROP TRIGGER IF EXISTS bi_treatment_set_items_uuid;
DROP TRIGGER IF EXISTS bu_treatment_set_items_rowver;
DROP TRIGGER IF EXISTS bi_treatment_sets_uuid;
DROP TRIGGER IF EXISTS bu_treatment_sets_rowver;
DROP TRIGGER IF EXISTS bi_treatment_disease_rules_uuid;
DROP TRIGGER IF EXISTS bu_treatment_disease_rules_rowver;
DROP TRIGGER IF EXISTS bi_treatment_master_uuid;
DROP TRIGGER IF EXISTS bu_treatment_master_rowver;

DROP TABLE IF EXISTS treatment_set_items;
DROP TABLE IF EXISTS treatment_sets;
DROP TABLE IF EXISTS treatment_disease_rules;
DROP TABLE IF EXISTS treatment_master;

/* =====================================================================
  1) treatment_master — 処置/薬剤マスタ（ルート）
     - clinic_uuid はアプリ必須（以後、不変）
     - clinics への FK を付与（この表のみ）
     - code は院別一意 UNIQUE(clinic_uuid, code)
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_master (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,                   -- UUIDv7(bin16)
  clinic_uuid          BINARY(16) NOT NULL,                          -- ↔ clinics.uuid（当時値・不変）
  code                 VARCHAR(50)  NOT NULL,                        -- 院内/製剤コード
  name                 VARCHAR(255) NOT NULL,                        -- 表示名
  type                 ENUM('procedure','medication') NOT NULL,      -- 区分
  qty_unit             VARCHAR(32)  NOT NULL,                        -- 単位
  default_pay_type     ENUM('insurance','private') NOT NULL DEFAULT 'insurance',

  /* 点数/価格（整数運用） */
  current_b_points     INT UNSIGNED NULL,
  current_a_points     INT UNSIGNED NULL,
  current_price_yen    INT UNSIGNED NULL,

  /* 税率（例 0.10） */
  tax_rate             DECIMAL(4,2) NOT NULL,

  /* 任意メタ（一本化: 全体向け注意・用法等） */
  dosage_per_kg        DECIMAL(10,4) NULL,                           -- 体重1kgあたり
  usage_text           TEXT NULL,

  /* 運用 */
  is_active            TINYINT(1) NOT NULL DEFAULT 1,
  created_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME  NULL,                                -- SoftDelete
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,            -- 楽観ロック

  /* 索引 */
  UNIQUE KEY uq_ttm_clinic_code (clinic_uuid, code),                  -- ★院別一意
  KEY    idx_ttm_active (is_active, name),
  KEY    idx_quality (deleted_at, updated_at, id),
  KEY    idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  /* FK（この表のみ clinics を参照） */
  CONSTRAINT fk_ttm_clinic_uuid
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_master_uuid
BEFORE INSERT ON treatment_master
FOR EACH ROW
BEGIN
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());
END$$

CREATE TRIGGER bu_treatment_master_rowver
BEFORE UPDATE ON treatment_master
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_master';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  2) treatment_disease_rules — 適用可病名（存在判定＋任意表示）
     - clinic_uuid を親（treatment_master）から継承（NULL時のみ）
     - clinics への FK は付けない
     - disease_uuid は p016.2 の方針を維持
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_disease_rules (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL UNIQUE,           -- UUIDv7(bin16)
  clinic_uuid      BINARY(16) NOT NULL,                  -- 当時値（FKなし）
  treatment_uuid   BINARY(16) NOT NULL,                  -- ↔ treatment_master.uuid
  disease_uuid     BINARY(16) NOT NULL,                  -- ↔ disease_master.uuid
  disease_specific TEXT NULL,                            -- on-label時の任意表示文（病名特異）
  is_active        TINYINT(1) NOT NULL DEFAULT 1,
  created_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME  NULL,
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tdr_pair (treatment_uuid, disease_uuid),
  KEY idx_tdr_treat (treatment_uuid),
  KEY idx_tdr_dis   (disease_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_tdr_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tdr_disease_uuid
    FOREIGN KEY (disease_uuid)   REFERENCES disease_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_disease_rules_uuid
BEFORE INSERT ON treatment_disease_rules
FOR EACH ROW
BEGIN
  DECLARE v_parent_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_master）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT tm.clinic_uuid INTO v_parent_clinic
      FROM treatment_master tm
     WHERE tm.uuid = NEW.treatment_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_parent_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_disease_rules_rowver
BEFORE UPDATE ON treatment_disease_rules
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_disease_rules';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  3) treatment_sets — 個人/共有セット（所有者: users.uuid）
     - clinic_uuid を親（users）から継承（NULL時のみ）
     - clinics への FK は付けない
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_sets (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,               -- UUIDv7(bin16)
  clinic_uuid  BINARY(16) NOT NULL,                      -- 当時値（FKなし）
  user_uuid    BINARY(16) NOT NULL,                      -- ↔ users.uuid
  name         VARCHAR(100) NOT NULL,
  note         VARCHAR(255) NULL,
  sequence_no  INT UNSIGNED NOT NULL DEFAULT 1,
  visibility   ENUM('private','shared') NOT NULL DEFAULT 'shared',
  is_active    TINYINT(1) NOT NULL DEFAULT 1,

  created_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME  NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_ts_owner (user_uuid, is_active, sequence_no),
  KEY idx_visibility (visibility),
  KEY idx_quality  (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_treatment_sets_user_uuid
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_sets_uuid
BEFORE INSERT ON treatment_sets
FOR EACH ROW
BEGIN
  DECLARE v_user_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（users）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT u.clinic_uuid INTO v_user_clinic
      FROM users u
     WHERE u.uuid = NEW.user_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_user_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_sets_rowver
BEFORE UPDATE ON treatment_sets
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_sets';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =====================================================================
  4) treatment_set_items — セット構成要素
     - clinic_uuid を親（treatment_sets）から継承（NULL時のみ）
     - clinics への FK は付けない
===================================================================== */
CREATE TABLE IF NOT EXISTS treatment_set_items (
  id              INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid            BINARY(16) NOT NULL UNIQUE,            -- UUIDv7(bin16)
  clinic_uuid     BINARY(16) NOT NULL,                   -- 当時値（FKなし）
  set_uuid        BINARY(16) NOT NULL,                   -- ↔ treatment_sets.uuid
  treatment_uuid  BINARY(16) NOT NULL,                   -- ↔ treatment_master.uuid
  sequence_no     INT UNSIGNED NOT NULL DEFAULT 1,
  preset_quantity DECIMAL(10,2) NULL,                    -- p016.2方針（10,2）

  created_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at      DATETIME  NULL,
  row_version     BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_tsi_item (set_uuid, treatment_uuid),
  KEY idx_tsi_set_seq (set_uuid, sequence_no),
  KEY idx_treatment (treatment_uuid),
  KEY idx_quality   (deleted_at, updated_at, id),
  KEY idx_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_tsi_set_uuid
    FOREIGN KEY (set_uuid)       REFERENCES treatment_sets(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT fk_tsi_treatment_uuid
    FOREIGN KEY (treatment_uuid) REFERENCES treatment_master(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER bi_treatment_set_items_uuid
BEFORE INSERT ON treatment_set_items
FOR EACH ROW
BEGIN
  DECLARE v_set_clinic BINARY(16);
  SET NEW.uuid = COALESCE(NEW.uuid, uuid_v7_bin());

  /* 親（treatment_sets）から clinic_uuid を継承（NULL時のみ設定：最低適用） */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT ts.clinic_uuid INTO v_set_clinic
      FROM treatment_sets ts
     WHERE ts.uuid = NEW.set_uuid
     LIMIT 1;
    SET NEW.clinic_uuid = v_set_clinic;
  END IF;
END$$

CREATE TRIGGER bu_treatment_set_items_rowver
BEFORE UPDATE ON treatment_set_items
FOR EACH ROW
BEGIN
  IF NEW.clinic_uuid <> OLD.clinic_uuid THEN
    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'clinic_uuid is immutable on treatment_set_items';
  END IF;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/p016.4_009.ttm_mas_set.sql>>>

<<<FILE patches/p017.3_025.receipt.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   Receipts（下書き→確定スナップ）— 統合DDL（p017.3）
   ---------------------------------------------------------
   - CSIFH-PureMirror v1: clinic_uuid を各表に保持
       drafts : farms.clinic_uuid を継承（可変／farm変更時は再継承）
       headers: 当時値固定
       checkups/items: 親から固定継承
   - FK新設は draft.farm_uuid → farms(uuid) のみ
   - ヘッダに draft 参照を保持: receipt_header_drafts_uuid（弱リンク）
   - 既存テーブル(checkups等)への ALTER は本DDLに含めない
   ========================================================= */

/* --- 再デプロイ安全化：関連トリガのDROP（存在しなくてもOK） --- */
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bu_rowver;
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_header_drafts_bi_clinic_inherit;
DROP TRIGGER IF EXISTS tr_receipt_headers_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_headers_bi_clinic_inherit;
DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_receipt_checkups_bi_clinic_inherit;
DROP TRIGGER IF EXISTS tr_receipt_items_bi_clinic_inherit;

/* --- 再デプロイ安全化：子→親の順でDROP（依存関係の都合） --- */
DROP TABLE IF EXISTS receipt_items;
DROP TABLE IF EXISTS receipt_checkups;
DROP TABLE IF EXISTS receipt_headers;
DROP TABLE IF EXISTS receipt_header_drafts;

/* =========================================================
   1) 下書きヘッダ：集計の本体（可変 / Mirror v1）
   - farm_uuid は弱リンクだが、draft に限り FK を付与
   - clinic_uuid は farm から継承（INSERT/UPDATE）
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_header_drafts (
  id                    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                  BINARY(16) NOT NULL UNIQUE,                  -- v7 UUID（下書きの識別）

  /* 任意のスコープ（印字や絞り込み用） */
  farm_uuid             BINARY(16) NULL,
  clinic_uuid           BINARY(16) NULL,                             -- 当時の所属院（可変：farm変更時に再継承）
  title                 VARCHAR(120) NULL,
  note                  VARCHAR(255) NULL,

  /* 状態遷移（発行で issued に） */
  status                ENUM('open','closed','issued') NOT NULL DEFAULT 'open',
  issued_at             DATETIME NULL,                               -- issued 遷移時刻
  issued_by_user_id     INT UNSIGNED NULL,
  issued_receipt_uuid   BINARY(16) NULL,                             -- 対応する receipt_headers.uuid（作成後にセット）

  /* クリニック設定スナップ（draft時点の値） */
  yen_per_point         DECIMAL(8,2) NOT NULL DEFAULT 10.00,         -- 例: 1点=10円
  copay_rate            DECIMAL(5,4) NOT NULL DEFAULT 0.1000,        -- 例: 10% は 0.1000
  tax_rounding          ENUM('floor','round','ceil') NOT NULL DEFAULT 'round',

  /* 集計（税抜→税→税込） */
  total_b_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_a_points        INT UNSIGNED NOT NULL DEFAULT 0,
  total_price_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 自由価格（税抜）
  subtotal_yen          INT UNSIGNED NOT NULL DEFAULT 0,             -- 点換算円 + 自由価格（税抜）
  tax_yen               INT UNSIGNED NOT NULL DEFAULT 0,
  total_insurance_yen   INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（保険）
  total_private_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 税込（自由）
  patient_copay_yen     INT UNSIGNED NOT NULL DEFAULT 0,             -- 患者負担
  insurer_pay_yen       INT UNSIGNED NOT NULL DEFAULT 0,             -- 保険者負担

  /* 監査（可変テーブルなので row_version / deleted_at を保持） */
  created_by            INT UNSIGNED NULL,
  updated_by            INT UNSIGNED NULL,
  row_version           BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at            DATETIME NULL,
  created_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at            DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 一覧最適化 */
  KEY idx_receipt_drafts_list   (deleted_at, updated_at, id),
  KEY idx_receipt_drafts_farm   (farm_uuid, deleted_at, updated_at, id),
  KEY idx_receipt_drafts_clinic (clinic_uuid, deleted_at, updated_at, id),

  /* draft にのみ farm FK（他表には貼らない） */
  CONSTRAINT fk_rcpt_drafts_farm
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bi_uuid_v7
BEFORE INSERT ON receipt_header_drafts
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 挿入時に farm → clinic を継承（弱参照 / FKはfarmにのみ） */
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO v_clinic
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_clinic;
  END IF;
END $$
DELIMITER ;

DELIMITER $$
CREATE TRIGGER tr_receipt_header_drafts_bu_rowver
BEFORE UPDATE ON receipt_header_drafts
FOR EACH ROW
BEGIN
  DECLARE v_clinic2 BINARY(16);

  /* 楽観ロック：row_version 自動インクリメント */
  SET NEW.row_version = OLD.row_version + 1;

  /* farm_uuid 変更時は clinic_uuid を再継承 */
  IF (NEW.farm_uuid <> OLD.farm_uuid) OR (NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL) THEN
    SELECT f.clinic_uuid INTO v_clinic2
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_clinic2;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   2) （ここでは ALTER を除外）既存表への付加は別ファイルで管理
   - ① checkups ALTER と ② checkup_items ALTER は本DDLから除外
   ========================================================= */

/* =========================================================
   3) 確定ヘッダ：不変スナップ（Mirror v1）
   - clinic_uuid は発行時点の当時値を固定保存
   - ヘッダ→ドラフト参照: receipt_header_drafts_uuid（弱リンク／FKなし）
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_headers (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                        BINARY(16) NOT NULL UNIQUE,            -- v7 UUID（スナップの識別）
  receipt_header_drafts_uuid  BINARY(16) NULL,                       -- 参照元ドラフト（弱リンク）
  farm_uuid                   BINARY(16) NULL,                       -- 弱リンク（将来の参照用）
  clinic_uuid                 BINARY(16) NULL,                       -- 当時の所属院（不変）
  receipt_no                  VARCHAR(40) NULL UNIQUE,               -- 任意の対外発番（UI採番）
  title                       VARCHAR(120) NULL,
  note                        VARCHAR(255) NULL,

  issued_at                   DATETIME NOT NULL,                     -- 発行日時（スナップ時刻）
  issued_by_user_id           INT UNSIGNED NULL,

  status                      ENUM('printed','voided') NULL DEFAULT NULL,  -- 未印刷(NULL)/印刷済/取消
  printed_at                  DATETIME NULL,
  printed_count               INT UNSIGNED NOT NULL DEFAULT 0,
  voided_at                   DATETIME NULL,
  void_reason                 VARCHAR(255) NULL,
  voided_by_user_id           INT UNSIGNED NULL,

  /* クリニック設定スナップ（固定） */
  yen_per_point               DECIMAL(8,2) NOT NULL,
  copay_rate                  DECIMAL(5,4) NOT NULL,
  tax_rounding                ENUM('floor','round','ceil') NOT NULL,

  /* 集計スナップ（固定） */
  total_b_points              INT UNSIGNED NOT NULL,
  total_a_points              INT UNSIGNED NOT NULL,
  total_price_yen             INT UNSIGNED NOT NULL,
  subtotal_yen                INT UNSIGNED NOT NULL,
  tax_yen                     INT UNSIGNED NOT NULL,
  total_insurance_yen         INT UNSIGNED NOT NULL,
  total_private_yen           INT UNSIGNED NOT NULL,
  patient_copay_yen           INT UNSIGNED NOT NULL,
  insurer_pay_yen             INT UNSIGNED NOT NULL,

  /* 任意：印字/レイアウト用のクリニック情報 */
  clinic_snapshot_json        JSON NULL,

  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 検索用インデックス */
  KEY idx_rcpt_hdr_draft  (receipt_header_drafts_uuid, issued_at),   -- 追跡用
  KEY idx_rcpt_hdr_issued (issued_at, id),
  KEY idx_rcpt_hdr_status (status, issued_at, id),
  KEY idx_rcpt_hdr_farm   (farm_uuid, issued_at, id),
  KEY idx_rcpt_hdr_clinic (clinic_uuid, issued_at, id)
  -- 必要なら UNIQUE(receipt_header_drafts_uuid) で「1ドラフト=1発行」を強制可
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_headers_bi_uuid_v7
BEFORE INSERT ON receipt_headers
FOR EACH ROW
BEGIN
  DECLARE v_hdr_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番 */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 発行時に farm → clinic を固定継承（アプリが直接セットしても可） */
  IF NEW.clinic_uuid IS NULL AND NEW.farm_uuid IS NOT NULL THEN
    SELECT f.clinic_uuid INTO v_hdr_clinic
      FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_hdr_clinic;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   4) 確定：チェックアップスナップ（不変 / clinic_uuid はヘッダから継承）
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_checkups (
  id                  INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                BINARY(16) NOT NULL UNIQUE,                  -- v7（items から参照）
  receipt_header_uuid BINARY(16) NOT NULL,                         -- ↔ receipt_headers.uuid（弱リンク）
  clinic_uuid         BINARY(16) NULL,                             -- 親ヘッダから固定継承
  source_checkup_uuid BINARY(16) NOT NULL,                         -- 由来：checkups.uuid
  checkup_at          DATETIME NULL,                               -- 任意：診療日時など
  individual_uuid     BINARY(16) NULL,                             -- 任意：印字補助
  individual_label    VARCHAR(120) NULL,                           -- 任意：個体表示名 等
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一ヘッダ内で同一sourceは一度だけ） */
  UNIQUE KEY uq_rcpt_hdr_src (receipt_header_uuid, source_checkup_uuid),

  KEY idx_rcpt_ckp_hdr    (receipt_header_uuid, id),
  KEY idx_rcpt_ckp_src    (source_checkup_uuid),
  KEY idx_rcpt_ckp_clinic (clinic_uuid, receipt_header_uuid, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_checkups_bi_uuid_v7
BEFORE INSERT ON receipt_checkups
FOR EACH ROW
BEGIN
  DECLARE v_ckp_clinic BINARY(16);

  /* uuid未指定なら v7 を自動採番（items が参照するため必須） */
  IF NEW.uuid IS NULL OR LENGTH(NEW.uuid)=0 THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* ヘッダから clinic_uuid を固定継承 */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT h.clinic_uuid INTO v_ckp_clinic
      FROM receipt_headers h WHERE h.uuid = NEW.receipt_header_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_ckp_clinic;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   5) 確定：行為明細スナップ（不変 / clinic_uuid はCKPから継承）
   ========================================================= */
CREATE TABLE IF NOT EXISTS receipt_items (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  receipt_checkup_uuid   BINARY(16) NOT NULL,                       -- ↔ receipt_checkups.uuid（弱リンク）
  clinic_uuid            BINARY(16) NULL,                           -- 親CKPから固定継承
  source_checkup_item_id INT UNSIGNED NOT NULL,                     -- 由来：checkup_items.id

  /* マスタ/入力の当時値スナップ（印字・再現に必要な範囲を保持） */
  description            VARCHAR(255) NOT NULL,                     -- 例: 処置/薬品名
  qty_unit               VARCHAR(32)  NULL,                         -- 例: mL, 回, 錠...
  quantity               DECIMAL(10,2) NOT NULL DEFAULT 1,

  /* 点数/自由価格の両立 */
  pay_type               ENUM('insurance','private') NOT NULL DEFAULT 'insurance',
  unit_b_points          INT UNSIGNED NOT NULL DEFAULT 0,
  unit_a_points          INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_points        INT UNSIGNED NOT NULL DEFAULT 0,
  yen_per_point          DECIMAL(8,2) NOT NULL DEFAULT 0.00,

  unit_price_yen         INT UNSIGNED NOT NULL DEFAULT 0,
  subtotal_price_yen     INT UNSIGNED NOT NULL DEFAULT 0,

  /* 税と金額（行で算出→ヘッダで合算） */
  tax_rate               DECIMAL(4,2) NOT NULL DEFAULT 0.00,
  subtotal_yen           INT UNSIGNED NOT NULL DEFAULT 0,           -- 税抜
  tax_yen                INT UNSIGNED NOT NULL DEFAULT 0,
  total_yen              INT UNSIGNED NOT NULL DEFAULT 0,           -- 税込

  note                   VARCHAR(255) NULL,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  /* 重複取り込み防止（同一チェックアップスナップ内の同一sourceは一度だけ） */
  UNIQUE KEY uq_rcptitem_ckp_src (receipt_checkup_uuid, source_checkup_item_id),

  KEY idx_rcpt_items_ckpuuid (receipt_checkup_uuid, id),
  KEY idx_rcpt_items_source  (source_checkup_item_id),
  KEY idx_rcpt_items_clinic  (clinic_uuid, receipt_checkup_uuid, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_receipt_items_bi_clinic_inherit
BEFORE INSERT ON receipt_items
FOR EACH ROW
BEGIN
  DECLARE v_item_clinic BINARY(16);

  /* 親CKPから clinic_uuid を固定継承 */
  IF NEW.clinic_uuid IS NULL THEN
    SELECT c.clinic_uuid INTO v_item_clinic
      FROM receipt_checkups c WHERE c.uuid = NEW.receipt_checkup_uuid LIMIT 1;
    SET NEW.clinic_uuid = v_item_clinic;
  END IF;
END $$
DELIMITER ;

/* =========================================================
   6) 発行（コピー）SQL — 一時テーブルなし簡易版
   ---------------------------------------------------------
   前提:
   - :draft_hex         = 対象ドラフトのUUID(HEX文字列)
   - :actor_user_id     = 発行操作ユーザーID（任意）
   - checkups.receipt_header_drafts_uuid が既に存在
   ========================================================= */

-- 参考: 発行（issue）トランザクション（INSERTのみで一括コピー）
-- START TRANSACTION;

-- 入力
-- SET @draft_uuid = uuid_hex_to_bin(:draft_hex);
-- SET @hdr_uuid   = uuid_v7_bin();

-- 1) ヘッダ作成（ドラフトの当時値をコピー。draft参照を保持）
-- INSERT INTO receipt_headers (
--   uuid, receipt_header_drafts_uuid,
--   farm_uuid, clinic_uuid,
--   receipt_no, title, note,
--   issued_at, issued_by_user_id,
--   yen_per_point, copay_rate, tax_rounding,
--   total_b_points, total_a_points, total_price_yen,
--   subtotal_yen, tax_yen, total_insurance_yen, total_private_yen,
--   patient_copay_yen, insurer_pay_yen,
--   clinic_snapshot_json
-- )
-- SELECT
--   @hdr_uuid, d.uuid,
--   d.farm_uuid,
--   d.clinic_uuid,                         -- NULLならヘッダINSERTトリガが farm→clinic を継承
--   NULL,
--   d.title, d.note,
--   COALESCE(d.issued_at, NOW()), d.issued_by_user_id,
--   d.yen_per_point, d.copay_rate, d.tax_rounding,
--   d.total_b_points, d.total_a_points, d.total_price_yen,
--   d.subtotal_yen, d.tax_yen, d.total_insurance_yen, d.total_private_yen,
--   d.patient_copay_yen, d.insurer_pay_yen,
--   NULL
-- FROM receipt_header_drafts d
-- WHERE d.uuid = @draft_uuid;

-- 2) チェックアップ・スナップ（source_checkup_uuid を保持）
-- INSERT INTO receipt_checkups (
--   uuid, receipt_header_uuid, clinic_uuid,
--   source_checkup_uuid, checkup_at,
--   individual_uuid, individual_label
-- )
-- SELECT
--   uuid_v7_bin(),
--   @hdr_uuid,
--   NULL,                                      -- トリガでヘッダの clinic_uuid を継承
--   c.uuid,
--   COALESCE(c.checkup_at, v.start_at, c.created_at),
--   c.individual_uuid,
--   NULL
-- FROM checkups c
-- LEFT JOIN visits v ON v.uuid = c.visit_uuid
-- WHERE c.receipt_header_drafts_uuid = @draft_uuid;

-- 3) 行為明細スナップ（rc.source_checkup_uuid 経由で ckps に紐付け）
-- INSERT INTO receipt_items (
--   receipt_checkup_uuid, clinic_uuid, source_checkup_item_id,
--   description, qty_unit, quantity,
--   pay_type,
--   unit_b_points, unit_a_points, subtotal_points, yen_per_point,
--   unit_price_yen, subtotal_price_yen,
--   tax_rate, subtotal_yen, tax_yen, total_yen,
--   note
-- )
-- SELECT
--   rc.uuid,                                   -- 新規 ckps に紐付け
--   NULL,                                      -- トリガで ckps の clinic_uuid を継承
--   ci.id,
--   ci.description,
--   ci.qty_unit,
--   ci.quantity,
--   ci.pay_type,
--   ci.unit_b_points,
--   ci.unit_a_points,
--   ci.subtotal_points,
--   ci.yen_per_point,
--   ci.unit_price_yen,
--   ci.subtotal_price_yen,
--   ci.tax_rate,
--   ci.subtotal_yen,
--   ci.tax_yen,
--   ci.total_yen,
--   ci.note
-- FROM checkup_items ci
-- JOIN checkups c
--   ON c.id = ci.checkup_id
-- JOIN receipt_checkups rc
--   ON rc.receipt_header_uuid = @hdr_uuid
--  AND rc.source_checkup_uuid = c.uuid
-- WHERE c.receipt_header_drafts_uuid = @draft_uuid;

-- 4) ドラフトを発行済みに更新（双方向追跡を残す）
-- UPDATE receipt_header_drafts d
-- SET d.status = 'issued',
--     d.issued_at = COALESCE(d.issued_at, NOW()),
--     d.issued_by_user_id = COALESCE(d.issued_by_user_id, :actor_user_id),
--     d.issued_receipt_uuid = @hdr_uuid
-- WHERE d.uuid = @draft_uuid;

-- COMMIT;
<<<END patches/p017.3_025.receipt.sql>>>

<<<FILE patches/p018.3_012.clinics_sett.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   vetDB — p018.2  clinics / clinic_settings（UUID不変版）
   ---------------------------------------------------------
   目的:
   - clinics.uuid を「不変」にする（UPDATEでの連鎖事故を防止）
   - clinic_settings は 1院1行（clinic_uuid UNIQUE）
   - コード/照合/行フォーマットは全体方針に準拠
     ENGINE=InnoDB, CHARSET=utf8mb4, COLLATE=utf8mb4_unicode_ci, ROW_FORMAT=DYNAMIC

   注意:
   - 本DDLは新規インストール想定。既存環境では ALTER に分解してください。
   - クリニックの追加採番は uuid_v7_bin() を用いるため、先に関数を用意しておくこと。
   ========================================================= */

/* 再デプロイ安全化（存在すればDROP） */
DROP TRIGGER IF EXISTS tr_clinics_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_clinics_bu_rowver;
DROP TABLE   IF EXISTS clinic_settings;
DROP TABLE   IF EXISTS clinics;

/* =========================================================
   clinics — クリニック（院）マスタ
   ---------------------------------------------------------
   方針:
   - uuid はアプリ内の主識別子。**不変**（UPDATEで変更させない）。
   - subdomain / custom_domain は NULL許容の一意制約（いずれか利用）。
   - 一覧/差分系の標準索引 (deleted_at, updated_at, id) を付与。
   - row_version は楽観ロック/差分検知用に+1する。
   ========================================================= */
CREATE TABLE clinics (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL,                 -- ★不変／更新不可（トリガで固定）
  name              VARCHAR(120) NOT NULL,               -- 例: 〇〇動物病院
  phone             VARCHAR(50)  NULL,
  email             VARCHAR(255) NULL,

  /* サブドメイン/独自ドメイン（どちらも任意／NULL重複OK、値が入れば一意） */
  subdomain         VARCHAR(63)  NULL,
  custom_domain     VARCHAR(255) NULL,

  postal_code       VARCHAR(16)  NULL,
  address_line1     VARCHAR(255) NULL,
  address_line2     VARCHAR(255) NULL,

  notes             TEXT NULL,                           -- 院内メモ（公開しない想定）

  /* 監査・運用列 */
  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at        DATETIME NULL,
  row_version       BIGINT UNSIGNED NOT NULL DEFAULT 1,

  /* 一意/索引 */
  UNIQUE KEY uq_clinics_uuid          (uuid),
  UNIQUE KEY uq_clinics_subdomain     (subdomain),
  UNIQUE KEY uq_clinics_custom_domain (custom_domain),
  KEY        idx_clinics_list         (deleted_at, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/* UUID自動採番（未指定時のみ） */
DELIMITER $$
CREATE TRIGGER tr_clinics_bi_uuid_v7
BEFORE INSERT ON clinics
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

/* UUID不変＋row_versionインクリメント（★重要） */
DELIMITER $$
CREATE TRIGGER tr_clinics_bu_rowver
BEFORE UPDATE ON clinics
FOR EACH ROW
BEGIN
  /* UUIDは不変：誤更新による連鎖CASCADE事故を防止 */
  SET NEW.uuid = OLD.uuid;
  /* 楽観ロック／差分検知 */
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;

/* =========================================================
   clinic_settings — 院ごとの運用/帳票設定（1院1行）
   ---------------------------------------------------------
   方針:
   - clinic_uuid UNIQUE で 1院1行。
   - 請求点数/自費レート/税率/端数処理などを保持（最低限）。
   - 帳票系: ロゴパス/フッター文/請求窓口担当/インボイス登録番号 等。
   - FKは clinics(uuid) に対して ON UPDATE CASCADE / ON DELETE RESTRICT。
   - row_version は編集ごとに+1。
   ========================================================= */
CREATE TABLE clinic_settings (
  id                           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                  BINARY(16) NOT NULL,     -- ↔ clinics.uuid（1院1行）
  /* 会計系既定値 */
  yen_per_point                DECIMAL(8,2) NOT NULL DEFAULT 0.00,
  copay_rate                   DECIMAL(5,2) NOT NULL DEFAULT 0.00,   -- 例: 30.00 (=30%)
  default_tax_rate             DECIMAL(4,2) NOT NULL DEFAULT 0.00,   -- 例: 10.00 (=10%)
  price_rounding               ENUM('none','round','ceil','floor') NOT NULL DEFAULT 'round',
  price_rounding_unit          INT UNSIGNED NOT NULL DEFAULT 1,      -- 1/10/100 など

  /* 帳票/表示 */
  billing_contact_name         VARCHAR(128) NULL,       -- 請求窓口担当者名（運用表示）
  invoice_logo_path            VARCHAR(255) NULL,       -- 帳票ロゴ（S3等のパス）
  receipt_footer_text          VARCHAR(255) NULL,       -- レシート定型フッター
  invoice_registration_number  VARCHAR(14)  NULL,       -- 例: 'T' + 13桁

  /* 監査・運用列 */
  created_at                   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at                   DATETIME NULL,
  row_version                  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  /* 一意/索引/FK */
  UNIQUE KEY uq_clinic_settings_clinic (clinic_uuid),
  KEY        idx_clinic_settings_list  (deleted_at, updated_at, id),
  CONSTRAINT fk_clinic_settings_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT,

  /* 任意: インボイス登録番号の形式検証（対応エンジンのみ有効） */
  CONSTRAINT chk_clinic_settings_invoice_reg
    CHECK (invoice_registration_number IS NULL
           OR invoice_registration_number REGEXP '^T[0-9]{13}$')
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/* row_versionのインクリメント（UUIDは保持していないため固定不要） */
DELIMITER $$
DROP TRIGGER IF EXISTS tr_clinic_settings_bu_rowver;
CREATE TRIGGER tr_clinic_settings_bu_rowver
BEFORE UPDATE ON clinic_settings
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;
<<<END patches/p018.3_012.clinics_sett.sql>>>

<<<FILE patches/p019.2_013.insu_enro.sql>>>
SET NAMES utf8mb4;

/* ======================================================================
   Insurance Enrollment — Fresh Install (Global / Tenant = FARM via farm_uuid)
   ----------------------------------------------------------------------
   方針
     • テナントは farm 単位（farm_uuid: BINARY(16)）。
     • 多病院表示は farms 側の clinic_uuid を参照（本テーブルには保持しない＝グローバル）。
     • 代表行は farm 単位で決定（today-valid優先→end DESC→start DESC→id DESC）。
     • 監査/整合: v1p9 準拠（row_version, deleted_at, list index）。
   前提
     • MySQL 8.0+（ウィンドウ関数使用）
     • farms(uuid) が存在
   ====================================================================== */

/* 0) 依存ビューを先にDROP（再定義のため） */
DROP VIEW IF EXISTS `insurance_current_status`;
DROP VIEW IF EXISTS `insurance_current`;

/* 1) 本体テーブル：グローバル（clinic列は持たない） */
DROP TABLE IF EXISTS `insurance_enrollments`;
CREATE TABLE IF NOT EXISTS `insurance_enrollments` (
  /* 識別子（AUTO_INCREMENT 主キー） */
  `id` INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  /* テナント（FARM単位, BINARY(16) UUIDv7想定） */
  `farm_uuid` BINARY(16) NOT NULL,

  /* 加入者コード（共済番号など8桁を想定） */
  `subscriber_code` CHAR(8) NOT NULL,

  /* 入力ステータス（英語ENUM：入力値の状態） */
  `status` ENUM('insured','non_insured','unknown') NOT NULL DEFAULT 'unknown',

  /* 期間（端NULL許容）— 両端NULLは today-valid とみなす */
  `start_date` DATE NULL,
  `end_date`   DATE NULL,

  /* 任意付帯 */
  `fiscal_year` YEAR NULL,
  `source_note` VARCHAR(255) NULL,

  /* 無効化(取消)と理由 — voided 行は代表選定から除外 */
  `voided_at`   DATETIME NULL,
  `void_reason` VARCHAR(255) NULL,

  /* v1p9: 楽観ロック & 論理削除 & 監査 */
  `row_version` BIGINT UNSIGNED NOT NULL DEFAULT 1,
  `deleted_at`  DATETIME NULL,
  `created_by`  INT UNSIGNED NULL,
  `created_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  /* 期間検索・代表化前の絞り込みで有効 */
  INDEX `idx_farm_dates` (`farm_uuid`, `start_date`, `end_date`),

  /* コード検索・監査用 */
  INDEX `idx_code` (`subscriber_code`),

  /* 一覧最適化（差分同期や更新順ソート） */
  KEY `idx_enroll_list` (`deleted_at`, `updated_at`, `id`),

  /* 期間整合性（NULLはスルー） */
  CHECK ( `start_date` IS NULL OR `end_date` IS NULL OR `start_date` <= `end_date` ),

  /* FK（維持）：farm_uuid → farms.uuid */
  CONSTRAINT `fk_ins_enro_farm`
    FOREIGN KEY (`farm_uuid`) REFERENCES `farms`(`uuid`)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
  ROW_FORMAT=DYNAMIC;

/* 2) トリガ — row_version 自動インクリメント（clinic継承系は削除済み） */
DROP TRIGGER IF EXISTS `tr_insurance_enrollments_rowver_bu`;
DELIMITER $$
CREATE TRIGGER `tr_insurance_enrollments_rowver_bu`
BEFORE UPDATE ON `insurance_enrollments`
FOR EACH ROW
BEGIN
  SET NEW.`row_version` = OLD.`row_version` + 1;
END$$
DELIMITER ;

/* 3) 代表1行ビュー（グローバル：farm単位、clinic非依存） */
CREATE VIEW `insurance_current` AS
WITH ranked AS (
  SELECT
    e.*,
    /* 今日有効？（端NULL許容） */
    CASE
      WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
       AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
      THEN 1 ELSE 0
    END AS is_today_valid,
    /* 代表順位: today-valid → end DESC → start DESC → id DESC */
    ROW_NUMBER() OVER (
      PARTITION BY e.farm_uuid
      ORDER BY
        CASE
          WHEN (e.start_date IS NULL OR e.start_date <= CURDATE())
           AND (e.end_date   IS NULL OR e.end_date   >= CURDATE())
          THEN 0 ELSE 1
        END,
        COALESCE(e.end_date,  '9999-12-31') DESC,
        COALESCE(e.start_date,'9999-12-31') DESC,
        e.id DESC
    ) AS rn
  FROM `insurance_enrollments` e
  WHERE e.voided_at IS NULL AND e.deleted_at IS NULL
)
SELECT
  r.id,
  r.farm_uuid,
  r.subscriber_code,
  r.status,
  r.start_date,
  r.end_date,
  r.fiscal_year,
  r.source_note,
  r.voided_at,
  r.void_reason,
  r.row_version,
  r.deleted_at,
  r.created_by,
  r.created_at,
  r.updated_at,
  r.is_today_valid,
  CASE WHEN r.end_date IS NULL THEN NULL
       ELSE DATEDIFF(r.end_date, CURDATE())
  END AS days_to_end
FROM ranked r
WHERE r.rn = 1;

/* 4) ラベルビュー（clinic列なし／グローバル） */
CREATE VIEW `insurance_current_status` AS
SELECT
  c.farm_uuid,
  c.subscriber_code,
  c.start_date,
  c.end_date,
  c.days_to_end,
  CASE
    WHEN c.is_today_valid = 1 THEN 'active'
    WHEN c.end_date IS NOT NULL AND c.end_date < CURDATE() THEN 'renewal_overdue'
    WHEN c.end_date IS NOT NULL
         AND c.end_date >= CURDATE()
         AND c.end_date <= (CURDATE() + INTERVAL 30 DAY)
      THEN 'renewal_due_soon'
    WHEN c.status = 'non_insured' THEN 'non_insured'
    WHEN c.status = 'insured'     THEN 'insured'
    ELSE 'unknown'
  END AS current_status
FROM `insurance_current` c;
<<<END patches/p019.2_013.insu_enro.sql>>>

<<<FILE patches/p020.2_020.fa_us_ind_mir.sql>>>
SET NAMES utf8mb4;

/* =========================================================
   VetDB — SoT + farmDB mirrors
   CSIFH-PureMirror v1 適用／p020.1 改修 完全DDL（長文コメント付き）
   ---------------------------------------------------------
   ■このファイルの目的
     - 「多病院対応（CSIFH）」と「farmDB純ミラー運用」を、p020.1系の
       SoT/Mirror 構成へ反映した“新規インストール用DDL”を提示します。
     - farm_users の clinic 参照は「冗長な二重FK」を避けるため、
       親 farms への【合成FK】(farm_uuid, clinic_uuid) を採用します。
       （= 子の clinic は必ず親の clinic と一致する）

   ■CSIFH-PureMirror v1 の要点（再掲）
     1) SoTは clinic_uuid を NOT NULL + FK（院所属を厳格化）
     2) Mirrorは farmDB の値を無加工で保持（clinic_uuid を含む／NULL可）
        → FK/推定/トリガは一切つけない“純ミラー”
     3) 可視性は常に「clinic一致」。NULLは誰にも見えない（未所属BOXのみ）。
     4) 履歴は chart_headers/visits の clinic_uuid で算出（mirrorに依存しない）
     5) 取り込み・突合のために entity_links を採用（院越境はDBで拒否）

   ■本DDLで定義するテーブル
     - SoT:        farms, vet_users, farm_users
     - Mirrors:    farmdb_farms_mirror, farmdb_individuals_mirror, farmdb_farm_users_mirror
     - Link-Table: entity_links（remote⇔local 1:1 対応／院スコープ厳格）

   ■前提（必須）
     - clinics(uuid BINARY(16)) が存在していること
     - 関数 uuid_v7_bin() が存在していること
     - individuals（SoT）が未導入の場合でも本DDLは動作しますが、
       entity_links のトリガの「individual分岐」を使う際は individuals が必要です。
       （必要なければ individual 分岐は利用しない／あとから有効化してください）
   ========================================================= */


/* =========================================================
 0) farms — SoT（個体/請求の基点）
   ---------------------------------------------------------
   ■設計方針
     - すべてのSoTは clinic 所属を厳格化 → clinic_uuid NOT NULL + FK。
     - farm は院付け替えがあり得るため ON UPDATE CASCADE / ON DELETE RESTRICT。
     - 一覧・差分同期向けの標準インデックスを付与。
     - farm_users からの【合成FK】の参照先となるため、
       (uuid, clinic_uuid) の UNIQUE を追加（MySQLの合成FK要件）。

   ■主な索引
     - uq_farms_uuid           : uuidの一意性（アプリ内での主識別子）
     - uq_farms_uuid_clinic    : 合成FKの参照先（farm_usersから参照）
     - idx_farms_clinic_list   : 院別一覧（deleted_at, updated_at併用）
   ========================================================= */
DROP TABLE IF EXISTS farms;
CREATE TABLE farms (
  id               INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid             BINARY(16) NOT NULL,
  clinic_uuid      BINARY(16) NOT NULL,              -- ↔ clinics.uuid（院所属・厳格）
  name             VARCHAR(120) NOT NULL,
  billing_name     VARCHAR(120) NULL,
  billing_address  VARCHAR(255) NULL,

  row_hash         CHAR(64) NULL,                    -- 任意：差分検出や外部同期の補助
  created_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at       DATETIME NULL,                    -- ソフトデリート（論理削除）
  row_version      BIGINT UNSIGNED NOT NULL DEFAULT 1, -- 楽観ロック/差分検知

  UNIQUE KEY uq_farms_uuid (uuid),
  /* 合成FKの参照先要件を満たすため、(uuid, clinic_uuid) を UNIQUE にする */
  UNIQUE KEY uq_farms_uuid_clinic (uuid, clinic_uuid),

  KEY idx_farms_name (name),
  KEY idx_farms_list (deleted_at, updated_at, id),
  KEY idx_farms_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_farms_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farms_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farms_bi_uuid_v7
BEFORE INSERT ON farms
FOR EACH ROW
BEGIN
  /* UUIDはBINARY(16)/v7想定。未指定時のみ自動採番。 */
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farms_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farms_bu_rowver_lockuuid
BEFORE UPDATE ON farms
FOR EACH ROW
BEGIN
  /* UUIDは不変・row_versionは+1。clinic_uuidの付け替えはFKが整合性を担保。 */
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
 1) vet_users — SoT（獣医・院内ユーザー）
   ---------------------------------------------------------
   ■設計方針
     - すべての vet_users は必ず clinic に所属（NOT NULL + FK）。
     - 一覧・検索キー（display_name/email）を付与。
     - row_version による編集競合検知。

   ■注意
     - 認証やロールはアプリ層/別テーブルで扱う想定。本テーブルは基本プロフィール。
   ========================================================= */
DROP TABLE IF EXISTS vet_users;
CREATE TABLE vet_users (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid               BINARY(16) NOT NULL,
  clinic_uuid        BINARY(16) NOT NULL,            -- ↔ clinics.uuid
  display_name       VARCHAR(100) NOT NULL,
  email              VARCHAR(255) NULL,
  phone              VARCHAR(50) NULL,
  role_label         VARCHAR(100) NULL,              -- 例: 院長/獣医師/スタッフ
  clinic_branch_name VARCHAR(120) NULL,              -- 分院メモ（UI補助）

  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at         DATETIME NULL,
  row_version        BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_vet_users_uuid (uuid),
  KEY idx_vet_users_name (display_name),
  KEY idx_vet_users_email (email),
  KEY idx_vet_users_list (deleted_at, updated_at, id),
  KEY idx_vet_users_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  CONSTRAINT fk_vet_users_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_vet_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bi_uuid_v7
BEFORE INSERT ON vet_users
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_vet_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_vet_users_bu_rowver_lockuuid
BEFORE UPDATE ON vet_users
FOR EACH ROW
BEGIN
  SET NEW.uuid = OLD.uuid;
  SET NEW.row_version = OLD.row_version + 1;
END$$
DELIMITER ;


/* =========================================================
 2) farm_users — SoT（農家ユーザー：farmに従属）
   ---------------------------------------------------------
   ■設計方針（重要）
     - farm_users は必ず「どこかの farm に所属」し、結果として clinic も決まる。
     - 子側に clinic_uuid を持たせるのは「院別スコープ検索の高速化」のため。
     - ただし clinics への単独FKは冗長。代わりに【合成FK】を採用し、
       子(farm_uuid, clinic_uuid) → 親(farms.uuid, farms.clinic_uuid) を強制一致。
     - 親farmの付け替えや clinic の変更に対して、ON UPDATE CASCADE で追随。

   ■合成FKの効果
     - 「子のclinicと親のclinicの不一致」をDBが拒否（アプリのバグ耐性）
     - clinics への重複FKを排除し、参照経路を親farmに集約（スキーマ簡潔）

   ■トリガ
     - 挿入/親変更時に、親farmから clinic_uuid を自動継承（書き忘れ防止）。
   ========================================================= */
DROP TABLE IF EXISTS farm_users;
CREATE TABLE farm_users (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL,

  farm_uuid    BINARY(16) NOT NULL,                 -- ↔ farms.uuid
  clinic_uuid  BINARY(16) NOT NULL,                 -- 院スコープ検索用に保持（親から継承）

  display_name VARCHAR(100) NOT NULL,
  email        VARCHAR(255) NULL,
  phone        VARCHAR(50) NULL,
  role_label   VARCHAR(100) NULL,                   -- 例: 場長/経理/担当

  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  UNIQUE KEY uq_farm_users_uuid (uuid),
  KEY idx_farm_users_farm (farm_uuid, display_name),
  KEY idx_farm_users_email (email),
  KEY idx_farm_users_list (deleted_at, updated_at, id),
  KEY idx_farm_users_clinic_list (clinic_uuid, deleted_at, updated_at, id),

  /* ☆合成FK：子(farm_uuid, clinic_uuid) → 親(farms.uuid, farms.clinic_uuid) */
  CONSTRAINT fk_fu_farm_clinic
    FOREIGN KEY (farm_uuid, clinic_uuid)
    REFERENCES farms (uuid, clinic_uuid)
    ON UPDATE CASCADE
    ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DROP TRIGGER IF EXISTS tr_farm_users_bi_uuid_v7;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bi_uuid_v7
BEFORE INSERT ON farm_users
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;

  /* 親farmから clinic_uuid を継承（手入力・取り違えの防止） */
  SELECT f.clinic_uuid INTO v_clinic
    FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  SET NEW.clinic_uuid = v_clinic;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_farm_users_bu_rowver_lockuuid;
DELIMITER $$
CREATE TRIGGER tr_farm_users_bu_rowver_lockuuid
BEFORE UPDATE ON farm_users
FOR EACH ROW
BEGIN
  DECLARE v_clinic BINARY(16);

  SET NEW.uuid = OLD.uuid;                    -- UUIDは不変
  SET NEW.row_version = OLD.row_version + 1;  -- 楽観ロック

  /* 親farmの変更や親側clinic付け替えに追随（再継承） */
  SELECT f.clinic_uuid INTO v_clinic
    FROM farms f WHERE f.uuid = NEW.farm_uuid LIMIT 1;
  SET NEW.clinic_uuid = v_clinic;
END$$
DELIMITER ;


/* =========================================================
 3) farmDB mirrors — farms（READ ONLY / 純ミラー）
   ---------------------------------------------------------
   ■設計方針
     - farmDBが正（SoT）。本ミラーは farmDB の列・値を無加工で保持。
     - clinic_uuid は farmDBの値をそのまま（NULL可）。FK/推定/トリガなし。
     - 院スコープ一覧・差分取込・名前検索を想定した索引のみ付与。
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farms_mirror;
CREATE TABLE farmdb_farms_mirror (
  id                INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid              BINARY(16) NOT NULL UNIQUE,     -- farmDB側 farm.uuid
  clinic_uuid       BINARY(16) NULL,                -- farmDBの値そのまま（NULL可）
  name              VARCHAR(120) NOT NULL,
  billing_name      VARCHAR(120) NULL,
  billing_address   VARCHAR(255) NULL,
  deleted_at        DATETIME NULL,                  -- 外部削除の鏡像（tombstone）
  updated_at_source DATETIME NULL,                  -- farmDB側の更新時刻（差分カーソル用）

  created_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_fdb_farms_clinic_list (clinic_uuid, deleted_at, updated_at, id),
  KEY idx_fdb_farms_updated     (updated_at_source),
  KEY idx_fdb_farms_name        (name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;


/* =========================================================
 4) farmDB mirrors — individuals（READ ONLY / 純ミラー）
   ---------------------------------------------------------
   ■設計方針
     - clinic_uuid は farmDBの値をそのまま（NULL可）。FK/推定/トリガなし。
     - 耳標の品質（外部の一意性担保）に依存するため UNIQUE は置かず、通常INDEX。
     - 性別・状態は v1p10/v1p5 の整合に合わせた ENUM 定義を採用。

   ■注意
     - row_version は“同期監視用の軽量フラグ”として保持（厳密ロック用途ではない）。
   ========================================================= */
DROP TABLE IF EXISTS farmdb_individuals_mirror;
CREATE TABLE farmdb_individuals_mirror (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid                 BINARY(16) NOT NULL UNIQUE,
  clinic_uuid          BINARY(16) NULL,             -- farmDB由来（NULL可）
  farm_uuid            BINARY(16) NOT NULL,         -- 参照先もfarmDBのUUID（FKなし）
  user_uuid            BINARY(16) NULL,

  name                 VARCHAR(100) NULL,
  ear_tag              CHAR(10) NULL,
  status               ENUM('active','sold','dead','culled') NOT NULL DEFAULT 'active',
  gender               ENUM('female','male','cast','unknown') NOT NULL DEFAULT 'unknown',
  birth_date           DATE NULL,
  death_date           DATE NULL,
  sire_name            VARCHAR(100) NULL,

  genetic_dam_uuid     BINARY(16) NULL,
  nursing_dam_uuid     BINARY(16) NULL,
  genetic_dam_ear_tag  CHAR(10) NULL,
  genetic_dam_name     VARCHAR(100) NULL,
  nursing_dam_ear_tag  CHAR(10) NULL,
  nursing_dam_name     VARCHAR(100) NULL,

  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at           DATETIME NULL,
  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_fdb_individuals_clinic_list (clinic_uuid, deleted_at, updated_at, id),
  KEY idx_fdb_individuals_farm        (farm_uuid, name),
  KEY idx_fdb_individuals_birth       (birth_date),
  KEY idx_fdb_individuals_ear_tag     (ear_tag),
  KEY idx_fdb_individuals_parents     (genetic_dam_uuid, nursing_dam_uuid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;


/* =========================================================
 5) farmDB mirrors — farm_users（READ ONLY / 純ミラー）
   ---------------------------------------------------------
   ■設計方針
     - ミラーは常に無加工。clinic_uuid は farmDBの値のまま（NULL可）。
     - FK/推定/トリガなし。院スコープ・farm紐付け・メール検索向けの索引のみ。
   ========================================================= */
DROP TABLE IF EXISTS farmdb_farm_users_mirror;
CREATE TABLE farmdb_farm_users_mirror (
  id           INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  uuid         BINARY(16) NOT NULL UNIQUE,
  clinic_uuid  BINARY(16) NULL,            -- farmDB由来（NULL可）
  farm_uuid    BINARY(16) NOT NULL,
  display_name VARCHAR(100) NOT NULL,
  email        VARCHAR(255) NULL,
  phone        VARCHAR(50) NULL,
  role_label   VARCHAR(100) NULL,

  created_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at   DATETIME NULL,
  row_version  BIGINT UNSIGNED NOT NULL DEFAULT 1,

  KEY idx_fdb_farm_users_clinic_list (clinic_uuid, deleted_at, updated_at, id),
  KEY idx_fdb_farm_users_farm        (farm_uuid, display_name),
  KEY idx_fdb_farm_users_email       (email)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;


/* =========================================================
 6) entity_links — remote(mirror) と local(SoT) の対応表
   ---------------------------------------------------------
   ■役割
     - farmDBミラー（remote）と VetDB SoT（local）の 1:1 対応表。
     - 取り込み/突合/逆同期の基盤。院越境はDBで拒否。
     - clinic_uuid は「local側から強制確定」。手入力は不可（トリガで上書き）。

   ■制約
     - remote重複禁止: UNIQUE(entity_type, source_system, remote_uuid)
     - 院越境禁止: remote側にclinicが付いており、localと不一致なら拒否。
       （remote側がNULLのときは“未所属→収容”のため許容）

   ■備考
     - entity_type に 'individual' を含みます。individuals（SoT）が未導入の環境では
       当面 'farm' / 'farm_user' での運用に限定するか、individual分岐の使用を控えてください。
   ========================================================= */
DROP TABLE IF EXISTS entity_links;
CREATE TABLE entity_links (
  id            BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

  clinic_uuid   BINARY(16) NOT NULL,                  -- ← local 由来（トリガで確定）
  entity_type   ENUM('farm','individual','farm_user') NOT NULL,
  source_system ENUM('farmdb') NOT NULL DEFAULT 'farmdb',

  local_uuid    BINARY(16) NOT NULL,                  -- VetDB SoT 側 UUID
  remote_uuid   BINARY(16) NOT NULL,                  -- farmDB mirror 側 UUID

  is_primary    TINYINT(1) NOT NULL DEFAULT 1,        -- 将来: 多対1許容時の“主”印
  note          VARCHAR(255) NULL,

  created_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_entity_links_remote (entity_type, source_system, remote_uuid),
  KEY idx_entity_links_local  (entity_type, local_uuid),
  KEY idx_entity_links_clinic (clinic_uuid, entity_type, updated_at, id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

/* ▼スコープ/整合トリガ
   - 挿入/更新の度に、local側から clinic_uuid を確定し、remote側clinicとの越境を拒否。
   - 'individual' 分岐は individuals（SoT）が存在する前提。未導入なら当面使用しないか、
     分岐をコメントアウトして適用してください。 */
DROP TRIGGER IF EXISTS tr_entity_links_bi_scope;
DELIMITER $$
CREATE TRIGGER tr_entity_links_bi_scope
BEFORE INSERT ON entity_links
FOR EACH ROW
BEGIN
  DECLARE v_local_clinic  BINARY(16);
  DECLARE v_remote_clinic BINARY(16);

  /* 1) local 側 clinic を確定（entity_typeに応じて参照先が異なる） */
  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farms WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      /* farm_users は合成FKにより (farm_uuid, clinic_uuid) が親と常に一致 */
      SELECT clinic_uuid INTO v_local_clinic
        FROM farm_users WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'individual' THEN
      /* 注意: individuals（SoT）が必要。未導入ならこの分岐は利用しないこと。 */
      SELECT f.clinic_uuid INTO v_local_clinic
        FROM individuals i
        JOIN farms f ON f.uuid = i.farm_uuid
       WHERE i.uuid = NEW.local_uuid
       LIMIT 1;
  END CASE;
  SET NEW.clinic_uuid = v_local_clinic;

  /* 2) remote 側 clinic を取得して院越境を拒否（NULLは許容＝未所属→収容） */
  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farms_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farm_users_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_individuals_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;
  END CASE;

  IF v_remote_clinic IS NOT NULL AND v_remote_clinic <> v_local_clinic THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Cross-clinic link is not allowed';
  END IF;
END$$
DELIMITER ;

DROP TRIGGER IF EXISTS tr_entity_links_bu_scope;
DELIMITER $$
CREATE TRIGGER tr_entity_links_bu_scope
BEFORE UPDATE ON entity_links
FOR EACH ROW
BEGIN
  DECLARE v_local_clinic  BINARY(16);
  DECLARE v_remote_clinic BINARY(16);

  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farms WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_local_clinic
        FROM farm_users WHERE uuid = NEW.local_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT f.clinic_uuid INTO v_local_clinic
        FROM individuals i
        JOIN farms f ON f.uuid = i.farm_uuid
       WHERE i.uuid = NEW.local_uuid
       LIMIT 1;
  END CASE;
  SET NEW.clinic_uuid = v_local_clinic;

  CASE NEW.entity_type
    WHEN 'farm' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farms_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'farm_user' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_farm_users_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;

    WHEN 'individual' THEN
      SELECT clinic_uuid INTO v_remote_clinic
        FROM farmdb_individuals_mirror WHERE uuid = NEW.remote_uuid LIMIT 1;
  END CASE;

  IF v_remote_clinic IS NOT NULL AND v_remote_clinic <> v_local_clinic THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Cross-clinic link is not allowed';
  END IF;
END$$
DELIMITER ;
<<<END patches/p020.2_020.fa_us_ind_mir.sql>>>

<<<FILE patches/p021_014.appo.sql>>>
SET NAMES utf8mb4;

-- =========================================================
-- vetDB v1p7-mt — Google Calendar（代表アカウント×共有カレンダー）
-- 方針：
--  - 予定(appointments)は clinic/farm が消えても残す → ON DELETE SET NULL
--  - 連携側（tokens/settings/sync_state/AEL/fulfillments）は親が消えたら掃除 → ON DELETE CASCADE
--  - 付け替え＝「連携病院を変えたら、その時点以降に作られた予定のみ連携」
--  - すべて ROW_FORMAT=DYNAMIC / utf8mb4_unicode_ci
--  - uuid_v7_bin() が無ければ UUID_TO_BIN(UUID(), TRUE) に置換可
--
-- 【WORKER PLAYBOOK（概要）】
--  1) 同期対象の抽出
--     SELECT * FROM appointments ap
--      WHERE ap.deleted_at IS NULL
--        AND ap.clinic_uuid IS NOT NULL             -- 連携有効フラグ
--        AND ap.start_at >= NOW() - INTERVAL 1 DAY; -- 任意の再送ウィンドウ
--
--  2) 連携に必要な設定の取得（テナント＝ap.clinic_uuid）
--     - clinic_google_tokens: 代表トークンを取得・リフレッシュ
--     - clinic_calendar_settings: calendar_id を取得
--
--  3) AEL（リンク表）のアップサート・冪等化
--     - まず AEL を (clinic_uuid, appointment_uuid, google_calendar_id) で検索
--     - 無ければ Google の events.list を
--       privateExtendedProperty=appointment_uuid=<ap.uuid> で再探索
--       見つかれば update、無ければ insert
--     - payload には extendedProperties.private.appointment_uuid を必ず設定
--     - 成功後、AEL: google_event_id, etag, status='synced', synced_at を更新
--
--  4) 削除・キャンセル
--     - DBで ap.deleted_at IS NOT NULL または ap.status='cancelled' を検出したら
--       Google events.delete → AEL.status='deleted' に更新（必要ならAEL削除）
--
--  5) 差分同期（任意）
--     - calendar_sync_state(sync_token) を使い、events.list(syncToken=...) で追加/更新/削除を取り込み
--     - 410 Gone ならフルからやり直して新しい nextSyncToken を保存
--
--  6) 連携病院の付け替え（運用）
--     - farms.clinic_uuid を新クリニックへ更新
--     - 既存の未来予定は appointments.clinic_uuid=NULL で“連携停止”（以後の新規のみ連携）
--     - 既存AELは削除（以後の誤更新防止）
--       DELETE ael FROM appointment_event_links ael
--       JOIN appointments ap ON ap.uuid=ael.appointment_uuid
--        WHERE ap.farm_uuid=:farm AND ap.start_at>=NOW() AND ap.deleted_at IS NULL;
-- =========================================================


/* ---------- 事前：既存トリガを落とす（再作成のため） ---------- */
DROP TRIGGER IF EXISTS tr_appointments_bi_uuid_v7;
DROP TRIGGER IF EXISTS tr_appointments_bu_rowver;
DROP TRIGGER IF EXISTS tr_clinic_google_tokens_bu_rowver;
DROP TRIGGER IF EXISTS tr_clinic_calendar_settings_bu_rowver;
DROP TRIGGER IF EXISTS tr_appointment_event_links_bu_rowver;
DROP TRIGGER IF EXISTS tr_calendar_sync_state_bu_rowver;
DROP TRIGGER IF EXISTS tr_appointment_fulfillments_bu_rowver;

/* ---------- 依存の深い順にDROP ---------- */
DROP TABLE IF EXISTS appointment_fulfillments;
DROP TABLE IF EXISTS appointment_event_links;
DROP TABLE IF EXISTS calendar_sync_state;
DROP TABLE IF EXISTS clinic_calendar_settings;
DROP TABLE IF EXISTS clinic_google_tokens;
DROP TABLE IF EXISTS appointments;


/* =========================================================
   1) 予定本体（Appointments = Googleへ送る元）
   - clinic_uuid / farm_uuid は ON DELETE SET NULL（予定を残す）
   - clinic_uuid IS NULL は“連携停止”を意味する（ワーカーは同期しない）
   ========================================================= */
CREATE TABLE appointments (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                 BINARY(16) NULL,               -- ↔ clinics.uuid（SET NULL方針）
  uuid                        BINARY(16) NOT NULL UNIQUE,    -- 予定の一意ID（v7推奨）
  farm_uuid                   BINARY(16) NULL,               -- ↔ farms.uuid（SET NULL）
  individual_uuid             BINARY(16) NULL,               -- ↔ individuals.uuid（SET NULL）
  organizer_vet_user_uuid     BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）
  created_by_vet_uuid         BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）
  updated_by_vet_user_uuid    BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）

  title                       VARCHAR(255) NOT NULL,
  note                        TEXT NULL,
  location_text               VARCHAR(255) NULL,
  start_at                    DATETIME NOT NULL,             -- UTC
  end_at                      DATETIME NOT NULL,             -- UTC
  time_zone                   VARCHAR(64) NULL,              -- 例: 'Asia/Tokyo'
  status                      ENUM('draft','scheduled','cancelled','archived')
                                NOT NULL DEFAULT 'scheduled',

  row_version                 BIGINT UNSIGNED NOT NULL DEFAULT 1,
  deleted_at                  DATETIME NULL,
  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_appt_list (deleted_at, updated_at, id),
  KEY idx_appt_tenant_time (clinic_uuid, start_at, end_at),
  KEY idx_appt_farm_time (farm_uuid, start_at, end_at),
  KEY idx_appt_individual (individual_uuid),
  KEY idx_appt_org (organizer_vet_user_uuid),

  CONSTRAINT fk_appt_clinic_uuid
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_appt_farm_uuid
    FOREIGN KEY (farm_uuid) REFERENCES farms(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_appt_individual_uuid
    FOREIGN KEY (individual_uuid) REFERENCES individuals(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_appt_organizer_vet
    FOREIGN KEY (organizer_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_appt_created_by_vet
    FOREIGN KEY (created_by_vet_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL,
  CONSTRAINT fk_appt_updated_by_vet
    FOREIGN KEY (updated_by_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_appointments_bi_uuid_v7
BEFORE INSERT ON appointments
FOR EACH ROW
BEGIN
  IF NEW.uuid IS NULL OR NEW.uuid = UNHEX(REPEAT('0',32)) THEN
    SET NEW.uuid = uuid_v7_bin();
  END IF;
END $$

CREATE TRIGGER tr_appointments_bu_rowver
BEFORE UPDATE ON appointments
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


/* =========================================================
   2) 代表アカウントのOAuthトークン（クリニック単位）
   - クリニック削除で自動掃除 → ON DELETE CASCADE
   ========================================================= */
CREATE TABLE clinic_google_tokens (
  id                   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid          BINARY(16) NOT NULL,                 -- ↔ clinics.uuid
  google_email         VARCHAR(255) NOT NULL,
  access_token_enc     TEXT NOT NULL,                       -- 暗号化済み
  refresh_token_enc    TEXT NOT NULL,                       -- 暗号化済み
  token_type           VARCHAR(32) NULL,
  scopes               TEXT NULL,
  expires_at           DATETIME NULL,
  revoked_at           DATETIME NULL,

  row_version          BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_clinic_token (clinic_uuid),
  KEY idx_tokens_list (updated_at, id),
  KEY idx_google_email (google_email),

  CONSTRAINT fk_clinic_token_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_clinic_google_tokens_bu_rowver
BEFORE UPDATE ON clinic_google_tokens
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


/* =========================================================
   3) 共有カレンダー設定（クリニック単位）
   - クリニック削除で自動掃除 → ON DELETE CASCADE
   ========================================================= */
CREATE TABLE clinic_calendar_settings (
  id                          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid                 BINARY(16) NOT NULL,           -- ↔ clinics.uuid
  calendar_id                 VARCHAR(255) NOT NULL,         -- '...@group.calendar.google.com'
  calendar_summary            VARCHAR(255) NULL,
  sync_owner_vet_user_uuid    BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL）

  row_version                 BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at                  DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_clinic_calendar (clinic_uuid),
  KEY idx_calendar_id (calendar_id),
  KEY idx_clinic_calendar_list (updated_at, id),

  CONSTRAINT fk_clinic_calendar_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_clinic_calendar_sync_owner
    FOREIGN KEY (sync_owner_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_clinic_calendar_settings_bu_rowver
BEFORE UPDATE ON clinic_calendar_settings
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


/* =========================================================
   4) Googleイベント対応表（AEL：共有カレンダー1件に集約）
   - テナント境界を保持しつつ、親消滅で掃除 → CASCADE
   - UNIQUE: (clinic_uuid, appointment_uuid, google_calendar_id)
   ========================================================= */
CREATE TABLE appointment_event_links (
  id                     INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid            BINARY(16) NOT NULL,           -- ↔ clinics.uuid（CASCADE）
  appointment_uuid       BINARY(16) NOT NULL,           -- ↔ appointments.uuid（CASCADE）
  google_calendar_id     VARCHAR(255) NOT NULL,
  google_event_id        VARCHAR(255) NOT NULL,
  ical_uid               VARCHAR(255) NULL,
  etag                   VARCHAR(255) NULL,
  writer_vet_user_uuid   BINARY(16) NULL,               -- ↔ vet_users.uuid（SET NULL, 監査用）
  status                 ENUM('pending','synced','failed','deleted','skipped')
                           NOT NULL DEFAULT 'pending',
  synced_at              DATETIME NULL,

  row_version            BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at             DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_link_per_calendar (clinic_uuid, appointment_uuid, google_calendar_id),
  KEY idx_link_gcal (google_calendar_id, google_event_id),
  KEY idx_link_writer (writer_vet_user_uuid),
  KEY idx_ael_list (updated_at, id),

  CONSTRAINT fk_ael_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_ael_appt
    FOREIGN KEY (appointment_uuid) REFERENCES appointments(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_ael_writer_vet
    FOREIGN KEY (writer_vet_user_uuid) REFERENCES vet_users(uuid)
    ON UPDATE CASCADE ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_appointment_event_links_bu_rowver
BEFORE UPDATE ON appointment_event_links
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


/* =========================================================
   5) 差分同期トークン（カレンダー単位）
   - クリニック削除で掃除 → CASCADE
   ========================================================= */
CREATE TABLE calendar_sync_state (
  id            INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid   BINARY(16) NOT NULL,                -- ↔ clinics.uuid（CASCADE）
  calendar_id   VARCHAR(255) NOT NULL,
  sync_token    TEXT NOT NULL,

  row_version   BIGINT UNSIGNED NOT NULL DEFAULT 1,
  updated_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_calendar_sync (clinic_uuid, calendar_id),
  KEY idx_calendar (calendar_id),
  KEY idx_css_list (updated_at, id),

  CONSTRAINT fk_sync_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_calendar_sync_state_bu_rowver
BEFORE UPDATE ON calendar_sync_state
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


/* =========================================================
   6) 予定→実施の疎結合（Visits＝記録 / Appointments＝予定）
   - 親が消えたら紐付けも掃除 → CASCADE
   ========================================================= */
CREATE TABLE appointment_fulfillments (
  id                 INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  clinic_uuid        BINARY(16) NOT NULL,           -- ↔ clinics.uuid（CASCADE）
  appointment_uuid   BINARY(16) NOT NULL,           -- ↔ appointments.uuid（CASCADE）
  visit_uuid         BINARY(16) NOT NULL,           -- ↔ visits.uuid（CASCADE）
  fulfilled_at       DATETIME NOT NULL,
  note               VARCHAR(255) NULL,

  row_version        BIGINT UNSIGNED NOT NULL DEFAULT 1,
  created_at         DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  UNIQUE KEY uq_appt_visit (appointment_uuid, visit_uuid),
  KEY idx_visit (visit_uuid),
  KEY idx_fulfill_list (created_at, id),

  CONSTRAINT fk_fulfill_clinic
    FOREIGN KEY (clinic_uuid) REFERENCES clinics(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_fulfill_appt
    FOREIGN KEY (appointment_uuid) REFERENCES appointments(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT fk_fulfill_visit
    FOREIGN KEY (visit_uuid) REFERENCES visits(uuid)
    ON UPDATE CASCADE ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;

DELIMITER $$
CREATE TRIGGER tr_appointment_fulfillments_bu_rowver
BEFORE UPDATE ON appointment_fulfillments
FOR EACH ROW
BEGIN
  SET NEW.row_version = OLD.row_version + 1;
END $$
DELIMITER ;


-- =========================================================
-- （任意）整合性監視ビュー：ズレ検知
--  A) farmとappointmentsのテナント不一致
--  B) AELとappointmentsのテナント不一致
--  0件であることを健康指標にする
-- =========================================================
/*
CREATE OR REPLACE VIEW v_appt_tenant_mismatch AS
SELECT
  ap.uuid            AS appointment_uuid,
  ap.clinic_uuid     AS appt_clinic,
  f.clinic_uuid      AS farm_clinic,
  ap.farm_uuid,
  ap.start_at, ap.end_at, ap.title
FROM appointments ap
JOIN farms f ON f.uuid = ap.farm_uuid
WHERE ap.deleted_at IS NULL
  AND (ap.clinic_uuid IS NULL OR ap.clinic_uuid <> f.clinic_uuid);

CREATE OR REPLACE VIEW v_ael_tenant_mismatch AS
SELECT
  ael.appointment_uuid,
  ael.clinic_uuid   AS ael_clinic,
  ap.clinic_uuid    AS appt_clinic,
  ael.google_calendar_id,
  ael.google_event_id,
  ap.start_at, ap.end_at, ap.title
FROM appointment_event_links ael
JOIN appointments ap ON ap.uuid = ael.appointment_uuid
WHERE ap.deleted_at IS NULL
  AND (ap.clinic_uuid IS NULL OR ael.clinic_uuid <> ap.clinic_uuid);
*/
<<<END patches/p021_014.appo.sql>>>

<<<FILE patches/p022.1_SAL.sql>>>
-- ============================================================
-- p022.1 : SAL v1（新規インストール統合版）＋ Receiptsヘッダ連携
-- 依存: p017.3（receipt_headers 等が既に存在）, p012系UUIDユーティリティが事前導入
-- ポリシー:
--  - ヘッダ1枚 = 請求1行（farm向け）
--  - 発行後にSPで作成/更新（未配分のみ上書き）/0円・voidedは未配分なら削除
--  - 会計の事実は自動で壊さない（配分済は凍結）
--  - 手修正は差分Onlyログ（sp_save_row_ultralite）
-- ============================================================

SET NAMES utf8mb4;

-- =========================================
-- 1) SAL コア（テーブル & ビュー）
-- =========================================

-- 再実行安全化
DROP VIEW  IF EXISTS v_receivable_open;
DROP TABLE IF EXISTS manual_corrections;
DROP TABLE IF EXISTS receivable_allocations;
DROP TABLE IF EXISTS receivable_credits;
DROP TABLE IF EXISTS receivable_charges;

-- 1-1) 請求（charge）：Receiptsヘッダ由来列を内包
CREATE TABLE receivable_charges (
  uuid                BINARY(16) PRIMARY KEY,
  counterparty_type   ENUM('farm','insurer') NOT NULL,
  counterparty_uuid   BINARY(16) NOT NULL,
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),
  occurred_at         DATETIME NOT NULL,

  -- Receiptsヘッダとの1:1リンク（支払い体験＝ヘッダ単位）
  source_receipt_header_uuid BINARY(16) NULL,

  row_version         BIGINT NOT NULL DEFAULT 0,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uq_rc_source_receipt (source_receipt_header_uuid),
  KEY idx_rcp_ctp_ctu (counterparty_type, counterparty_uuid),
  KEY idx_rcp_occurred (occurred_at),

  CONSTRAINT fk_rc_source_receipt
    FOREIGN KEY (source_receipt_header_uuid) REFERENCES receipt_headers(uuid)
    ON UPDATE RESTRICT
    ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 1-2) クレジット（入金/調整/相殺は正数で統一）
CREATE TABLE receivable_credits (
  uuid                BINARY(16) PRIMARY KEY,
  counterparty_type   ENUM('farm','insurer') NOT NULL,
  counterparty_uuid   BINARY(16) NOT NULL,

  credit_type         ENUM('cash','direct_debit','insurer_payment','adjustment','void','rounding','discount') NOT NULL,
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),
  occurred_at         DATETIME NOT NULL,

  created_by_user_uuid  BINARY(16) NULL,
  created_via           ENUM('ui','import','system','api') NOT NULL DEFAULT 'ui',
  op_reason             VARCHAR(255) NULL,

  row_version         BIGINT NOT NULL DEFAULT 0,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  KEY idx_ccp_ctp_ctu (counterparty_type, counterparty_uuid),
  KEY idx_credit_type (credit_type),
  KEY idx_credit_occurred (occurred_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 1-3) 配分（どのクレジットをどの請求に何円充当したか）
CREATE TABLE receivable_allocations (
  id                  BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  charge_uuid         BINARY(16) NOT NULL,
  credit_uuid         BINARY(16) NOT NULL,
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),

  created_by_user_uuid  BINARY(16) NULL,
  created_via           ENUM('ui','import','system','api') NOT NULL DEFAULT 'ui',
  note                  VARCHAR(255) NULL,

  row_version         BIGINT NOT NULL DEFAULT 0,
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  KEY idx_alloc_charge (charge_uuid),
  KEY idx_alloc_credit (credit_uuid),

  CONSTRAINT fk_alloc_charge FOREIGN KEY (charge_uuid)  REFERENCES receivable_charges(uuid)
    ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT fk_alloc_credit FOREIGN KEY (credit_uuid)  REFERENCES receivable_credits(uuid)
    ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 1-4) 未収ビュー（open = 請求 − 配分合計）
CREATE VIEW v_receivable_open AS
SELECT
  c.uuid               AS charge_uuid,
  c.counterparty_type,
  c.counterparty_uuid,
  c.amount_yen,
  c.occurred_at,
  (c.amount_yen - IFNULL((SELECT SUM(a.amount_yen)
                            FROM receivable_allocations a
                           WHERE a.charge_uuid = c.uuid), 0)
  ) AS open_amount_yen
FROM receivable_charges c;

-- 1-5) 手修正ログ（手動UPDATEのみ差分JSONを記録）
CREATE TABLE manual_corrections (
  id               BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  occurred_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  actor_user_uuid  BINARY(16) NOT NULL,
  actor_name       VARCHAR(128) NULL,

  entity           VARCHAR(64) NOT NULL,
  charge_uuid      BINARY(16) NULL,
  credit_uuid      BINARY(16) NULL,
  alloc_id         BIGINT NULL,

  action           ENUM('update') NOT NULL DEFAULT 'update',
  reason           VARCHAR(255) NOT NULL,
  delta_json       LONGTEXT NOT NULL,

  KEY idx_mcl_charge (charge_uuid),
  KEY idx_mcl_credit (credit_uuid),
  KEY idx_mcl_alloc  (alloc_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- =========================================
-- 2) 汎用：1行保存（差分Onlyログ）
-- =========================================
DELIMITER //

DROP PROCEDURE IF EXISTS sp_save_row_ultralite //
CREATE PROCEDURE sp_save_row_ultralite (
  IN  p_table            VARCHAR(64),
  IN  p_pk_col           VARCHAR(64),
  IN  p_pk_kind          ENUM('uuid','bigint'),
  IN  p_pk_bin           BINARY(16),
  IN  p_pk_bigint        BIGINT,
  IN  p_row_version      BIGINT,
  IN  p_after_json       LONGTEXT,
  IN  p_actor_uuid_bin   BINARY(16),
  IN  p_actor_name       VARCHAR(128),
  IN  p_reason           VARCHAR(255),
  IN  p_entity           VARCHAR(64),
  IN  p_log_key_column   VARCHAR(64)
)
proc: BEGIN
  DECLARE v_pk BLOB;
  DECLARE v_db_ver BIGINT;
  DECLARE v_delta LONGTEXT DEFAULT JSON_OBJECT();
  DECLARE v_changes INT DEFAULT 0;
  DECLARE v_set_csv LONGTEXT DEFAULT '';

  SET v_pk = IF(p_pk_kind='uuid', p_pk_bin, p_pk_bigint);

  START TRANSACTION;

  -- ① row_version ロック取得
  SET @sql_lock := CONCAT(
    'SELECT row_version INTO @dbver FROM `', p_table, '` ',
    'WHERE `', p_pk_col, '`=? FOR UPDATE'
  );
  PREPARE s0 FROM @sql_lock; EXECUTE s0 USING v_pk; DEALLOCATE PREPARE s0;
  SET v_db_ver = @dbver;
  IF v_db_ver IS NULL THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT='404_NOT_FOUND';
  END IF;

  -- ② 楽観ロック
  IF v_db_ver <> p_row_version THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT='409_CONFLICT';
  END IF;

  -- ③ 差分作成
  SET @keys  := JSON_KEYS(p_after_json);
  SET @n     := IFNULL(JSON_LENGTH(@keys), 0);
  SET @i     := 0;
  SET @after := p_after_json;

  WHILE @i < @n DO
    SET @k := JSON_UNQUOTE(JSON_EXTRACT(@keys, CONCAT('$[', @i, ']')));

    SET @sql_col := CONCAT(
      'SELECT `', @k, '` INTO @b FROM `', p_table, '` WHERE `', p_pk_col, '`=?'
    );
    PREPARE s1 FROM @sql_col; EXECUTE s1 USING v_pk; DEALLOCATE PREPARE s1;

    SET @a := JSON_UNQUOTE(JSON_EXTRACT(@after, CONCAT('$.', @k)));

    IF NOT ((@b IS NULL AND @a IS NULL) OR (@b = @a)) THEN
      SET v_delta = JSON_SET(v_delta, CONCAT('$.', @k), JSON_OBJECT('before', @b, 'after', @a));
      SET v_changes = v_changes + 1;

      SET v_set_csv = IF(
        v_set_csv='',
        CONCAT('`', @k, '` = JSON_UNQUOTE(JSON_EXTRACT(@after, ''$.', @k, '''))'),
        CONCAT(v_set_csv, ', `', @k, '` = JSON_UNQUOTE(JSON_EXTRACT(@after, ''$.', @k, '''))')
      );
    END IF;

    SET @i := @i + 1;
  END WHILE;

  -- ④ 差分なし
  IF v_changes = 0 THEN
    COMMIT; SELECT 'NO_CHANGE' AS status; LEAVE proc;
  END IF;

  -- ⑤ 差分UPDATE + row_version +1
  SET @upd := CONCAT(
    'UPDATE `', p_table, '` SET ', v_set_csv, ', `row_version`=`row_version`+1 ',
    'WHERE `', p_pk_col, '`=?'
  );
  PREPARE s2 FROM @upd; EXECUTE s2 USING v_pk; DEALLOCATE PREPARE s2;

  -- ⑥ ログ1行
  SET @ins := CONCAT(
    'INSERT INTO manual_corrections(',
    'occurred_at,actor_user_uuid,actor_name,entity,', p_log_key_column, ',action,reason,delta_json',
    ') VALUES (NOW(), ?, ?, ?, ?, ''update'', ?, ?)'
  );
  PREPARE s3 FROM @ins;
  EXECUTE s3 USING
    p_actor_uuid_bin,
    p_actor_name,
    p_entity,
    v_pk,
    p_reason,
    v_delta;
  DEALLOCATE PREPARE s3;

  COMMIT;
  SELECT 'OK' AS status;
END//

DELIMITER ;

-- =========================================
-- 3) Receiptsヘッダ ↔ SAL 連携SP（発行後に1回CALL）
-- =========================================
DELIMITER $$

DROP PROCEDURE IF EXISTS sp_upsert_charge_for_receipt_header $$
CREATE PROCEDURE sp_upsert_charge_for_receipt_header(
  IN p_header_uuid BINARY(16)
)
proc: BEGIN
  DECLARE v_farm_uuid BINARY(16);
  DECLARE v_issued_at DATETIME;
  DECLARE v_status VARCHAR(10);         -- 'printed' / 'voided' / NULL
  DECLARE v_patient_copay INT UNSIGNED;
  DECLARE v_charge_uuid BINARY(16);
  DECLARE v_alloc_cnt INT DEFAULT 0;

  -- 1) ヘッダ本体（p017.3）
  SELECT h.farm_uuid, h.issued_at, h.status, h.patient_copay_yen
    INTO v_farm_uuid, v_issued_at, v_status, v_patient_copay
  FROM receipt_headers h
  WHERE h.uuid = p_header_uuid
  LIMIT 1;

  IF v_issued_at IS NULL OR v_farm_uuid IS NULL THEN
    LEAVE proc; -- 相手不明や未発行はスキップ
  END IF;

  -- 2) 既存請求（このヘッダ由来）と配分数
  SELECT r.uuid INTO v_charge_uuid
    FROM receivable_charges r
   WHERE r.source_receipt_header_uuid = p_header_uuid
   LIMIT 1;

  IF v_charge_uuid IS NOT NULL THEN
    SELECT COUNT(*) INTO v_alloc_cnt
      FROM receivable_allocations a
     WHERE a.charge_uuid = v_charge_uuid;
  END IF;

  -- 3) 同期ロジック
  IF (v_status IS NULL OR v_status='printed') AND v_patient_copay > 0 THEN
    -- 新規
    IF v_charge_uuid IS NULL THEN
      SET v_charge_uuid = uuid_v7_bin();  -- ← p012のユーティリティを使用
      INSERT INTO receivable_charges(
        uuid, counterparty_type, counterparty_uuid,
        amount_yen, occurred_at, source_receipt_header_uuid
      ) VALUES (
        v_charge_uuid, 'farm', v_farm_uuid,
        v_patient_copay, v_issued_at, p_header_uuid
      );
    -- 更新（未配分のみ）
    ELSEIF v_alloc_cnt = 0 THEN
      UPDATE receivable_charges
         SET counterparty_type = 'farm',
             counterparty_uuid = v_farm_uuid,
             amount_yen        = v_patient_copay,
             occurred_at       = v_issued_at,
             row_version       = row_version + 1
       WHERE uuid = v_charge_uuid;
    END IF;
  ELSE
    -- voided or 0円 → 未配分なら削除
    IF v_charge_uuid IS NOT NULL AND v_alloc_cnt = 0 THEN
      DELETE FROM receivable_charges WHERE uuid = v_charge_uuid;
    END IF;
  END IF;
END $$

-- 3-任意) ヘッダ取消前クリーンアップ（配分有無で削除/リンク切り）
DROP PROCEDURE IF EXISTS sp_cleanup_charge_before_receipt_void $$
CREATE PROCEDURE sp_cleanup_charge_before_receipt_void(
  IN p_header_uuid BINARY(16)
)
proc: BEGIN
  DECLARE v_charge_uuid BINARY(16);
  DECLARE v_alloc_cnt INT DEFAULT 0;

  SELECT r.uuid INTO v_charge_uuid
    FROM receivable_charges r
   WHERE r.source_receipt_header_uuid = p_header_uuid
   LIMIT 1;

  IF v_charge_uuid IS NULL THEN LEAVE proc; END IF;

  SELECT COUNT(*) INTO v_alloc_cnt
    FROM receivable_allocations a
   WHERE a.charge_uuid = v_charge_uuid;

  IF v_alloc_cnt = 0 THEN
    DELETE FROM receivable_charges WHERE uuid = v_charge_uuid;
  ELSE
    UPDATE receivable_charges
       SET source_receipt_header_uuid = NULL,
           row_version = row_version + 1
     WHERE uuid = v_charge_uuid;
  END IF;
END $$

DELIMITER ;

-- ============================================================
-- 使用手順（要点）
--  - 発行後に:  CALL sp_upsert_charge_for_receipt_header(:receipt_header_uuid);
--  - 取消前に:  CALL sp_cleanup_charge_before_receipt_void(:receipt_header_uuid); → その後 status='voided'
--  - 手修正:    CALL sp_save_row_ultralite(...)
-- ============================================================
<<<END patches/p022.1_SAL.sql>>>

<<<FILE patches/p022_SAL.sql>>>
-- ============================================
-- SAL v1 （コメント付き完全版・スキーマ＋監査＋保存SP）
-- ※ “コードに変更なし”。コメントのみ追加。
-- ============================================

-- ------------------------------
-- 1) 請求（charges）：売上（正数）。未収は alloc（配分）で相殺していく。
-- ------------------------------
CREATE TABLE receivable_charges (
  uuid                BINARY(16) PRIMARY KEY,                          -- 行ID（UUID: BINARY(16)）
  counterparty_type   ENUM('farm','insurer') NOT NULL,                 -- 相手先の種別：農家 or 保険会社
  counterparty_uuid   BINARY(16) NOT NULL,                             -- 相手先UUID
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),            -- 請求金額（正数）
  occurred_at         DATETIME NOT NULL,                               -- 発生日（請求日/締め日など）
  row_version         BIGINT NOT NULL DEFAULT 0,                       -- 楽観ロック用バージョン番号

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,     -- 生成時刻（DBサーバ）
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 最終更新時刻

  KEY idx_rcp_ctp_ctu (counterparty_type, counterparty_uuid),          -- 相手先での検索用複合キー
  KEY idx_occurred    (occurred_at)                                    -- 期間検索用
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------------------
-- 2) クレジット（credits）：入金/調整/相殺も“正数”で統一して保存
-- ----------------------------------------
CREATE TABLE receivable_credits (
  uuid                BINARY(16) PRIMARY KEY,                          -- 行ID（UUID）
  counterparty_type   ENUM('farm','insurer') NOT NULL,                 -- 相手先の種別
  counterparty_uuid   BINARY(16) NOT NULL,                             -- 相手先UUID

  credit_type         ENUM(                                            -- 種別（入金/相殺/調整など）
    'cash','direct_debit','insurer_payment','adjustment','void','rounding','discount'
  ) NOT NULL,
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),            -- 金額（常に正）
  occurred_at         DATETIME NOT NULL,                               -- 発生日（入金日/相殺日など）

  -- INSERTはログ不要運用のため、誰がどう作ったかの最小痕跡をここに保存
  created_by_user_uuid  BINARY(16) NULL,                               -- 作成者UUID
  created_via           ENUM('ui','import','system','api') NOT NULL DEFAULT 'ui', -- 生成経路
  op_reason             VARCHAR(255) NULL,                              -- 事由メモ（任意）

  row_version         BIGINT NOT NULL DEFAULT 0,                       -- 手修正を許す場合のために付与

  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,     -- 生成時刻
  updated_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 更新時刻

  KEY idx_ccp_ctp_ctu (counterparty_type, counterparty_uuid),          -- 相手先での検索用
  KEY idx_credit_type (credit_type),                                   -- 種別での分析用
  KEY idx_occurred    (occurred_at)                                    -- 期間分析用
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------------------------------------
-- 3) 配分（allocations）：あるクレジットをどの請求に何円充当したか
-- ----------------------------------------------------------
CREATE TABLE receivable_allocations (
  id                  BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,      -- 行ID（数値）
  charge_uuid         BINARY(16) NOT NULL,                             -- 紐づく請求
  credit_uuid         BINARY(16) NOT NULL,                             -- 紐づくクレジット
  amount_yen          INT NOT NULL CHECK (amount_yen >= 0),            -- 充当金額（正数）

  created_by_user_uuid  BINARY(16) NULL,                               -- 生成者（追跡）
  created_via           ENUM('ui','import','system','api') NOT NULL DEFAULT 'ui', -- 生成経路
  note                  VARCHAR(255) NULL,                              -- 任意メモ

  row_version         BIGINT NOT NULL DEFAULT 0,                       -- 手修正（編集）許可時に使用
  created_at          DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,     -- 生成時刻

  KEY idx_charge (charge_uuid),                                        -- 請求別合計の高速化
  KEY idx_credit (credit_uuid),                                        -- クレジット別合計の高速化
  CONSTRAINT fk_alloc_charge FOREIGN KEY (charge_uuid) REFERENCES receivable_charges(uuid)
    ON DELETE CASCADE ON UPDATE RESTRICT,                              -- 親が消えたら配分も消す
  CONSTRAINT fk_alloc_credit FOREIGN KEY (credit_uuid) REFERENCES receivable_credits(uuid)
    ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ------------------------------------------------------
-- 4) ビュー：請求ごとの未収金額（open_amount_yen）を即時計算
--    ※ open = 請求金額 - その請求に対する配分合計
-- ------------------------------------------------------
CREATE OR REPLACE VIEW v_receivable_open AS
SELECT
  c.uuid               AS charge_uuid,                                  -- 請求ID
  c.counterparty_type,                                                  -- 相手種別
  c.counterparty_uuid,                                                  -- 相手UUID
  c.amount_yen,                                                         -- 請求金額
  c.occurred_at,                                                        -- 請求日
  (c.amount_yen - IFNULL((
     SELECT SUM(a.amount_yen) FROM receivable_allocations a WHERE a.charge_uuid = c.uuid
   ), 0)
  ) AS open_amount_yen                                                  -- 未収金額
FROM receivable_charges c;

-- --------------------------------------------
-- 監査ログ（手修正のみ：UPDATE/DELETE を対象）
-- 差分は delta_json に { col: {before, after}, ... } で保存
-- --------------------------------------------
CREATE TABLE manual_corrections (
  id               BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,          -- 行ID
  occurred_at      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,         -- 記録時刻
  actor_user_uuid  BINARY(16) NOT NULL,                                 -- 操作者UUID
  actor_name       VARCHAR(128) NULL,                                   -- 操作者名（表示用）

  entity           VARCHAR(64) NOT NULL,                                -- 対象テーブル論理名（例: 'receivable_charges'）
  charge_uuid      BINARY(16) NULL,                                     -- 対象キー（請求）
  credit_uuid      BINARY(16) NULL,                                     -- 対象キー（クレジット）
  alloc_id         BIGINT NULL,                                         -- 対象キー（配分）

  action           ENUM('update') NOT NULL DEFAULT 'update',            -- 操作種別（最小：updateのみ）
  reason           VARCHAR(255) NOT NULL,                               -- 手修正の理由（UIで必須入力）
  delta_json       LONGTEXT NOT NULL,                                   -- 差分JSON

  KEY idx_charge (charge_uuid),                                         -- 検索用
  KEY idx_credit (credit_uuid),
  KEY idx_alloc  (alloc_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- =========================================================
-- 汎用 保存＋差分ログ ストアド（UNHEX不要：BINARY(16)直バインド）
-- 1行更新のたびに呼び出し（編集モードで「保存」されたとき）
-- 手順：
-- ① SELECT ... FOR UPDATE で row_version 取得＆行ロック
-- ② 楽観ロック（画面の row_version と一致検証）
-- ③ p_after_json のキーだけ before/after を比較し差分作成
-- ④ 差分ゼロなら NO_CHANGE で終了（row_versionもログも増やさない）
-- ⑤ 差分カラムだけ UPDATE（row_versionを+1）
-- ⑥ manual_corrections に差分JSONを1行INSERT
-- ⑦ COMMIT
-- =========================================================
DELIMITER // 

CREATE PROCEDURE sp_save_row_ultralite (
  IN  p_table            VARCHAR(64),         -- 物理テーブル名（例: 'receivable_charges'）
  IN  p_pk_col           VARCHAR(64),         -- 主キー列名（例: 'uuid' / 'id'）
  IN  p_pk_kind          ENUM('uuid','bigint'), -- 主キー型（uuid/bigint）
  IN  p_pk_bin           BINARY(16),          -- UUID主キーの実値（BINARY(16)）
  IN  p_pk_bigint        BIGINT,              -- BIGINT主キーの実値
  IN  p_row_version      BIGINT,              -- 楽観ロック用 row_version（画面の値）
  IN  p_after_json       LONGTEXT,            -- 変更候補 {列:値,...}（変更した列だけ送る）
  IN  p_actor_uuid_bin   BINARY(16),          -- 操作者UUID（BINARY(16)）
  IN  p_actor_name       VARCHAR(128),        -- 操作者名
  IN  p_reason           VARCHAR(255),        -- 修正理由（必須）
  IN  p_entity           VARCHAR(64),         -- ログ表示用の論理名
  IN  p_log_key_column   VARCHAR(64)          -- manual_corrections側の対象キー列名
)
BEGIN
  DECLARE v_pk BLOB;                 -- WHEREに使う主キー（uuid/bigint を両方受けられる器）
  DECLARE v_db_ver BIGINT;           -- DB上の現行 row_version
  DECLARE v_delta LONGTEXT DEFAULT JSON_OBJECT();  -- 差分JSON（{col:{before,after},...}）
  DECLARE v_changes INT DEFAULT 0;   -- 変更カラム数
  DECLARE v_set_csv LONGTEXT DEFAULT '';           -- UPDATE SET句のCSV

  SET v_pk = IF(p_pk_kind='uuid', p_pk_bin, p_pk_bigint);  -- 主キー実値を決定

  START TRANSACTION;  -- 原子性確保

  -- ① row_version をロック付きで取得（存在しなければ404）
  SET @sql_lock := CONCAT(
    'SELECT row_version INTO @dbver FROM `', p_table, '` ',
    'WHERE `', p_pk_col, '`=? FOR UPDATE'
  );
  PREPARE s0 FROM @sql_lock; EXECUTE s0 USING v_pk; DEALLOCATE PREPARE s0;
  SET v_db_ver = @dbver;
  IF v_db_ver IS NULL THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT='404_NOT_FOUND';
  END IF;

  -- ② 楽観ロック：画面の row_version と一致しなければ競合
  IF v_db_ver <> p_row_version THEN
    ROLLBACK; SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT='409_CONFLICT';
  END IF;

  -- ③ 送信されたキーだけ比較して差分作成（カラム定義の事前取得は不要）
  SET @keys  := JSON_KEYS(p_after_json);              -- 変更候補のキー配列
  SET @n     := IFNULL(JSON_LENGTH(@keys), 0);        -- キー数
  SET @i     := 0;
  SET @after := p_after_json;                          -- 可読性のため別名

  WHILE @i < @n DO
    SET @k := JSON_UNQUOTE(JSON_EXTRACT(@keys, CONCAT('$[', @i, ']')));  -- i番目の列名

    -- before を1カラムだけ取得（行はFOR UPDATE済）
    SET @sql_col := CONCAT(
      'SELECT `', @k, '` INTO @b FROM `', p_table, '` WHERE `', p_pk_col, '`=?'
    );
    PREPARE s1 FROM @sql_col; EXECUTE s1 USING v_pk; DEALLOCATE PREPARE s1;

    -- after は JSON から取得（文字として比較：厳密化したければCASTを追加）
    SET @a := JSON_UNQUOTE(JSON_EXTRACT(@after, CONCAT('$.', @k)));

    IF NOT ((@b IS NULL AND @a IS NULL) OR (@b = @a)) THEN
      -- 差分JSONに {before, after} を記録
      SET v_delta = JSON_SET(v_delta, CONCAT('$.', @k), JSON_OBJECT('before', @b, 'after', @a));
      SET v_changes = v_changes + 1;

      -- UPDATEのSET句に積む（差分カラムだけ）
      SET v_set_csv = IF(
        v_set_csv='',
        CONCAT('`', @k, '` = JSON_UNQUOTE(JSON_EXTRACT(@after, ''$.', @k, '''))'),
        CONCAT(v_set_csv, ', `', @k, '` = JSON_UNQUOTE(JSON_EXTRACT(@after, ''$.', @k, '''))')
      );
    END IF;

    SET @i := @i + 1;
  END WHILE;

  -- ④ 差分なし：row_versionもログも触らず終了
  IF v_changes = 0 THEN
    COMMIT; SELECT 'NO_CHANGE' AS status; LEAVE proc;
  END IF;

  -- ⑤ 差分カラムだけ UPDATE ＋ row_version を +1
  SET @upd := CONCAT(
    'UPDATE `', p_table, '` SET ', v_set_csv, ', `row_version`=`row_version`+1 ',
    'WHERE `', p_pk_col, '`=?'
  );
  PREPARE s2 FROM @upd; EXECUTE s2 USING v_pk; DEALLOCATE PREPARE s2;

  -- ⑥ 差分ログ1行（manual_corrections）
  SET @ins := CONCAT(
    'INSERT INTO manual_corrections(',
    'occurred_at,actor_user_uuid,actor_name,entity,', p_log_key_column, ',action,reason,delta_json',
    ') VALUES (NOW(), ?, ?, ?, ?, ''update'', ?, ?)'
  );
  PREPARE s3 FROM @ins;
  EXECUTE s3 USING
    p_actor_uuid_bin,       -- 操作者UUID（BINARY(16)）
    p_actor_name,           -- 操作者名
    p_entity,               -- 表示用エンティティ名
    v_pk,                   -- 対象キー（uuid: BINARY(16) / bigint: 数値）
    p_reason,               -- 修正理由
    v_delta;                -- 差分JSON
  DEALLOCATE PREPARE s3;

  COMMIT;                      -- 変更とログを同時確定（オールorナッシング）
  SELECT 'OK' AS status;       -- 呼び出し側が見やすいステータス

proc: END//

DELIMITER ;
<<<END patches/p022_SAL.sql>>>

<<<FILE patches/p023_auth.sql>>>

<<<END patches/p023_auth.sql>>>

<<<FILE patches/p024_outbox.sql>>>
SET NAMES utf8mb4;

-- =====================================================================
-- vetDB v1p9 — Outbox / Inbox 新設（BINARY(16) 版・既存関数利用）
-- 依存関数（既存）:
--   • uuid_hex_to_bin(s VARCHAR(36)) RETURNS BINARY(16)
--   • uuid_bin_to_hex(b BINARY(16)) RETURNS CHAR(32)
--   • uuid_v7_bin() RETURNS BINARY(16)
-- 方針:
--   • APIは文字UUID、DBはBINARY(16)。DB-API間の変換はアプリ層で実施。
--   • 時刻はUTC保存（表示でTZ変換）。
--   • ENGINE=InnoDB / utf8mb4 / ROW_FORMAT=DYNAMIC（MariaDB 10.5）
-- =====================================================================


/* ---------------------------------------------------------------------
   Outbox（配信キュー）
   役割:
     - 本体Tx内でイベント行をINSERT（確定と同時に記録）
     - ワーカーが pending を取り出して配信（at-least-once）
   カラム要点:
     - event_uuid   : イベントID（BINARY(16), UNIQUE）
     - aggregate    : 集約名（'visit','checkup','appointment'など）
     - aggregate_id : 対象UUID（BINARY(16)）
     - event_type   : 'created' | 'updated' | 'deleted' など
     - payload_json : スナップショット or 差分（まずはスナップショット推奨）
     - attempts     : 送信試行回数
     - available_at : 次回試行時刻（指数バックオフで再設定）
     - status       : 'pending' | 'sent' | 'failed'
   インデックス:
     - (status, available_at, id): 配信対象スキャンの最適化
     - (aggregate, aggregate_id) : 対象別の監査/再送用
   --------------------------------------------------------------------- */
DROP TRIGGER IF EXISTS tr_outbox_messages_bi_uuid_v7;

CREATE TABLE IF NOT EXISTS outbox_messages (
  id             BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,          -- 配信順の近似
  event_uuid     BINARY(16)  NOT NULL UNIQUE,                         -- イベントUUID（BINARY16）
  aggregate      VARCHAR(64) NOT NULL,                                -- 集約名
  aggregate_id   BINARY(16)  NOT NULL,                                -- 対象UUID（BINARY16）
  event_type     VARCHAR(64) NOT NULL,                                -- created/updated/deleted 等
  payload_json   JSON        NOT NULL,                                -- MariaDB 10.5: 実体はLONGTEXT
  attempts       INT UNSIGNED NOT NULL DEFAULT 0,                     -- 試行回数
  available_at   DATETIME    NOT NULL DEFAULT CURRENT_TIMESTAMP,      -- 次回試行（UTC）
  status         ENUM('pending','sent','failed') NOT NULL DEFAULT 'pending',
  created_at     DATETIME    NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     DATETIME    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_outbox_status_available (status, available_at, id),
  INDEX idx_outbox_aggregate (aggregate, aggregate_id)
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci
  ROW_FORMAT = DYNAMIC;

-- 既存の uuid_v7_bin() を利用して event_uuid を自動付与
DELIMITER //
CREATE TRIGGER tr_outbox_messages_bi_uuid_v7
BEFORE INSERT ON outbox_messages
FOR EACH ROW
BEGIN
  IF NEW.event_uuid IS NULL THEN
    SET NEW.event_uuid = uuid_v7_bin();           -- 既存: 擬似v7のBINARY(16)
    -- v7でなくてよければ下記でも可（どちらか片方のみ利用）
    -- SET NEW.event_uuid = uuid_hex_to_bin(uuid());
  END IF;
END//
DELIMITER ;


-- ---------------------------------------------------------------------
-- Inbox（Idempotency-Key 重複排除）
-- 役割:
--   - 同一Idempotency-Keyの多重適用を防止（Tx内で挿入して確定）
-- ---------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS inbox_processed (
  idempotency_key VARCHAR(128) PRIMARY KEY,                            -- クライアント送信ユニークキー
  processed_at    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP          -- 初回処理時刻（UTC）
) ENGINE=InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_unicode_ci
  ROW_FORMAT = DYNAMIC;


-- =====================================================================
-- 参考: ワーカー/APIでの利用例（DDL外、実装時のSQLイメージ）
-- 1) 取得（最大100件、pending & 期限到来）
--    UUIDを「32桁HEX（ダッシュ無し）」で返したい場合は uuid_bin_to_hex() を使用。
--    「36桁ダッシュ形式」が必要なら下段の式例を利用（既存関数のみで実現可）。
-- =====================================================================

/*
-- 32桁HEXで返す例（既存: uuid_bin_to_hex）
SELECT id,
       uuid_bin_to_hex(event_uuid)   AS event_uuid_hex,
       aggregate,
       uuid_bin_to_hex(aggregate_id) AS aggregate_id_hex,
       event_type, payload_json, attempts
FROM outbox_messages
WHERE status='pending'
  AND available_at <= UTC_TIMESTAMP()
ORDER BY id
LIMIT 100;

-- 36桁ダッシュ形式で返す場合（関数追加せず式で対応）
SELECT id,
       LOWER(CONCAT(
         SUBSTR(HEX(event_uuid),1,8),'-',
         SUBSTR(HEX(event_uuid),9,4),'-',
         SUBSTR(HEX(event_uuid),13,4),'-',
         SUBSTR(HEX(event_uuid),17,4),'-',
         SUBSTR(HEX(event_uuid),21,12)
       )) AS event_uuid_str,
       aggregate,
       LOWER(CONCAT(
         SUBSTR(HEX(aggregate_id),1,8),'-',
         SUBSTR(HEX(aggregate_id),9,4),'-',
         SUBSTR(HEX(aggregate_id),13,4),'-',
         SUBSTR(HEX(aggregate_id),17,4),'-',
         SUBSTR(HEX(aggregate_id),21,12)
       )) AS aggregate_id_str,
       event_type, payload_json, attempts
FROM outbox_messages
WHERE status='pending'
  AND available_at <= UTC_TIMESTAMP()
ORDER BY id
LIMIT 100;

-- 成功時の更新
UPDATE outbox_messages
   SET status='sent', updated_at=UTC_TIMESTAMP()
 WHERE id IN (...);

-- 失敗時の指数バックオフ（例：2^attempts 秒、上限はアプリ側で制御）
UPDATE outbox_messages
   SET attempts = attempts + 1,
       available_at = DATE_ADD(UTC_TIMESTAMP(), INTERVAL LEAST(3600, POW(2, attempts)) SECOND),
       status = IF(attempts+1 >= 10, 'failed', 'pending'),
       updated_at = UTC_TIMESTAMP()
 WHERE id = ?;
*/
<<<END patches/p024_outbox.sql>>>

